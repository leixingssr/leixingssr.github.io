{"title":"Java面试","uid":"23ac8df41cab07b7baa7284b723ffed2","slug":"Java面试","date":"2023-02-24T14:05:35.000Z","updated":"2023-02-24T15:00:44.605Z","comments":true,"path":"api/articles/Java面试.json","keywords":null,"cover":"https://images.alphacoders.com/603/603479.png","content":"<p><strong>&#x3D;&#x3D; 和 equals 的区别是什么</strong></p>\n<p>&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是内存地址；而 equals 默认情况下是地址引用比较（对象（对象内容）是否相等），只是很多类重新了 equals 方法，比如 String、Integer 等；</p>\n<p><strong>8大基本数据类型</strong></p>\n<p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double，</p>\n<p>整型byte short int long 浮点类型float double 布尔型boolean 字符型char</p>\n<p>引用类型类，接口，枚举，数组</p>\n<p>而 String 属于对象。</p>\n<p>J<strong>ava</strong> <strong>中操作字符串都有哪些类？它们之间有什么区别？</strong></p>\n<p>String、StringBuffer、StringBuilder。</p>\n<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>\n<p>String不可变，StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>\n<p><strong>如何将字符串反转</strong></p>\n<ul>\n<li>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</li>\n<li>replace()：字符串替换。</li>\n<li>trim()：去除字符串两端空白。</li>\n<li>split()：分割字符串，返回一个分割后的字符串数组。</li>\n<li>length()：返回字符串长度。</li>\n<li>substring()：截取字符串。</li>\n</ul>\n<p><strong>接口和抽象类有什么区别</strong></p>\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n构造函数：抽象类可以有构造函数；接口不能有。</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>\n</li>\n</ul>\n<p><strong>Java</strong> <strong>中 IO 流分为几种</strong></p>\n<p>按<strong>功能</strong>来分：输入流（input）、输出流（output）。</p>\n<p>按<strong>类型</strong>来分：字节流和字符流。</p>\n<p><strong>BIO、NIO、AIO 有什么区别？</strong></p>\n<ul>\n<li><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>\n</li>\n<li><p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>\n</li>\n<li><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>\n</li>\n</ul>\n<p><strong>HashMap</strong> <strong>和 Hashtable 有什么区别</strong></p>\n<p>HashMap的键和值都允许有null值存在，而HashTable则不行。</p>\n<p>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</p>\n<p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>\n<p><strong>说一下 HashMap 的实现原理</strong></p>\n<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>\n<p>HashMap 底层是由数组加链表实现的,当调用put方法储存键值对时,HashMap会根据key的hashCode值,进行计算确定存放位置,当发生hash计算结果一致时,会将数据链接到前一个数据的后面,当链表长度过长时,会将链表转化为红黑树,提高查询效率。</p>\n<p><strong>java中的HashSet,内部是如何工作的</strong></p>\n<p>HashSet的内部采用HashMap来实现。由于Map需要key和value,所以所有key的都有一个默认value。类似于HashMap,HashSet不允许重复的key,只允许有一个null,意思就是HashSet中只允许存储一个nul对象。</p>\n<p><strong>深拷贝和浅拷贝的区别</strong></p>\n<p><strong>浅拷贝</strong>：只是将引用指向存在的内存地址，新旧对象共用内存地址，修改其中一个对象的值，另一个对象的值也随之改变。</p>\n<p><strong>深拷贝</strong>：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。</p>\n<p><strong>ArrayList</strong> <strong>和 LinkedList 的区别是什么</strong></p>\n<ul>\n<li><strong>数据结构实现</strong>：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n<li><strong>随机访问效率</strong>：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n<li><strong>增加和删除效率</strong>：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n</ul>\n<p><strong>ArrayList</strong> <strong>和 Vector 的区别是什么</strong></p>\n<ul>\n<li><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p>\n</li>\n<li><p>性能：ArrayList 在性能方面要优于 Vector。</p>\n</li>\n<li><p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>\n</li>\n</ul>\n<p><strong>Integer与int的区别</strong></p>\n<p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。在数据库实体和数据表映射设计中一般将属性设置为保证类型。</p>\n<p><strong>是否可以继承String类?</strong> </p>\n<p>String类是final类故不可以继承。 </p>\n<p><strong>请写出你最常见到的5个异常</strong></p>\n<ol>\n<li><p>NullPointException(空指针异常)</p>\n</li>\n<li><p>ArrIndexOutOfBoundsException（数组越界异常）</p>\n</li>\n<li><p>ClassCastException(类型转换异常)</p>\n</li>\n<li><p>FileNotFoundException 文件找不到异常</p>\n</li>\n<li><p>ConnectException 连接异常，连接超时，拒绝连接</p>\n</li>\n<li><p>NotSerializableException</p>\n</li>\n</ol>\n<p><strong>重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？</strong></p>\n<p>​\t\t方法的重载和重写都是实现多态的方式，区别在重载是编译时的多态性，而多态是运行时的多态性。重载发生同一个类中，两个同名的方法以为参数类型，参数顺序，参数个数不同；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，重写方法的访问权限要和父类相同或者更易被访问。重载对返回类型没有特殊的要求。方法名一致，参数列表中参数的顺序，类型，个数不同。所以方法返回值类型无法实现重载。。</p>\n<p><strong>final、finally、finalize区别</strong></p>\n<ul>\n<li><strong>final</strong>：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可被继承。</li>\n<li><strong>finally</strong>：异常处理语句结构的一部分，表示不管抛不拋异常都执行。</li>\n<li><strong>finalize</strong>：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>\n</ul>\n<p><strong>Lock和Synchronized的区别</strong></p>\n<p>Lock是接口，synchronized是关键字</p>\n<p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。Synchronized,会一直获取，借助这个特性可以规避死锁。</p>\n<p>synchronized在发生异常和同步代码块结束的时候，会自动释放锁，Lock必须手动释放，所以如果忘记释放锁，也会造成死锁。</p>\n<p><strong>&amp;</strong> <strong>和</strong> <strong>&amp;&amp;</strong> <strong>的区别</strong></p>\n<ol>\n<li><p>一个是位运算，一个是逻辑运算。</p>\n</li>\n<li><p>&amp;运算符是：逻辑与；&amp;&amp;运算符是：短路与。</p>\n</li>\n</ol>\n<p><strong>String类常用方法</strong></p>\n<ul>\n<li><p>length：获取字符串长度。</p>\n</li>\n<li><p>substring：截取字符串。</p>\n</li>\n<li><p>replace：替换字符串。</p>\n</li>\n<li><p>trim：去除字符串两端空格。</p>\n</li>\n</ul>\n<p><strong>jdk和jre的区别</strong></p>\n<p>JRE是java运行时环境。</p>\n<p>JDK是java开发工具包，JDK包含JRE，但是JRE可以独立安装。</p>\n<p><strong>Collection 和 Collections的区别</strong></p>\n<p>Collection 提供了对集合对象进行基本操作的通用接口方法。继承接口有List与Set。</p>\n<p>Collections是工具类，主要功能有用于对集合中元素进行排序、搜索以及线程安全等。</p>\n<p><strong>java迭代器Iterator 是什么</strong></p>\n<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java中的Iterator功能比较简单，并且只能单向移动。</p>\n<p><strong>Runnable和Callable的区别如下</strong></p>\n<p>Callable规定的方法是call(),Runnable规定的方法是run().</p>\n<p>Callable的任务执行后可返回值，而Runnable的任务是不能返回值得。</p>\n<p>call方法可以抛出异常，run方法不可以。</p>\n<p><strong>synchronized</strong> <strong>和</strong> <strong>Lock</strong> <strong>有什么区别</strong></p>\n<p>1.synchronized是关键字,Lock是接口;</p>\n<p>2.synchronized是隐式的加锁,lock是显式的加锁;</p>\n<p>3.synchronized可以作用于方法上,lock只能作用于方法块;</p>\n<p>4.synchronized底层采用的是objectMonitor,lock采用的AQS;</p>\n<p><strong>synchronized的用法有哪些</strong></p>\n<ul>\n<li><p>修饰普通方法：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁。</p>\n</li>\n<li><p>修饰静态方法：作用于当前类，进入同步代码前要获得当前类对象的锁。</p>\n</li>\n<li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>\n</li>\n</ul>\n<p><strong>volatile和synchronized的区别是什么？</strong></p>\n<ul>\n<li><p>volatile只能使用在变量上；而synchronized可以在类，变量，方法和代码块上。</p>\n</li>\n<li><p>volatile至保证可见性；synchronized保证原子性与可见性。</p>\n</li>\n<li><p>volatile禁用指令重排序；synchronized不会。</p>\n</li>\n<li><p>volatile不会造成阻塞；synchronized会。</p>\n</li>\n</ul>\n","feature":"ture","text":"&#x3D;&#x3D; 和 equals 的区别是什么 &#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是内存地址；而 equals 默认情况下是地址引用比较（对象（对象内容）是否相等），只是很多类重新了 eq...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":4,"path":"api/tags/面试.json"}],"toc":"","author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"mapped":true,"prev_post":{"title":"框架面试","uid":"ad513d9238aebc54d31cd7ff3f640644","slug":"框架面试","date":"2023-02-24T14:06:01.000Z","updated":"2023-02-24T15:02:13.803Z","comments":true,"path":"api/articles/框架面试.json","keywords":null,"cover":"https://img.99tu.com:9988/uploads/allimg/201124/2-201124213320.jpg#文章在首页时的预览图，以及文章页的背景图","text":"spring 常用的注入方式 setter 属性注入 构造方法注入 注解方式注入 spring 中的 bean 是线程安全 spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。 sp...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":4,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"},"next_post":{"title":"Git","uid":"221a7ad001c03569112f684b2dfdc120","slug":"Git","date":"2022-12-15T13:55:09.000Z","updated":"2023-03-01T06:59:37.065Z","comments":true,"path":"api/articles/Git.json","keywords":null,"cover":"https://rare-gallery.com/thumbnail/407927-WLOP-women-two-women-digital-art-ArtStation-fantasy-art.jpg#文章在首页时的预览图，以及文章页的背景图","text":"GitGit 是基于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"工具","slug":"工具","count":2,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":2,"path":"api/tags/工具.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"}}