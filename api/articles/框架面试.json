{"title":"框架面试","uid":"ad513d9238aebc54d31cd7ff3f640644","slug":"框架面试","date":"2023-02-24T14:06:01.000Z","updated":"2023-03-14T14:05:03.649Z","comments":true,"path":"api/articles/框架面试.json","keywords":null,"cover":"https://img.99tu.com:9988/uploads/allimg/201124/2-201124213320.jpg#文章在首页时的预览图，以及文章页的背景图","content":"<p><strong>spring</strong> <strong>常用的注入方式</strong></p>\n<ul>\n<li>setter 属性注入</li>\n<li>构造方法注入</li>\n<li>注解方式注入</li>\n</ul>\n<p><strong>spring</strong> <strong>中的 bean 是线程安全</strong></p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n<p><strong>spring</strong> <strong>支持几种 bean 的作用域</strong></p>\n<p>spring 支持 5 种作用域</p>\n<ul>\n<li><p>singleton：单例bean，容器存在之后，使用不需要创建。</p>\n</li>\n<li><p>prototype：每次从容器调用 bean 时都会创建一个新的示例。</p>\n</li>\n</ul>\n<p>Web环境下的作用域：</p>\n<ul>\n<li><p>request：每次 http 请求都会创建一个 bean；</p>\n</li>\n<li><p>session：同一个 http session 共享一个 bean 实例；</p>\n</li>\n<li><p>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p></blockquote>\n<p><strong>spring 自动装配 bean 有哪些方式</strong></p>\n<p>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</p>\n<p>byName：它根据 bean 的名称注入对象依赖项。</p>\n<p>byType：它根据类型注入对象依赖项。</p>\n<p><strong>spring</strong> <strong>事务实现方式有哪些</strong></p>\n<p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</p>\n<p>编程式事务：提供编码的形式管理和维护事务。</p>\n<p><strong>说一下 spring 的事务隔离</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致。</p></blockquote>\n<ul>\n<li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么。</p>\n</li>\n<li><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>\n</li>\n<li><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别。</p>\n</li>\n<li><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>\n</li>\n<li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>\n</li>\n</ul>\n<p><strong>说一下 spring mvc 运行流程</strong></p>\n<ul>\n<li>spring mvc 先将请求发送给 DispatcherServlet  ( 前端控制器)。</li>\n<li>DispatcherServlet 查询一个或多个 HandlerMapping（处理器映射器）  ,找到处理请求的 Controller。</li>\n<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>\n<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>\n<li>DispatcherServlet 查询一个或多个视图解析器，找到 ModelAndView 对象指定的视图对象。</li>\n<li>视图对象负责渲染返回给客户端。</li>\n</ul>\n<p><strong>为什么要用 spring boot</strong></p>\n<ol>\n<li>配置简单。不需要强制配置XML，遵循“约定大于配置” 。</li>\n<li>集成了大量常用的第三方库的配置（start），提供了几乎可以零配置的开箱即用的能力。</li>\n</ol>\n<p><strong>什么是bean的自动装配</strong></p>\n<p>无须在Spring配置文件中描述javaBean之间的依赖关系。IOC容器会自动建立javabean之间的关联关系。</p>\n<p><strong>IoC</strong></p>\n<p>IoC即控制反转，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述让容器知道要创建的对象间的关系，在Spring中管理对象及其依赖关系是通过Spring的IoC容器实现的。IoC的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此IoC也叫做依赖注入。</p>\n<p><strong>依赖注入的相关注解</strong></p>\n<ul>\n<li>@Autowired</li>\n<li>@Qualifier</li>\n<li>@Resource</li>\n<li>@Value</li>\n</ul>\n<p><strong>BeanFactory、FactoryBean和ApplicationContext的区别</strong></p>\n<ul>\n<li><p>BeanFactory是一个bean工厂，它是Spring中工厂的顶层规范接口，它定义了getBean()等管理Bean的通用方法。</p>\n</li>\n<li><p>FactoryBean是一个工厂Bean,使用了工厂方法模式，作用是生产其他Bean实例。</p>\n</li>\n<li><p>ApplicationConext是BeanFactory的子接口，扩展了BeanFactory的功能。</p>\n</li>\n</ul>\n<p><strong>解释Spring框架中bean的生命周期。</strong></p>\n<p>Spring Bean的生命周期主要分为四个阶段：实例化 Instantiation –&gt; 属性赋值 Populate –&gt; 初始化 Initialization –&gt; 销毁 Destruction。</p>\n<p><strong>Spring</strong> <strong>都用到哪些设计模式</strong></p>\n<ul>\n<li>工厂模式，spring的 IOC容器就是使用了工厂设计模式。</li>\n<li>模板方法， JdbcTemplate。</li>\n<li>代理模式，AOP 整的都是代理。</li>\n<li>单例，IOC容器里面的bean默认都是单例设计模式。</li>\n<li>责任链模式，比如拦截器</li>\n<li>观察者模式，Spring里的监听器</li>\n<li>适配器模式 SpringMVC 提到的 handlerApdaper</li>\n</ul>\n","feature":"ture","text":"spring 常用的注入方式 setter 属性注入 构造方法注入 注解方式注入 spring 中的 bean 是线程安全 spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。 sp...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":5,"path":"api/tags/面试.json"}],"toc":"","author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"mapped":true,"prev_post":{"title":"Mysql面试","uid":"5c9c7d24e42be581f1bc83d2d55ba0fd","slug":"Mysql面试","date":"2023-02-24T14:06:20.000Z","updated":"2023-03-02T09:42:05.616Z","comments":true,"path":"api/articles/Mysql面试.json","keywords":null,"cover":"https://images.alphacoders.com/640/640985.jpg#文章在首页时的预览图，以及文章页的背景图","text":"数据库的三范式是什么 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 第三范式：任何非主属性不依赖于其它非主属性 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":5,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"},"next_post":{"title":"Java面试","uid":"23ac8df41cab07b7baa7284b723ffed2","slug":"Java面试","date":"2023-02-24T14:05:35.000Z","updated":"2023-02-24T15:00:44.605Z","comments":true,"path":"api/articles/Java面试.json","keywords":null,"cover":"https://images.alphacoders.com/603/603479.png","text":"&#x3D;&#x3D; 和 equals 的区别是什么 &#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是内存地址；而 equals 默认情况下是地址引用比较（对象（对象内容）是否相等），只是很多类重新了 eq...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":5,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"}}