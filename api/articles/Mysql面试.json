{"title":"Mysql面试","uid":"5c9c7d24e42be581f1bc83d2d55ba0fd","slug":"Mysql面试","date":"2023-02-24T14:06:20.000Z","updated":"2023-03-02T09:42:05.616Z","comments":true,"path":"api/articles/Mysql面试.json","keywords":null,"cover":"https://images.alphacoders.com/640/640985.jpg#文章在首页时的预览图，以及文章页的背景图","content":"<p><strong>数据库的三范式是什么</strong></p>\n<p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>\n<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>\n<p>第三范式：任何非主属性不依赖于其它非主属性</p>\n<p><strong>说一下</strong> <strong>ACID</strong> <strong>是什么</strong></p>\n<ul>\n<li><p>原子性：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。</p>\n</li>\n<li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p>\n</li>\n<li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p>\n</li>\n<li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n</li>\n</ul>\n<p><strong>MySQL</strong> <strong>的内连接、左连接、右连接有什么区别？</strong></p>\n<ul>\n<li><p><strong>内连接</strong>：返回两张表中满足连接条件的记录</p>\n</li>\n<li><p><strong>左连接</strong>：返回左边表的所有记录，右边表只返回满足连接条件的记录，匹配不到的记录连接null</p>\n</li>\n</ul>\n<p><strong>说一下数据库的事务隔离</strong></p>\n<p><strong>读未提交</strong>：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>\n<p><strong>读已提交</strong>：一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>\n<p><strong>可重复读</strong>：默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p>\n<p><strong>串行化</strong>：代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。事务A和事务B，事务A在操作数据库时，事务B只能排队等待。</p>\n<p><strong>MySQL的锁</strong></p>\n<p>MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p>\n<p><strong>索引分为那几类？</strong></p>\n<p>从大类来分：分为<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>；</p>\n<p>从种类来分有：</p>\n<ul>\n<li><strong>主键索引</strong>: 也简称主键。它可以提高查询效率，并提供唯一性约束。一张表中只能有一个主键。</li>\n<li><strong>普通索引</strong>：就是普普通通的索引。</li>\n<li><strong>唯一索引</strong>：索引的值不能重复。</li>\n<li><strong>复合索引</strong>：在工作中用得比较频繁的一个索引；</li>\n</ul>\n<p><strong>为什么索引是使用B+树？</strong></p>\n<ol>\n<li><p>B+树会将所有数据存放在叶子节点上，组成一个有序的双向链表，便于范围查询</p>\n</li>\n<li><p>非叶子节点只储存索引列值可以储存更多数据，降低树的深度,一次IO操作可以检索出更多的列值，</p>\n</li>\n</ol>\n<p><strong>什么叫回表？</strong></p>\n<p>查询先走非聚簇最终只能得到主键值,拿着辅助索引查询出来的主键去聚簇索引中进行查询，这个过程就是叫回表。</p>\n<p><strong>什么叫索引覆盖？</strong></p>\n<p>查询走非聚簇索引的，通过非聚簇索引就直接获取到我们想要的全部数据了，不需要进行回表查询全部数据，这个过程就叫做索引覆盖；</p>\n<p><strong>什么是最左前缀原则</strong></p>\n<p>在MySQL建立联合索引时会遵守最左前缀匹配原则，在检索数据时从检索条件字段顺序需要联合建立索引始从左往右匹配,并且不跳过索引中的列,如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>\n<p><strong>MySQL索引失效的几种情况</strong></p>\n<ol>\n<li>使用or作为连接条件，只有两边字段都需要建立索引，有一个没有则索引失效。</li>\n<li>复合索引不满足最左原则就不能使用全部索引</li>\n<li>like查询以%开头</li>\n<li>存在列计算</li>\n<li>如果mysql估计使用全表扫描要比使用索引快，则不使用索引，比如结果的量很大</li>\n<li>存在类型转化</li>\n</ol>\n<p><strong>常见的索引优化手段有哪些</strong></p>\n<ul>\n<li>①查询的时候尽量不要使用select * ，这样可以避免大量的回表；</li>\n<li>②插入多条记录时，应使用批量插入语句.。</li>\n<li>③在设计主键id的表中，尽量使用自增主键id，这样可以避免页分裂；</li>\n<li>④在使用order b进行排序时，应该选着建立索引的字段作为排序条件</li>\n<li>⑤在使用连接查询时，应该尽量使用内连接而非左连接</li>\n<li>⑥在使用索引查询时，应该尽量避免回表查询，尽量做到索引覆盖</li>\n<li>⑥在使用联合索引时，应该遵循最左前缀原则，避免索引失效</li>\n<li>⑥在查询记录只有一条时，应该在语句加上limit 1。</li>\n</ul>\n<p><strong>什么是聚簇索引</strong></p>\n<p>将索引列和数据存放在一起，通过索引也就找到了全部数据</p>\n<p><strong>哪些情况下不适合建索引</strong></p>\n<ul>\n<li><p>1.频繁更新的字段不适合建立索引</p>\n</li>\n<li><p>2.where条件中用不到的字段不适合建立索引</p>\n</li>\n<li><p>3.表数据可以确定比较少的不需要建索引</p>\n</li>\n<li><p>4.数据重复且分布均匀的的字段不适合建索引例如性别，真假值。</p>\n</li>\n<li><p>5.参与列计算的列不适合建索引，索引会失效</p>\n</li>\n</ul>\n<p><strong>MySQL实现乐观锁</strong></p>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n","feature":"ture","text":"数据库的三范式是什么 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 第三范式：任何非主属性不依赖于其它非主属性 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":4,"path":"api/tags/面试.json"}],"toc":"","author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"mapped":true,"prev_post":{"title":"Redis面试","uid":"9864cb5f05af74d955a88eab7d87ec93","slug":"Redis面试","date":"2023-02-24T14:06:48.000Z","updated":"2023-02-24T14:53:49.234Z","comments":true,"path":"api/articles/Redis面试.json","keywords":null,"cover":"https://images2.alphacoders.com/648/648566.jpg#文章在首页时的预览图，以及文章页的背景图","text":"Redis 支持的数据类型有哪些 Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。 什么是缓存穿透？怎么解决？ 缓存穿透：指查询一个一定不存在的数据，由于缓存是不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":4,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"},"next_post":{"title":"框架面试","uid":"ad513d9238aebc54d31cd7ff3f640644","slug":"框架面试","date":"2023-02-24T14:06:01.000Z","updated":"2023-02-24T15:02:13.803Z","comments":true,"path":"api/articles/框架面试.json","keywords":null,"cover":"https://img.99tu.com:9988/uploads/allimg/201124/2-201124213320.jpg#文章在首页时的预览图，以及文章页的背景图","text":"spring 常用的注入方式 setter 属性注入 构造方法注入 注解方式注入 spring 中的 bean 是线程安全 spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。 sp...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":4,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"}}