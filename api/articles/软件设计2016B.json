{"title":"软件设计2016B","uid":"1e4363102957705e71b03727a248bf78","slug":"软件设计2016B","date":"2022-12-06T07:01:51.000Z","updated":"2022-12-06T07:27:10.702Z","comments":true,"path":"api/articles/软件设计2016B.json","keywords":null,"cover":null,"content":"<h1 id=\"软件设计B\"><a href=\"#软件设计B\" class=\"headerlink\" title=\"软件设计B\"></a>软件设计B</h1><h2 id=\"选择题（每小题2分，共30分）\"><a href=\"#选择题（每小题2分，共30分）\" class=\"headerlink\" title=\"选择题（每小题2分，共30分）\"></a>选择题（每小题2分，共30分）</h2><p>对于依赖倒转的表述错误的是（  D  ）<br>A. 依赖于抽象而不依赖于具体，也就是针对接口编程。<br>B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道的方法集合。<br>C. 从选项B的角度论述，一个对象可以有多个接口。<br><strong>D. 此题没有正确答案。</strong></p>\n<p>以下意图那个是用来描述桥接模式? （  B  ）<br>A. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>B. 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</strong><br>C. 将一个复杂对象的构建与它的表示分离，使得同样构建过程可以创建不同的表示。<br>D. 动态地给一个对象添加一些额外的职责。</p>\n<p>以下属于属于创建型设计模式的是（  C  ）。<br>A．外观模式           \t\t\t\t  B．中介模式<br><strong>C．抽象工厂</strong>           \t\t\t\t  D．命令模式</p>\n<p>对象组合的有点表述不当的是（ D   ）<br>A. 容器类仅能通过被包含对象的接口来对其进行访问。<br>B. “黑盒” 复用，封装性好，因为被包含对象的内部细节对外是不可见。<br>C. 通过获取指向其它的具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合<br><strong>D.造成极其严重的依赖关系。</strong></p>\n<p>在应用程序开发中那种设计模式可以用于分离出算法（  A  ）。<br><strong>A. 策略模式</strong>       \t\t\t\t      B. 中介模式<br>C. 组合模式          \t\t\t\t\t  D. 适配器模式</p>\n<p>下列不属于结构型设计模式的是（  A  ）。<br><strong>A．命令模式</strong>               \t\t\t  B．适配器模式<br>C．组合模式              \t\t\t\t  D．外观模式</p>\n<p>当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（  A  ）模式。<br><strong>A.创建型</strong>  \t\t\t\t\t\t\t  B.结构型<br>C行为型 \t\t\t\t\t\t\t\t  D.以上都可以</p>\n<p>在观察者模式中，表述错误的是（  C  ）<br>A.观察者角色的更新是被动的。<br>B.被观察者可以通知观察者进行更新<br><strong>C.观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进行。</strong><br>D.以上表述全部错误。</p>\n<p>开闭原则的含义是一个软件实体（  A  ）。<br><strong>A．应该对扩展开发，对修改关闭</strong>           B．对修改开放，对扩展关闭<br>C．在应用子类的地方可以使用父类代替     D．应该尽可能的使用大粒度的类实现</p>\n<p>关于继承表述错误的是：（  D  ）<br>A.继承是一种通过扩展一个已有对象的实现，从而获得新功能的复用方法。<br>B.泛化类（超类）可以显式地捕获那些公共的属性和方法。特殊类（子类）则通过附加属性和方法来进行实现的扩展。<br>C.破坏了封装性，因为这会将父类的实现细节暴露给子类。<br><strong>D.继承本质上是“白盒复用”，对父类的修改，不会影响到子类。</strong></p>\n<p>设计模式一般是用来解决什么问题的（  A  ）。<br><strong>A．同一问题的不同表象</strong>\t\t\t\t     B．测试用例的设计<br>C．编码中如何组织代码               \t D． 需求获取中业务领域知识获取的问题</p>\n<p>以下意图那个是用来描述 ITERATOR(迭代器)? （  C  ）<br>A.使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。<br>B.用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>C.提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示</strong>。<br>D.运用共享技术有效地支持大量细粒度的对象。</p>\n<p>下图结构图描述的是那种 模式? （A    ）</p>\n<p>  <strong>A.\tABSTRACT FACTORY（抽象工厂</strong>）<br>  B. FACTORY METHOD（工厂方法）<br>  C. BUILDER（生成器）<br>  D. BRIDGE（桥接）</p>\n<p>下图结构图描述的是那种模式? （  C  ）</p>\n<p>  A.\tSTRATEGY(策略)<br>  B.\tOBSERVER（观察者）<br>  <strong>C.\tADAPTER（适配器）</strong><br>  D. BUILDER（生成器）</p>\n<p>下列模式中,属于行为模式的是（ B   ）<br>    A. 工厂模式 \t\t\t\t\t\t <strong>B. 观察者</strong><br>    C. 适配器 \t\t\t\t\t\t D. 以上都是</p>\n<h2 id=\"填空题（每空1分，共20分）\"><a href=\"#填空题（每空1分，共20分）\" class=\"headerlink\" title=\"填空题（每空1分，共20分）\"></a>填空题（每空1分，共20分）</h2><p>  工厂模式分为 <strong>简单工厂</strong>，<strong>工厂模式</strong>，<strong>抽象工厂</strong> 三种类型。</p>\n<p>创立型模式的根本意图是要把  <strong>对象的创建</strong> 和  <strong>使用分离</strong>____的责任进行分离，从而降低系统的_耦合度___。</p>\n<p>面向对象的七条基本原则包括：开<strong>闭原则，里式代换原则，合成聚合原则，依赖倒转，迪米特法则，单一原则，接口隔离</strong></p>\n<p>在存在继承关系的情况下，方法向   **超类_**方向集中，而数据向   <strong>子类</strong>_  方向集中。</p>\n<p>适配器模式，分为类的适配器和对象的适配器两种实现。其中类的适配器采用的是   <strong>继承</strong>   关系，而对象适配器采用的是  <strong>组合聚合</strong>．</p>\n<p><strong>组合模式</strong>模式将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p><strong>单例模式</strong>    模式确保某一个类仅有一个实例，并自行实例化并向整个系统提供这个实例。</p>\n<p><strong>外观模式</strong>     模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，为子系统中的一组接口提供一个一致的界面。</p>\n<h2 id=\"简答题（每小题6分，共30分）\"><a href=\"#简答题（每小题6分，共30分）\" class=\"headerlink\" title=\"简答题（每小题6分，共30分）\"></a>简答题（每小题6分，共30分）</h2><p>​\t设计模式具有哪三大特点？<br>          <strong>可重用性，对相同类型问题反复出现，尽管问题的环境有不同，但解决方案有效<br>          可传授性，问题反复出现，解决问题的方案相同，大家都接受该解决方案<br>          名称，每个设计模式都有名称</strong></p>\n<p>​\t为什么面向对象的分析和设计中优先使用组合，而非继承？<br>          <strong>继承关系有很多缺点，如果合理使用组合则可以有效的避免这些缺点，使用组合关系将系统对变化的\t\t适应力从静态提升到动态，而且由于组合将已有对象组合到了新对象中，因此新对象可以调用已有对\t\t象的功能。</strong><br>​\t  \t<strong>由于组合关系中各个对象的内部实现是隐藏的，我们只能通过接口调用，因此我们完全可以在运行期\t\t用实现了同样接口的另外一个对象来代替原对象，从而灵活实现运行期的行为控制。而且使用合成关\t\t系有助\t于保持每个类的职责的单一性，这样类的层次体系以及类的规模都不太可能增长为不可控\t\t制的庞然大物。</strong><br>​\t单例模式的两种实现方法，并说明优缺点？<br>      <strong>懒汉式，在类被加载时，唯一的实例已经被创建。这个模式在java中很容易实现，在其他语言中很难.<br>​\t  饿汉式，在类加载的时候不创建单例实体。只有在第一次请求实例的时候创建，并且只在第一次创建后\t\t不再创佳该类的实例</strong></p>\n<p>​\t简述依赖例转原则的基本思想。请举出一个使用了软件依赖原则的软件设计模式，其中何处体现了依赖原则。<br>  <strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong><br>  <strong>抽象不应该依赖于细节，细节应该不依赖于抽象</strong></p>\n<p>​\t列举两个可以使我们在程序中不必使用if…else结构的软件设计模式。使用软件设计模式是如何做到这一点的？<br>   <strong>抽象不应该依赖于细节，细节应该不依赖于抽象</strong><br>   <strong>策略模式是将不同算法（处理方法）封装到stategy类中，状态模式是将不同状态封装到state类中。\t二者都是通过，类中的子类，实现不同情况的调用，从而有效的替换充满在程序中的 if else 语句。</strong></p>\n<h2 id=\"综合题（共20分）\"><a href=\"#综合题（共20分）\" class=\"headerlink\" title=\"综合题（共20分）\"></a>综合题（共20分）</h2><p>   1:我们经常碰到这种需求：通过公共场合传递文件，文件是用明文写的，凡是拿到这个文件都能看懂，传递过程中又不希望别人能看懂，于希望对文件内容进行加密。因为信息是不是军事机密，我们仅仅是想不被别人看明白，外传递过程中，传递人几乎不懂计算机的加密算法，那么很简单了，我们选择简单的字符移位的方法来实现加密。<br>   请用外观模式实现这个文件传递过程，分别封装外观类，加密和解密类，文件存取类，客户端类。（Java语言或者类Java语言描述，语法可以不完全正确，但业务逻辑流程必须正确）</p>\n","text":"软件设计B选择题（每小题2分，共30分）对于依赖倒转的表述错误的是（ D ）A. 依赖于抽象而不依赖于具体，也就是针对接口编程。B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道的方法集合。C. 从选项B的角度论述，一个对象可以有多个接口。D. 此...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"考试","slug":"考试","count":3,"path":"api/categories/考试.json"}],"tags":[{"name":"考试","slug":"考试","count":3,"path":"api/tags/考试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1B\"><span class=\"toc-text\">软件设计B</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%88%E6%AF%8F%E5%B0%8F%E9%A2%982%E5%88%86%EF%BC%8C%E5%85%B130%E5%88%86%EF%BC%89\"><span class=\"toc-text\">选择题（每小题2分，共30分）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E6%AF%8F%E7%A9%BA1%E5%88%86%EF%BC%8C%E5%85%B120%E5%88%86%EF%BC%89\"><span class=\"toc-text\">填空题（每空1分，共20分）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E7%AD%94%E9%A2%98%EF%BC%88%E6%AF%8F%E5%B0%8F%E9%A2%986%E5%88%86%EF%BC%8C%E5%85%B130%E5%88%86%EF%BC%89\"><span class=\"toc-text\">简答题（每小题6分，共30分）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%BC%E5%90%88%E9%A2%98%EF%BC%88%E5%85%B120%E5%88%86%EF%BC%89\"><span class=\"toc-text\">综合题（共20分）</span></a></li></ol></li></ol>","author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"mapped":true,"prev_post":{"title":"linux题库","uid":"e8eb3a6ab0f5bbc8166f7c80111edbc0","slug":"linux题库","date":"2022-12-06T10:06:34.000Z","updated":"2022-12-06T10:09:13.330Z","comments":true,"path":"api/articles/linux题库.json","keywords":null,"cover":null,"text":"1.10 练习题一、填空题1．GNU的含义是GNU’s Not Unix的递归缩写。2．Linux一般有3个主要部分： 内核 、 命令解释层 、 实用工具 。3．&#x2F;etc&#x2F;sysconfig&#x2F;network 文件主要用于设置基本的网络配置，包括主机名...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"考试","slug":"考试","count":3,"path":"api/categories/考试.json"}],"tags":[{"name":"考试","slug":"考试","count":3,"path":"api/tags/考试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}}},"next_post":{"title":"软件设计2016A","uid":"0f532b7b772da326c49235c97b678ef4","slug":"软件设计2016A","date":"2022-12-06T06:50:31.000Z","updated":"2022-12-06T07:14:15.384Z","comments":true,"path":"api/articles/软件设计2016A.json","keywords":null,"cover":null,"text":"软件设计A选择题设计模式一般是用来解决什么问题的（ D ）。A．需求获取中业务领域知识获取 B．测试用例的设计C．编码中如何组织代码 D．同一问题的不同表象 开闭原则的含义是一个软件实体（ A ）。A．应该对扩展开发，对修改关闭 B．对修改开放，对扩展关闭C．在应用子类的地方可以...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"考试","slug":"考试","count":3,"path":"api/categories/考试.json"}],"tags":[{"name":"考试","slug":"考试","count":3,"path":"api/tags/考试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}}}}