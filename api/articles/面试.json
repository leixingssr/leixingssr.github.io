{"title":"面试","uid":"b8cee04dc0368bcbafd67939edc1c0b9","slug":"面试","date":"2023-03-13T14:03:10.000Z","updated":"2023-07-24T12:50:36.200Z","comments":true,"path":"api/articles/面试.json","keywords":null,"cover":"https://images5.alphacoders.com/131/1318231.png","content":"<h2 id=\"1、String-类的常用方法都有那些？\"><a href=\"#1、String-类的常用方法都有那些？\" class=\"headerlink\" title=\"1、String 类的常用方法都有那些？\"></a>1、String 类的常用方法都有那些？</h2><ol>\n<li>length：返回字符串的长度。</li>\n<li>charAt：返回指定索引处的字符。</li>\n<li>concat：将指定字符串连接到此字符串的结尾。</li>\n<li>substring：返回一个新字符串，它是此字符串的一个子字符串。</li>\n<li>toLowerCase：使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</li>\n<li>toUpperCase：使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</li>\n<li>split：将此 String 以给定的分隔符作为分隔符来拆分。</li>\n<li>indexOf：返回指定字符在此字符串中第一次出现处的索引。</li>\n<li>lastIndexOf：返回指定字符在此字符串中最后一次出现处的索引。</li>\n<li>replace：使用给定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</li>\n</ol>\n<h2 id=\"2、抽象类必须要有抽象方法吗？\"><a href=\"#2、抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"2、抽象类必须要有抽象方法吗？\"></a>2、抽象类必须要有抽象方法吗？</h2><p>不必须，但抽象类通常用于定义抽象方法，它们必须被子类实现。抽象类可以有抽象方法，也可以不包含抽象方法。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在抽象类中，普通方法和抽象方法有很明显的区别。以下是它们的区别：</p>\n<ol>\n<li>抽象方法必须在抽象类中声明，而普通方法则不需要。</li>\n<li>抽象方法没有实现，只有声明，而普通方法有实现。</li>\n<li>子类必须实现抽象方法，否则子类也必须声明为抽象类。而普通方法则可以被子类继承或重写。</li>\n<li>抽象方法强制子类实现某些行为，而普通方法则提供了默认的实现。</li>\n</ol>\n<p>总之，抽象方法是一种约束，它要求子类必须实现某些方法，而普通方法则是一种默认实现，它可以被子类继承或重写。</p></blockquote>\n<h2 id=\"3、普通类和抽象类有哪些区别？\"><a href=\"#3、普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"3、普通类和抽象类有哪些区别？\"></a>3、普通类和抽象类有哪些区别？</h2><p>1、普通类可以定义实例对象，抽象类不能定义实例对象；</p>\n<p>2、普通类可以实现抽象方法（当然也可以不实现），但是抽象类一般必须实现抽象方法；</p>\n<p>3、继承于抽象类的子类必须实现抽象类中的方法，而普通类可以不实现；</p>\n<p>4、抽象类的方法可以为空，但普通类的方法不能为空；</p>\n<p>5、抽象类可以有自己的实现，而普通类要有自己的实现方法；</p>\n<p>6、抽象类可以被抽象方法和非抽象方法组成，而普通类只能由非抽象方法组成。</p>\n<h2 id=\"4、BIO、NIO、AIO-有什么区别？\"><a href=\"#4、BIO、NIO、AIO-有什么区别？\" class=\"headerlink\" title=\"4、BIO、NIO、AIO 有什么区别？\"></a>4、BIO、NIO、AIO 有什么区别？</h2><p>BIO：阻塞式I&#x2F;O，也叫同步阻塞I&#x2F;O，当一个线程调用IO操作时，它会被阻塞，直到有结果返回。</p>\n<p>NIO：非阻塞式I&#x2F;O，也叫同步非阻塞I&#x2F;O，当线程调用IO操作时，如果没有可用的数据，此线程不会被阻塞，而是直接得到结果。</p>\n<p>AIO：异步非阻塞I&#x2F;O，当线程调用IO操作时，不需要等待结果，系统会通知该线程，IO操作已经完成。</p>\n<h2 id=\"5、Files的常用方法都有哪些？\"><a href=\"#5、Files的常用方法都有哪些？\" class=\"headerlink\" title=\"5、Files的常用方法都有哪些？\"></a>5、Files的常用方法都有哪些？</h2><ol>\n<li>createNewFile()：创建一个新文件</li>\n<li>delete()：删除文件或目录</li>\n<li>exists()：检查文件或目录是否存在</li>\n<li>getAbsolutePath()：获取文件或目录的绝对路径</li>\n<li>getName()：获取文件或目录的名称</li>\n<li>getParent()：获取文件或目录父目录的路径</li>\n<li>getPath()：获取文件或目录的路径</li>\n<li>isDirectory()：检查指定路径是否为目录</li>\n<li>isFile()：检查指定路径是否为文件</li>\n<li>listFiles()：返回指定目录中的所有文件</li>\n<li>mkdir()：创建一个目录</li>\n<li>mkdirs()：创建一个多级目录</li>\n<li>renameTo()：重命名文件或目录</li>\n<li>setLastModified()：设置文件或目录的最后修改时间</li>\n<li>length()：获取文件大小</li>\n</ol>\n<h2 id=\"6、java-容器都有哪些？\"><a href=\"#6、java-容器都有哪些？\" class=\"headerlink\" title=\"6、java 容器都有哪些？\"></a>6、java 容器都有哪些？</h2><p>Java容器大致可以分成以下几类：</p>\n<ol>\n<li><p>函数式容器：如java.util.function包中定义的容器，通常用于对多个对象进行函数式操作；</p>\n</li>\n<li><p>集合容器：如java.util包中定义的容器，用于表示多个对象的集合；</p>\n</li>\n<li><p>常见的容器：如java.util.ArrayList、java.util.LinkedList、java.util.HashSet、java.util.HashMap 等等，这些都用于存储和操作各种类型的对象。</p>\n</li>\n<li><p>常见的树容器：如java.util.TreeMap、java.util.TreeSet等，可以用于存储和操作树状对象的集合。</p>\n</li>\n<li><p>其他容器：J2EE、J2ME所提供的容器，例如EJB、Servlet、JMS等，以及WebServices等，可以让应用程序可以更方便地使用分布式架构技术。</p>\n</li>\n</ol>\n<h2 id=\"7、Collection-和-Collections-有什么区别？\"><a href=\"#7、Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"7、Collection 和 Collections 有什么区别？\"></a>7、Collection 和 Collections 有什么区别？</h2><p><strong>Collection 是集合类的上级接口</strong>,继承它的主要有 <strong>List</strong> 和 <strong>Set</strong>;</p>\n<p>Collection 是一个接口，提供了一组用于操作集合的方法，它是 Java 集合框架的核心接口。Collections 是一个工具类，提供许多针对容器操作的静态方法，它可以用来进行容器的排序，搜索，反转等操作。</p>\n<h2 id=\"8、HashMap-和-Hashtable-有什么区别？\"><a href=\"#8、HashMap-和-Hashtable-有什么区别？\" class=\"headerlink\" title=\"8、HashMap 和 Hashtable 有什么区别？\"></a>8、HashMap 和 Hashtable 有什么区别？</h2><p>HashMap 和 Hashtable 都继承自 Map 接口，它们都是散列表的实现，主要用来存储 key-value 键值对。</p>\n<p>两者的最大差异在于：HashMap 是非同步的，而 Hashtable 是同步的。另外的一些区别如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>HashMap 允许 null 键和 null值，而Hashtable不允许；</li>\n<li>HashMap 的迭代器（Iterator）是 fail-fast迭代器，而 equalsHashtable 的迭代器不是 fail-fast的；</li>\n<li>当容量决定性能的时候，HashMap比 Hashtable理想；</li>\n<li>HashMap 扩容原则上是：如果当前容量超过了装填因子 * 初始容量，就扩容两倍；<br>Hashtable 会根据固定容量扩容：乘以 2 + 1。</li>\n</ul></blockquote>\n<h2 id=\"9、说一下-HashMap-的实现原理？\"><a href=\"#9、说一下-HashMap-的实现原理？\" class=\"headerlink\" title=\"9、说一下 HashMap 的实现原理？\"></a>9、说一下 HashMap 的实现原理？</h2><p>HashMap 是根据 Key 的 hashCode 来计算出在数组中的位置的，存储的是一个键值对的数据结构，K-V 的形式。</p>\n<p>其实现原理（从 JDK 1.7 开始）：</p>\n<ol>\n<li><p>HashMap 是一种根据 Key 的 hash 码值来准确定位 Value 的存放位置，无须遍历链表，用到了哈希表的原理。</p>\n</li>\n<li><p>先使用对象的哈希码计算出 hash 值，叫做哈希码，然后将哈希码转化为一个数组里的索引值，使其形成一个 Hash 数组，以便进行快速查找。</p>\n</li>\n<li><p>由于 K-V 的存储形式，HashMap 里存储的是必须是对象，它们必须具备唯一性，使用其实现 HashCode 方法，HashMap 将利用 Key 的哈希码作为其中的索引值，把这两者结合起来，实现其存储方式。</p>\n</li>\n<li><p>如果生成的哈希码冲突则会采取链表法或者红黑树法来解决，以提高其检索的效率。</p>\n</li>\n<li><p>HashMap 存储的是一个数组，在添加或删除元素的时候，不会对数组产生过大的影响，从而保证了 HashMap 的容量会保持得比较稳定。</p>\n</li>\n</ol>\n<p>更多关于 HashMap 实现原理，详情可参考 Java 数据结构与算法之 HashMap 实现原理等。</p>\n<h2 id=\"10、如何实现数组和-List-之间的转换？\"><a href=\"#10、如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"10、如何实现数组和 List 之间的转换？\"></a>10、如何实现数组和 List 之间的转换？</h2><p><strong>1）将数组转换为List</strong></p>\n<p>方法一：使用Arrays类的asList()静态方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>方法二：使用Collections类的addAll()静态方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2）将List转换为数组</strong></p>\n<p>方法一：使用List接口的toArray()方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>方法二：使用Collections类的toArray()方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"11、ArrayList-和-Vector-的区别是什么？\"><a href=\"#11、ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"11、ArrayList 和 Vector 的区别是什么？\"></a>11、ArrayList 和 Vector 的区别是什么？</h2><p>ArrayList 和 Vector 都是 Java 中的容器类，作为容器类的一种，两者都用于存放元素，但有一些不同之处：</p>\n<p>（1）ArrayList 是线程不安全的，而 Vector 是线程安全的，这是两者最大的不同之处。</p>\n<p>（2）ArrayList 的操作性能比 Vector 高，因为 Vector 是线程安全的，需要加锁导致获得锁的开销较大，性能较低。</p>\n<p>（3）ArrayList 不可以设置初始容量，而 Vector 可以通过构造函数指定容量大小。</p>\n<p>（4）ArrayList 的初始容量为10，而 Vector 的初始容量为0。ArrayList 和 Vector 都支持动态扩容，但 Vector 扩容的策略比 ArrayList 冗余一些。</p>\n<h2 id=\"12、Array-和-ArrayList-有何区别？\"><a href=\"#12、Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"12、Array 和 ArrayList 有何区别？\"></a>12、Array 和 ArrayList 有何区别？</h2><p>数组是基础数据结构，具有固定大小。而ArrayList是可变大小的，而且具有许多已实现的基本操作，如添加、移除、排序和搜索元素。此外，数组只能存储相同类型的元素，而ArrayList却能存储不同类型的元素。</p>\n<h2 id=\"13、怎么确保一个集合不能被修改？\"><a href=\"#13、怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"13、怎么确保一个集合不能被修改？\"></a>13、怎么确保一个集合不能被修改？</h2><p>要确保集合不能被修改，最常见的方法是使用不可变集合，即不可修改的集合。不可变集合可以通过对集合对象本身调用.freeze（）来实现，这会使集合对象不可变，任何尝试对集合中元素进行修改的尝试都会失败。另外，可以使用Object.preventExtensions（）方法来确保集合的剩余空间不可以被添加新的元素。</p>\n<h2 id=\"14、线程和进程的区别？\"><a href=\"#14、线程和进程的区别？\" class=\"headerlink\" title=\"14、线程和进程的区别？\"></a>14、线程和进程的区别？</h2><p>1）进程是指一个正在运行的程序，其中包含一组相关的活动；而线程是进程中的一条执行路径。</p>\n<p>2）进程有自己独立的内存空间，而线程共享父进程的内存空间。</p>\n<p>3）进程是操作系统分配资源的基本单位，而线程是程序执行的基本单位。</p>\n<p>4）进程的创建速度慢，而线程的创建速度快。</p>\n<p>5）进程的消耗的资源多，而线程的消耗资源少。</p>\n<h2 id=\"15、创建线程有哪几种方式？\"><a href=\"#15、创建线程有哪几种方式？\" class=\"headerlink\" title=\"15、创建线程有哪几种方式？\"></a>15、创建线程有哪几种方式？</h2><p>1、实现 <code>Runnable</code> 接口；<br>2、继承 <code>Thread</code> 类；<br>3、实现 <code>Callable</code> 接口；<br>4、使用线程池技术。</p>\n<h2 id=\"16、线程有哪些状态？\"><a href=\"#16、线程有哪些状态？\" class=\"headerlink\" title=\"16、线程有哪些状态？\"></a>16、线程有哪些状态？</h2><p>线程状态有：</p>\n<p>1）新建状态（New）：新创建了一个线程对象，但还没有调用start()方法。</p>\n<p>2）就绪状态（Runnable）：这个状态表明线程已经启动，可以等待处理器为其分配时间片。</p>\n<p>3）阻塞状态（Blocked）：线程被阻塞，暂停运行，它正在等待某些事件，通常指等待其他线程做出一些特定动作（唤醒它）。</p>\n<p>4）运行状态（Running）：正在运行的线程会消耗处理器的资源，它可以执行任务和操作系统的服务。</p>\n<p>5）终止状态（Terminated）：线程已经运行完毕或者被强行终止，不能再恢复运行了。</p>\n<h2 id=\"17、线程池都有哪些状态？\"><a href=\"#17、线程池都有哪些状态？\" class=\"headerlink\" title=\"17、线程池都有哪些状态？\"></a>17、线程池都有哪些状态？</h2><p>线程池状态通常包括：</p>\n<ol>\n<li>已创建：新建线程池；</li>\n<li>运行状态：当调用<code>execute()</code>方法时，线程池处于运行状态；</li>\n<li>阻塞状态：当调用<code>shutdown()</code>方法时，线程池处于阻塞状态；</li>\n<li>停止状态：当调用<code>shutdownNow()</code>方法时，线程池处于停止状态；</li>\n<li>清理状态：当线程池中的所有任务执行完毕或调用terminate()方法时，线程池处于清理状态；</li>\n<li>完成状态：当线程清理完毕后，线程池处于完成状态。</li>\n</ol>\n<h2 id=\"18、解释一下什么是-aop？\"><a href=\"#18、解释一下什么是-aop？\" class=\"headerlink\" title=\"18、解释一下什么是 aop？\"></a>18、解释一下什么是 aop？</h2><p>AOP(Aspect Oriented Programming)即面向切面编程，是一种比传统编程更高层次的编程范式，它将传统软件开发中横切关注点从业务逻辑代码中解耦出来，把它们横向抽离出来，形成一个可复用的模块，所谓横切关注点指的是日志记录、性能统计、安全控制、事务处理、异常处理等。</p>\n<h2 id=\"19、spring-常用的注入方式有哪些？\"><a href=\"#19、spring-常用的注入方式有哪些？\" class=\"headerlink\" title=\"19、spring 常用的注入方式有哪些？\"></a>19、spring 常用的注入方式有哪些？</h2><ul>\n<li>XML配置式<ul>\n<li><code>&lt;property&gt;</code>标签</li>\n<li><code>&lt;constructor-arg&gt;</code> 构造函数注入</li>\n</ul>\n</li>\n<li>Annotations注解式（基于JDK 1.5）<ul>\n<li><code>@Autowired</code></li>\n<li><code>@Resource</code></li>\n<li><code>@Qualifier</code></li>\n<li><code>@Value</code></li>\n</ul>\n</li>\n<li>Java Config Java配置式<ul>\n<li><code>@Bean</code></li>\n<li><code>@Configuration</code></li>\n<li><code>@Import</code></li>\n<li><code>@DependsOn</code></li>\n<li><code>@Primary</code></li>\n<li><code>@Lazy</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"20、spring-支持几种-bean-的作用域？\"><a href=\"#20、spring-支持几种-bean-的作用域？\" class=\"headerlink\" title=\"20、spring 支持几种 bean 的作用域？\"></a>20、spring 支持几种 bean 的作用域？</h2><p>Spring 支持5 种种不同的bean作用域，分别是：</p>\n<ul>\n<li>singleton：这是默认的作用域，它的实例在spring容器中只存在一份，即一个spring容器中只有一个singleton实例；</li>\n<li>prototype：每次调用情况会创建一个新的bean实例；</li>\n<li>request：在一个HTTP request周期内有效；</li>\n<li>session：在一个HTTP session周期内有效；</li>\n<li>global session：全局HTTP session上有效。</li>\n</ul>\n<h2 id=\"21、spring-事务实现方式有哪些？\"><a href=\"#21、spring-事务实现方式有哪些？\" class=\"headerlink\" title=\"21、spring 事务实现方式有哪些？\"></a>21、spring 事务实现方式有哪些？</h2><p>Spring 事务实现方式一共有三种：</p>\n<ol>\n<li>基于XML的声明式事务：基于Spring的API来实现事务，通过在Spring的配置文件中声明，就可以实现事务。</li>\n<li>基于注解的声明式事务：和XML文件类似，具有相同的功能，只是使用注解简化了开发步骤。</li>\n<li>编程式事务：基于Java代码来实现，代码中控制事务的创建、提交、回滚等</li>\n</ol>\n<h2 id=\"22、spring-boot-核心配置文件是什么？\"><a href=\"#22、spring-boot-核心配置文件是什么？\" class=\"headerlink\" title=\"22、spring boot 核心配置文件是什么？\"></a>22、spring boot 核心配置文件是什么？</h2><p>核心配置文件是 Spring Boot 中的 application.properties 文件，它位于应用程序的 src&#x2F;main&#x2F;resources 目录下。它允许用户通过简单的键值对配置不同的属性，以更改 Spring Boot 应用程序的运行行为。例如，可以通过更改此文件中的 server.port 属性来修改 Spring Boot 应用程序的端口。</p>\n<h2 id=\"23、spring-boot-配置文件有哪几种类型？它们有什么区别？\"><a href=\"#23、spring-boot-配置文件有哪几种类型？它们有什么区别？\" class=\"headerlink\" title=\"23、spring boot 配置文件有哪几种类型？它们有什么区别？\"></a>23、spring boot 配置文件有哪几种类型？它们有什么区别？</h2><p>Spring Boot 支持的配置文件类型有：</p>\n<ol>\n<li>YAML（.yml）：基于YAML语法的配置格式，使用缩进结构来表示层次结构，功能比 properties 强大。 </li>\n<li>properties（.properties）：Java支持的属性配置文件。 </li>\n<li>XML（.xml）：J2EE开发常用的XML配置格式。</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这三种配置文件类型之间的区别在于：YAML文件以缩进式格式存储，并具有良好的可读性，但是其功能要强于properties；properties文件使用’&#x3D;’存储键值对，具有较高的兼容性；XML文件使用标签属性的形式存储，具有良好的结构性，但是相对于其它两种配置文件，其读取速度较慢。</p></blockquote>\n<h2 id=\"24、spring-boot-有哪些方式可以实现热部署？\"><a href=\"#24、spring-boot-有哪些方式可以实现热部署？\" class=\"headerlink\" title=\"24、spring boot 有哪些方式可以实现热部署？\"></a>24、spring boot 有哪些方式可以实现热部署？</h2><ol>\n<li><p>使用Spring Boot Devtools：Spring Boot提供了一个叫做Devtools的模块，它可以让你再修改完文件之后不需要再重新编译或者启动应用程序就可以自动重启应用程序，从而实现热部署。</p>\n</li>\n<li><p>使用JRebel：JRebel是一款可以让你在改变完Java类之后重新加载应用的一款软件，它可以节省大量的重新编译时间，从而实现热部署。 </p>\n</li>\n<li><p>使用spring-loaded模块：spring-loaded模块可以实现实时重新加载类，从而实现热部署。</p>\n</li>\n<li><p>使用Maven插件：有一些Maven插件可以实现热部署，例如 cargo-maven2-plugin 和 spring-boot-devtools等。</p>\n</li>\n<li><p>使用Docker：Docker可以在运行应用程序时做更细粒度的重新加载，从而实现热部署。</p>\n</li>\n</ol>\n<h2 id=\"25、什么是-spring-cloud？\"><a href=\"#25、什么是-spring-cloud？\" class=\"headerlink\" title=\"25、什么是 spring cloud？\"></a>25、什么是 spring cloud？</h2><p>Spring Cloud是一个基于Spring框架的微服务开发工具，旨在为开发者提供快速构建分布式系统的一系列工具。它允许开发者使用服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁定、领导选举、分布式会话和集群状态等，以建立精心设计的分布式系统作为应用的一部分。</p>\n<h2 id=\"26、spring-cloud-的核心组件有哪些？\"><a href=\"#26、spring-cloud-的核心组件有哪些？\" class=\"headerlink\" title=\"26、spring cloud 的核心组件有哪些？\"></a>26、spring cloud 的核心组件有哪些？</h2><ol>\n<li>服务注册与发现（Eureka）；</li>\n<li>服务治理（Ribbon，Hystrix）；</li>\n<li>服务网关（Zuul）；</li>\n<li>配置中心（Spring Cloud Config）；</li>\n<li>消息总线（Spring Cloud Stream）；</li>\n<li>服务跟踪（Sleuth）；</li>\n<li>服务容错（Hystrix）；</li>\n<li>分布式链路追踪（Zipkin）；</li>\n<li>外部认证授权（Spring Security OAuth2）；</li>\n<li>事件发布&#x2F;订阅（Spring Cloud Bus）等</li>\n</ol>\n<h2 id=\"27、mybatis-中-和-的区别是什么？\"><a href=\"#27、mybatis-中-和-的区别是什么？\" class=\"headerlink\" title=\"27、mybatis 中 #{}和 ${}的区别是什么？\"></a>27、mybatis 中 #{}和 ${}的区别是什么？</h2><p>#{}是Mybatis中的预编译处理占位符，它可以防止SQL注入；<br>${}是Mybatis中的字符串替换占位符，它不防止SQL注入</p>\n<h2 id=\"28、mybatis-有几种分页方式？\"><a href=\"#28、mybatis-有几种分页方式？\" class=\"headerlink\" title=\"28、mybatis 有几种分页方式？\"></a>28、mybatis 有几种分页方式？</h2><p>Mybatis 有以下几种分页方式：</p>\n<ul>\n<li><p>通过特殊的关键词‘limit’、‘offset’进行分页，这样 MySQL 不用再生成重复的内存拷贝，从而提高查询效率。</p>\n</li>\n<li><p>通过使用 RowBounds 对象，设置当前页码及大小。</p>\n</li>\n<li><p>通过拦截器（插件）的方式实现物理分页，可以使用不同的物理分页方案实现物理分页，例如改写sql语句进行分页，使用本地的存储过程等</p>\n</li>\n<li><p>通过连接的方式实现物理分页，通过连接表进行分页，可以支持任何数据库。</p>\n</li>\n</ul>\n<h2 id=\"29、mybatis-逻辑分页和物理分页的区别是什么？\"><a href=\"#29、mybatis-逻辑分页和物理分页的区别是什么？\" class=\"headerlink\" title=\"29、mybatis 逻辑分页和物理分页的区别是什么？\"></a>29、mybatis 逻辑分页和物理分页的区别是什么？</h2><p>逻辑分页是指从数据库检索出满足查询条件的所有记录，然后在应用层进行内存分页进行数据分页，翻页时会重新查询数据库，不能实现服务器端的分页效果。</p>\n<p>物理分页则是指在数据库查询中使用 limit 关键字设置取出记录的开始位置和数量，MySQL 和 PostgreSQL 就常用的这种物理分页，翻页时不会重新查询数据库，MySQL 默认使用物理分页。</p>\n<h2 id=\"30、如何做-mysql-的性能优化？\"><a href=\"#30、如何做-mysql-的性能优化？\" class=\"headerlink\" title=\"30、如何做 mysql 的性能优化？\"></a>30、如何做 mysql 的性能优化？</h2><ol>\n<li><p><code>合理分配内存</code>：根据系统的具体情况，合理设置各个堆的大小和配置，控制内存使用。</p>\n</li>\n<li><p><code>合理使用索引</code>： 根据业务需求，权衡索引的增加与删除，减少索引不必要的影响。</p>\n</li>\n<li><p><code>定期做查询优化</code>：通过性能分析，逐步优化SQL语句，提高查询效率。</p>\n</li>\n<li><p><code>维护数据库</code>：定期进行表碎片整理，获得较高的磁盘存储性能。</p>\n</li>\n<li><p><code>数据库备份</code>：定期备份数据库，以防出现数据丢失的问题。</p>\n</li>\n</ol>\n<h2 id=\"31、redis-持久化有几种方式？\"><a href=\"#31、redis-持久化有几种方式？\" class=\"headerlink\" title=\"31、redis 持久化有几种方式？\"></a>31、redis 持久化有几种方式？</h2><p>Redis持久化有三种方式：</p>\n<ol>\n<li>RDB（Redis Database）方式:在指定的时间间隔内备份数据（如每10分钟备份一次）。</li>\n<li>AOF（Append Only File）方式：保存数据改动的日志文件（所有写入操作进行改动的日志文件），按行记录每次的写操作，并在重启时重放数据到内存中进行重建。</li>\n<li>共存方式：将AOF和RDB两种方式结合起来，可以进行定时的RDB备份，也可以根据设置的条件触发AOF文件的改动，使数据写入更加安全，出现问题也有及时补救的方法。</li>\n</ol>\n<h2 id=\"32、requestparam与pathvariable区别\"><a href=\"#32、requestparam与pathvariable区别\" class=\"headerlink\" title=\"32、requestparam与pathvariable区别\"></a>32、requestparam与pathvariable区别</h2><ol>\n<li>作用：Requestparam用于获取请求参数，Pathvariable用于获取请求URL中的占位符变量；</li>\n<li>地址：Requestparam参数是请求地址中“？”后面的参数，Pathvariable参数是路径参数，是请求地址中实际路径中的参数；</li>\n<li>位置：Requestparam放在方法参数中，Pathvariable放在方法参数前面加上@Pathvariable注解；</li>\n<li>操作：Requestparam可以挪动参数位置，Pathvariable不能挪动参数位置，否则会找不到参数。</li>\n</ol>\n<h2 id=\"33、redis-数据类型\"><a href=\"#33、redis-数据类型\" class=\"headerlink\" title=\"33、redis 数据类型\"></a>33、redis 数据类型</h2><p>Redis 当前有 5 种数据类型：</p>\n<ol>\n<li>String（字符串）</li>\n<li>Hash（哈希）</li>\n<li>List（列表）</li>\n<li>Set（集合）</li>\n<li>Sorted Set（有序集合）</li>\n</ol>\n<h2 id=\"32、IOC容器是什么？\"><a href=\"#32、IOC容器是什么？\" class=\"headerlink\" title=\"32、IOC容器是什么？\"></a>32、IOC容器是什么？</h2><p>IOC容器是一种控制反转（Inversion of Control）的框架，其基本思想是把实例化对象的动作交由容器对象负责，由容器来实现对象之间的依赖注入，并提供服务实例。IOC容器充当中心角色，所有被管理的对象依赖其来完成配置、管理和调用，使应用得到更加松耦合的架构。</p>\n<h2 id=\"33、spring-bean的生命周期？\"><a href=\"#33、spring-bean的生命周期？\" class=\"headerlink\" title=\"33、spring bean的生命周期？\"></a>33、spring bean的生命周期？</h2><p>Spring bean的生命周期围绕着各个bean的实例化、配置以及销毁而进行，同时包括：</p>\n<p>1.实例化：将普通Java对象实例化为Spring容器管理的bean实例；</p>\n<p>2.设置属性：将bean实例中配置的属性值应用到实例中；</p>\n<p>3.装配Bean：为bean提供其他bean的相关引用服务；</p>\n<p>4.初始化：在bean可用之前完成其他初始化步骤，包括调用它们的初始化方法；</p>\n<p>5.销毁：在容器关闭时为bean提供一个清理方法。</p>\n<h2 id=\"34、Spring的自动装配原理\"><a href=\"#34、Spring的自动装配原理\" class=\"headerlink\" title=\"34、Spring的自动装配原理\"></a>34、Spring的自动装配原理</h2><ol>\n<li>Spring Boot启动的时候会通过<code>@EnableAutoConfiguration</code>注解找到<code>META-INF/spring.factories</code>配置文件中的所有自动配置类，并对其进行加载</li>\n<li>然后自动配置类就生效 ， 帮我们进行自动配置工作；</li>\n<li>自动配置都在<code>springboot-autoconfigure</code>的jar包中；</li>\n<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）</li>\n<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作</li>\n</ol>\n<h2 id=\"35、mybatis的优缺点\"><a href=\"#35、mybatis的优缺点\" class=\"headerlink\" title=\"35、mybatis的优缺点\"></a>35、mybatis的优缺点</h2><ul>\n<li><p><strong>优点</strong></p>\n<ul>\n<li>基于sql语句编程，使用灵活，解除sql与程序代码的耦合 </li>\n<li>与jdbc相比，减少50%代码，消除jdbc大量冗余代码，不需要手动开关连接</li>\n<li>只要支持jdbc的数据库，mybatis都支持 </li>\n<li>与spring集成比较好 </li>\n<li>支持面向对象编程，提供了字段，表名等映射标签，支持对象与ORM表映射</li>\n</ul>\n</li>\n<li><p><strong>缺点</strong> </p>\n<ul>\n<li>有些数据库独有的语句，不能随意切换数据库类型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"36、java-过滤器内容和作用\"><a href=\"#36、java-过滤器内容和作用\" class=\"headerlink\" title=\"36、java 过滤器内容和作用\"></a>36、java 过滤器内容和作用</h2><p>Java 过滤器是一种特殊类型的程序，可以被 Java Web 应用程序用来拦截用户的请求，并在请求的前后作出某些动作。这些动作可以做到输入验证、身份验证和授权等操作，从而保护应用程序免受恶意的攻击。</p>\n<h2 id=\"37、索引是如何实现的\"><a href=\"#37、索引是如何实现的\" class=\"headerlink\" title=\"37、索引是如何实现的\"></a>37、索引是如何实现的</h2><p>索引的思想就是，根据表中的某个属性建立一套算法，每次查询的时候，在内存中根据该算法得到出所需要的数据的物理地址，根据物理地址直接去磁盘中拿到结果数据，不用将表中的所有数据都加载到内存扫描一遍。有：普通索引、唯一索引、主键索引、全文索引、组合索引。</p>\n","feature":"ture","text":"1、String 类的常用方法都有那些？ length：返回字符串的长度。 charAt：返回指定索引处的字符。 concat：将指定字符串连接到此字符串的结尾。 substring：返回一个新字符串，它是此字符串的一个子字符串。 toLo...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":5,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">1、String 类的常用方法都有那些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">2、抽象类必须要有抽象方法吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3、普通类和抽象类有哪些区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4、BIO、NIO、AIO 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">5、Files的常用方法都有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E3%80%81java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">6、java 容器都有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7%E3%80%81Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">7、Collection 和 Collections 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8%E3%80%81HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">8、HashMap 和 Hashtable 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">9、说一下 HashMap 的实现原理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F\"><span class=\"toc-text\">10、如何实现数组和 List 之间的转换？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11%E3%80%81ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">11、ArrayList 和 Vector 的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12%E3%80%81Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">12、Array 和 ArrayList 有何区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13%E3%80%81%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F\"><span class=\"toc-text\">13、怎么确保一个集合不能被修改？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">14、线程和进程的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">15、创建线程有哪几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">16、线程有哪些状态？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">17、线程池都有哪些状态？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF-aop%EF%BC%9F\"><span class=\"toc-text\">18、解释一下什么是 aop？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19%E3%80%81spring-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">19、spring 常用的注入方式有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20%E3%80%81spring-%E6%94%AF%E6%8C%81%E5%87%A0%E7%A7%8D-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">20、spring 支持几种 bean 的作用域？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21%E3%80%81spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">21、spring 事务实现方式有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22%E3%80%81spring-boot-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">22、spring boot 核心配置文件是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23%E3%80%81spring-boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">23、spring boot 配置文件有哪几种类型？它们有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24%E3%80%81spring-boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%EF%BC%9F\"><span class=\"toc-text\">24、spring boot 有哪些方式可以实现热部署？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-spring-cloud%EF%BC%9F\"><span class=\"toc-text\">25、什么是 spring cloud？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26%E3%80%81spring-cloud-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">26、spring cloud 的核心组件有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27%E3%80%81mybatis-%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">27、mybatis 中 #{}和 ${}的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28%E3%80%81mybatis-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">28、mybatis 有几种分页方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29%E3%80%81mybatis-%E9%80%BB%E8%BE%91%E5%88%86%E9%A1%B5%E5%92%8C%E7%89%A9%E7%90%86%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">29、mybatis 逻辑分页和物理分页的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30%E3%80%81%E5%A6%82%E4%BD%95%E5%81%9A-mysql-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">30、如何做 mysql 的性能优化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#31%E3%80%81redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">31、redis 持久化有几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32%E3%80%81requestparam%E4%B8%8Epathvariable%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">32、requestparam与pathvariable区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33%E3%80%81redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">33、redis 数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32%E3%80%81IOC%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">32、IOC容器是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33%E3%80%81spring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F\"><span class=\"toc-text\">33、spring bean的生命周期？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#34%E3%80%81Spring%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">34、Spring的自动装配原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35%E3%80%81mybatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">35、mybatis的优缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36%E3%80%81java-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%86%85%E5%AE%B9%E5%92%8C%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">36、java 过滤器内容和作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#37%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84\"><span class=\"toc-text\">37、索引是如何实现的</span></a></li></ol>","author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"mapped":true,"prev_post":{"title":"数据库","uid":"e409567ce70193edb20816f760deda32","slug":"数据库","date":"2023-04-01T09:46:11.000Z","updated":"2023-07-24T12:48:22.365Z","comments":true,"path":"api/articles/数据库.json","keywords":null,"cover":"https://images6.alphacoders.com/131/1318421.png","text":"数据库–Mysql数据库是以电子方式存储的系统数据集合。它可以包含任何类型的数据，包括文字、数字、图像、视频和文件。您可以使用称为数据库管理系统 (DBMS) 的软件来存储、检索和编辑数据。在计算机系统中，“数据库” 一词也可以指任何 DB...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"数据库","slug":"数据库","count":2,"path":"api/tags/数据库.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"},"next_post":{"title":"Redis面试","uid":"9864cb5f05af74d955a88eab7d87ec93","slug":"Redis面试","date":"2023-02-24T14:06:48.000Z","updated":"2023-02-24T14:53:49.234Z","comments":true,"path":"api/articles/Redis面试.json","keywords":null,"cover":"https://images2.alphacoders.com/648/648566.jpg#文章在首页时的预览图，以及文章页的背景图","text":"Redis 支持的数据类型有哪些 Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。 什么是缓存穿透？怎么解决？ 缓存穿透：指查询一个一定不存在的数据，由于缓存是不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":5,"path":"api/tags/面试.json"}],"author":{"name":"Leixng","slug":"blog-author","avatar":"/img/003.png","link":"/","description":"清风徐来","socials":{"github":"https://github.com/leixingssr?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/177137946?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/img/svg/gitee.svg","link":"https://gitee.com/leixingsss"},"Email":{"icon":"/img/svg/QQMail.svg","link":"https://mail.qq.com/cgi-bin/frame_html?sid=E8RhG3WmM8OPiglq&r=af46ab161c61f3640e812141ff04c53c&lang=zh"}}}},"feature":"ture"}}