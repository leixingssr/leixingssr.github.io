[{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"SpringBoot文档更新日志\n\n\n版本\n更新日期\n操作\n描述\n\n\n\nv1.0\n2021&#x2F;11&#x2F;14\nA\n基础篇\n\n\nv1.0.1\n2021&#x2F;11&#x2F;30\nU\n更新基础篇错别字若干，不涉及内容变更\n\n\nv2.0\n2021&#x2F;12&#x2F;01\nA\n运维实用篇\n\n\nV3.0\n2022&#x2F;2&#x2F;21\nA\n开发实用篇\n\n\nV4.0\n2022&#x2F;3&#x2F;29\nA\n原理篇\n\n\n前言​\t\t很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是Spring家族中比较重要的一门技术课程——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发Spring程序不用SpringBoot那就是给自己过不去，SpringBoot为我们开发Spring程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。\n​\t\t正如上面提到的，这门技术是用来加速开发Spring程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少Spring怎么回事，与Spring配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。\n课程内容说明​\t\tSpringBoot这门技术课程所包含的技术点其实并不是很多，但是围绕着SpringBoot的周边知识，也就是SpringBoot整合其他技术，这样的知识量很大，例如SpringBoot整合MyBatis等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。\n\n\n\n学习者\n归类方式\n\n\n\n小白\n完全没有用过SpringBoot技术\n\n\n初学者\n能使用SpringBoot技术完成基础的SSM整合\n\n\n开发者\n能使用SpringBoot技术实现常见的技术整合工作\n\n\n​\t\t简单说就是你能用SpringBoot做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将SpringBoot技术划分成4个单元，每个单元是针对不同的学习者准备的。\n\n\n\n学习者\n课程单元\n\n\n\n小白\n基础篇\n\n\n初学者\n应用篇（  运维实用篇  &amp;  开发实用篇  ）\n\n\n开发者\n原理篇\n\n\n​\t\t看完这个划分你就应该有这么个概念，我没有用过SpringBoot技术，所以从基础篇开始学习；或者我会一点SpringBoot技术，那我从实用篇开始学就好了，就是这个意思。\n​\t\t每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着基础篇在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了原理篇讲解了，应用相关的内容统一放到应用篇里面讲解，你在基础篇阶段纠结也没有用，这一部分不讲这些知识，在基础篇先把SpringBoot的基础使用掌握完再说后面的知识吧。\n​\t\t此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个番外篇。番外篇的设置为了解决如下问题：\n\n持续更新SpringBoot后续发展出现的新技术\n讲解部分知识点规模较大的支线知识（例如WebFlux）\n扩展非实用性知识，扩展学习者视野\n\n​\t\t每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。\n\n\n\n课程单元\n学习目标\n\n\n\n基础篇\n能够创建SpringBoot工程基于SpringBoot实现ssm&#x2F;ssmp整合\n\n\n应用篇\n能够掌握SpringBoot程序多环境开发能够基于Linux系统发布SpringBoot工程能够解决线上灵活配置SpringBoot工程的需求能够基于SpringBoot整合任意第三方技术\n\n\n原理篇\n掌握SpringBoot内部工作流程理解SpringBoot整合第三方技术的原理实现自定义开发整合第三方技术的组件\n\n\n番外篇\n掌握SpringBoot整合非常见的第三方技术掌握相同领域的更多的解决方案，并提升同领域方案设计能力\n\n\n​\t\t整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。\n课程前置知识说明\n\n\n课程单元\n前置知识\n要求\n\n\n\n基础篇\nJava基础语法\n面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等\n\n\n基础篇\nSpring与SpringMVC\n知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能\n\n\n基础篇\nMybatis与Mybatis-Plus\n基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块\n\n\n基础篇\n数据库MySQL\n能够读懂基础CRUD功能的SQL语句\n\n\n基础篇\n服务器\n知道服务器与web工程的关系，熟悉web服务器的基础配置\n\n\n基础篇\nmaven\n知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承\n\n\n基础篇\nweb技术（含vue，ElementUI)\n知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定\n\n\n应用篇\nLinux（CenterOS7）\n熟悉常用的Linux基础指令，熟悉Linux系统目录结构\n\n\n应用篇\n实用开发技术\n缓存：Redis、MongoDB、……消息中间件:RocketMq、RabbitMq、……\n\n\n原理篇\nSpring\n了解Spring加载bean的各种方式知道Spring容器底层工作原理，能够阅读简单的Spring底层源码\n\n\n​\t\t看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。\n​\t\t课程安排就说到这里了，下面进入到SpringBoot基础篇的学习\nSpringBoot基础篇​\t\t在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：\n\nSpringBoot快速入门\nSpringBoot基础配置\n基于SpringBoot整合SSMP\n\nJC-1.快速上手SpringBoot​\t\t学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说\n\nSpring程序初始搭建过程\nSpring程序的开发过程\n\n​\t通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\nSpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件&#x2F;配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\nSpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n​\t带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。\n温馨提示\n​\t\t如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。\nJC-1-1.SpringBoot入门程序制作（一）​\t\t下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。\n​\t\t下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会简化二字的含义。\n步骤①：创建新模块，选择Spring Initializr，并配置模块相关基础信息\n\n​\t\t特别关注：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直联网转转转。\n​\t\t特别关注：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11。\n步骤②：选择当前模块需要使用的技术集\n\n​\t\t按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了。\n​\t\t关注：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。\n步骤③：开发控制器类\n&#x2F;&#x2F;Rest模式\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n    @GetMapping\n    public String getById()&#123;\n        System.out.println(&quot;springboot is running...&quot;);\n        return &quot;springboot is running...&quot;;\n    &#125;\n&#125;\n\n​\t\t入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解。\n​\t\t关注：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。\n步骤④：运行自动生成的Application类\n\n​\t\t使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。\n​\t\t不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。\n访问路径：\thttp:&#x2F;&#x2F;localhost:8080&#x2F;books\n\n​\t\t是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。\n\npom.xml\n这是maven的配置文件，描述了当前工程构建时相应的配置信息。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springboot_01_01_quickstart&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。\n\nApplication类\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n&#125;\n\n这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。\n\n\n​       到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。\n​       通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spring程序相比，SpringBoot程序在开发的过程中各个层面均具有优势。\n\n\n\n类配置文件\nSpring\nSpringBoot\n\n\n\npom文件中的坐标\n手工添加\n勾选添加\n\n\nweb3.0配置类\n手工制作\n无\n\n\nSpring&#x2F;SpringMVC配置类\n手工制作\n无\n\n\n控制器\n手工制作\n手工制作\n\n\n​\t\t一句话总结一下就是能少写就少写，能不写就不写，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了。\n总结\n\n开发SpringBoot程序在Idea工具中基于联网的前提下可以根据向导快速制作\nSpringBoot程序需要依赖JDK，版本要求最低为JDK8\nSpringBoot程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）\n运行SpringBoot程序通过运行Application程序进行\n\n思考\n​\t\t前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说。\nJC-1-2.SpringBoot入门程序制作（二）​\t\t如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序可以不基于IDE工具进行，在SpringBoot官网中可以直接创建SpringBoot程序。\n​\t\tSpringBoot官网和Spring的官网是在一起的，都是  spring.io  。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容\n\n\n步骤①：点击Spring Initializr后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。\n\n\n步骤②：右侧的ADD DEPENDENCIES用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。\n\n\n步骤③：所有信息设置完毕后，点击下面左侧GENERATE按钮，生成一个文件包。\n\n步骤④：保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程\t\t\n\n步骤⑤：解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样，你可以创建一个Controller测试一下当前工程是否可用。\n温馨提示\n​\t\t做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，还句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下，读取Spring官网信息，然后展示到Idea界面中而已，可以通过如下信息比对一下\nIdea中创建工程时默认选项\n\n\nSpringBoot官网创建工程时对应的地址\n​\t\t看看SpringBoot官网创建工程的URL地址，是不是和Idea中使用的URL地址是一样的？\n\n\n总结\n\n打开SpringBoot官网，选择Quickstart Your Project中的Spring Initializr。\n\n\n创建工程。\n\n\n保存项目文件。\n\n\n解压项目，通过IDE导入项目后进行编辑使用。\n\n\n思考\n​\t\t现在创建工程靠的是访问国外的Spring主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。\nJC-1-3.SpringBoot入门程序制作（三）​\t\t前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过SpringBoot官网创建SpringBoot工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样。\n​\t\t创建工程时，切换选择starter服务路径，然后手工输入阿里云地址即可，地址：http://start.aliyun.com或https://start.aliyun.com\n\n​\t\t阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。\n\n​\t\t不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是2.4.1，所以如果你想更换其他的版本，创建项目后在pom文件中手工修改即可，别忘了刷新一下，加载新版本信息。\n​\t\t注意：阿里云提供的工程创建地址初始化完毕后和使用SpringBoot官网创建出来的工程略有区别，主要是在配置文件的形式上有区别,这个信息在后面讲解SpringBoot程序的执行流程时给大家揭晓。\n总结\n\n选择start来源为自定义URL\n输入阿里云starter地址\n创建项目\n\n思考\n​\t\t做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。\nJC-1-4.SpringBoot入门程序制作（四）​\t\t不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。\n​\t\t联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实SpringBoot工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。\n​\t\t下面就手工创建一个SpringBoot工程，如果需要使用的东西提前保障在maven仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用3种方式创建了SprongBoot工程了，所以下面也没什么东西需要下载了。\n步骤①：创建工程时，选择创建普通Maven工程。\n\n\n步骤②：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springboot_01_04_quickstart&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n&lt;&#x2F;project&gt;\n\n​\t\t用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。\n步骤③：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class);\n    &#125;\n&#125;\n\n​\t\t关注：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍。\n​\t\t关注：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称。\n步骤④：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别的。\n​\t\t看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。\n温馨提示\n​\t\t如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的。\n总结\n\n创建普通Maven工程\n继承spring-boot-starter-parent\n添加依赖spring-boot-starter-web\n制作引导类Application\n\n​        到这里已经学习了4种创建SpringBoot工程的方式，其实本质是一样的，都是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。\n教你一招：在Idea中隐藏指定文件&#x2F;文件夹​\t\t创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。\n​\t\t处理方案无外乎两种，如果你对每一个文件&#x2F;目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。\n​\t\t既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。\n步骤①：打开设置，【Files】→【Settings】。\n\n\n步骤②：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。\n\n\n步骤③：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可。\n​\t到这里就做完了，其实就是Idea的一个小功能\n总结\n\nIdea中隐藏指定文件或指定类型文件\n【Files】→【Settings】\n【Editor】→【File Types】→【Ignored Files and Folders】\n输入要隐藏的名称，支持*号通配符\n回车确认添加\n\n\n\nJC-1-5.SpringBoot简介​\t\t入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。\n​\t\tSpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。\n​\t\t都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：\n\nSpring程序缺点\n依赖设置繁琐\n以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标是必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定了。\n\n\n配置繁琐\n以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n回顾\n​\t通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\nSpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件&#x2F;配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\nSpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n​\t\t再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：\n\n起步依赖（简化依赖配置）\n依赖配置的书写简化就是靠这个起步依赖达成的。\n\n\n自动配置（简化常用工程相关配置）\n配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。\n\n\n辅助功能（内置服务器，……）\n除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot入门程序中一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了。\n\n\n\n​\t\t下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\nparent\nstarter\n引导类\n内嵌tomcat\n\nparent​\t\tSpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版，在与B技术进行配合使用时，与B技术的3.5版可以合作在一起工作，但是和B技术的3.7版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。\n​\t\tSpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent。\n​\t\tparent自身具有很多个版本，每个parent版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的parent就行了，由parent帮助开发者统一的进行各种技术的版本管理。\n​\t\t比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由parent负责处理。\n​\t\t有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用parent可以帮助开发者进行版本的统一管理。\n​\t\t关注：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。\n​\t\t那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义。\n\n项目中的pom.xml中继承了一个坐标\n\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n\n打开后可以查阅到其中又继承了一个坐标\n\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n\n这个坐标中定义了两组信息\n\n第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。\n&lt;properties&gt;\n    &lt;activemq.version&gt;5.16.3&lt;&#x2F;activemq.version&gt;\n    &lt;aspectj.version&gt;1.9.7&lt;&#x2F;aspectj.version&gt;\n    &lt;assertj.version&gt;3.19.0&lt;&#x2F;assertj.version&gt;\n    &lt;commons-codec.version&gt;1.15&lt;&#x2F;commons-codec.version&gt;\n    &lt;commons-dbcp2.version&gt;2.8.0&lt;&#x2F;commons-dbcp2.version&gt;\n    &lt;commons-lang3.version&gt;3.12.0&lt;&#x2F;commons-lang3.version&gt;\n    &lt;commons-pool.version&gt;1.6&lt;&#x2F;commons-pool.version&gt;\n    &lt;commons-pool2.version&gt;2.9.0&lt;&#x2F;commons-pool2.version&gt;\n    &lt;h2.version&gt;1.4.200&lt;&#x2F;h2.version&gt;\n    &lt;hibernate.version&gt;5.4.32.Final&lt;&#x2F;hibernate.version&gt;\n    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;&#x2F;hibernate-validator.version&gt;\n    &lt;httpclient.version&gt;4.5.13&lt;&#x2F;httpclient.version&gt;\n    &lt;jackson-bom.version&gt;2.12.4&lt;&#x2F;jackson-bom.version&gt;\n    &lt;javax-jms.version&gt;2.0.1&lt;&#x2F;javax-jms.version&gt;\n    &lt;javax-json.version&gt;1.1.4&lt;&#x2F;javax-json.version&gt;\n    &lt;javax-websocket.version&gt;1.1&lt;&#x2F;javax-websocket.version&gt;\n    &lt;jetty-el.version&gt;9.0.48&lt;&#x2F;jetty-el.version&gt;\n    &lt;junit.version&gt;4.13.2&lt;&#x2F;junit.version&gt;\n&lt;&#x2F;properties&gt;\n\n第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hibernate-core&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;hibernate.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;dependencyManagement&gt;\n\n​\t\t关注：上面的依赖坐标定义是出现在标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。\n​\t\t关注：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式。\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;$&#123;spring-boot.version&#125;&lt;&#x2F;version&gt;\n            &lt;type&gt;pom&lt;&#x2F;type&gt;\n            &lt;scope&gt;import&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;dependencyManagement&gt;\n\n总结\n\n开发SpringBoot程序要继承spring-boot-starter-parent\nspring-boot-starter-parent中定义了若干个依赖管理\n继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n继承parent的形式也可以采用引入依赖的形式实现效果\n\n思考\n​\t\tparent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？\nstarter​\t\tSpringBoot关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。\n​\t\tSpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做starter。\n​\t\tstarter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置。\n​\t\t这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义。\n\n项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-json&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。\n​\t\t但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jackson-datatype-jdk8&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jackson-datatype-jsr310&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.module&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jackson-module-parameter-names&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n​\t到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\nstarter与parent的区别\n​\t\t朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。\n​\t\tstarter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的。\n​\t\tparent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的。\n实际开发应用方式\n\n实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n\n如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n如果没有对应的starter，手写坐标即可\n\n\n实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理\n\n方式一：直接写坐标\n方式二：覆盖中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了\n\n&lt;properties&gt;\n    &lt;activemq.version&gt;5.16.3&lt;&#x2F;activemq.version&gt;\n    &lt;aspectj.version&gt;1.9.7&lt;&#x2F;aspectj.version&gt;\n    &lt;assertj.version&gt;3.19.0&lt;&#x2F;assertj.version&gt;\n    &lt;commons-codec.version&gt;1.15&lt;&#x2F;commons-codec.version&gt;\n    &lt;commons-dbcp2.version&gt;2.8.0&lt;&#x2F;commons-dbcp2.version&gt;\n    &lt;commons-lang3.version&gt;3.12.0&lt;&#x2F;commons-lang3.version&gt;\n    &lt;commons-pool.version&gt;1.6&lt;&#x2F;commons-pool.version&gt;\n    &lt;commons-pool2.version&gt;2.9.0&lt;&#x2F;commons-pool2.version&gt;\n    &lt;h2.version&gt;1.4.200&lt;&#x2F;h2.version&gt;\n    &lt;hibernate.version&gt;5.4.32.Final&lt;&#x2F;hibernate.version&gt;\n    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;&#x2F;hibernate-validator.version&gt;\n    &lt;httpclient.version&gt;4.5.13&lt;&#x2F;httpclient.version&gt;\n    &lt;jackson-bom.version&gt;2.12.4&lt;&#x2F;jackson-bom.version&gt;\n    &lt;javax-jms.version&gt;2.0.1&lt;&#x2F;javax-jms.version&gt;\n    &lt;javax-json.version&gt;1.1.4&lt;&#x2F;javax-json.version&gt;\n    &lt;javax-websocket.version&gt;1.1&lt;&#x2F;javax-websocket.version&gt;\n    &lt;jetty-el.version&gt;9.0.48&lt;&#x2F;jetty-el.version&gt;\n    &lt;junit.version&gt;4.13.2&lt;&#x2F;junit.version&gt;\n&lt;&#x2F;properties&gt;\n\n温馨提示\n​\t\tSpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n命名规则：spring-boot-starter-技术名称\n\n​\t所以后期见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合技术的章节再说。\n总结\n\n开发SpringBoot程序需要导入坐标时通常导入对应的starter\n每个不同的starter根据功能不同，通常包含多个依赖坐标\n使用starter可以实现快速配置的效果，达到简化配置的目的\n\n引导类​\t\t配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类，也就是带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行。\n@SpringBootApplication\npublic class Springboot0101QuickstartApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot0101QuickstartApplication.class, args);\n    &#125;\n&#125;\n\n​\t\tSpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建Spring容器对象（IoC容器）并将所有的对象放置到Spring容器中管理，也就是一个一个的Bean。现在改用SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。其实当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。\n@SpringBootApplication\npublic class QuickstartApplication &#123;\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext ctx &#x3D; SpringApplication.run(QuickstartApplication.class, args);\n        BookController bean &#x3D; ctx.getBean(BookController.class);\n        System.out.println(&quot;bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + bean);\n    &#125;\n&#125;\n\n​\t\t通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为引导类。\n​\t\t作为一个引导类最典型的特征就是当前类上方声明了一个注解@SpringBootApplication。\n总结\n\nSpringBoot工程提供引导类用来启动程序\nSpringBoot工程启动后创建并初始化Spring容器\n\n思考\n​\t\t程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？\n内嵌tomcat​\t\t当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter。\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n​\t\tSpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西，我帮你搞一个web服务器，你要愿意用的，直接使用就好了。SpringBoot又琢磨，提供一种服务器万一不满足开发者需要呢？干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。\n​\t\t由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。\n​\t\t下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题：\n\n这个服务器在什么位置定义的\n这个服务器是怎么运行的\n这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾\n\n内嵌Tomcat定义位置\n​\t\t说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n​\t\t打开web对应的starter查看导入了哪些东西。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-json&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t第三个依赖就是tomcat对应的东西了，居然也是一个starter，再打开看看。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;jakarta.annotation&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jakarta.annotation-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.3.5&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;tomcat-embed-core&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;9.0.52&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;artifactId&gt;tomcat-annotations-api&lt;&#x2F;artifactId&gt;\n                &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;\n            &lt;&#x2F;exclusion&gt;\n        &lt;&#x2F;exclusions&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;tomcat-embed-el&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;9.0.52&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;tomcat-embed-websocket&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;9.0.52&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;artifactId&gt;tomcat-annotations-api&lt;&#x2F;artifactId&gt;\n                &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;\n            &lt;&#x2F;exclusion&gt;\n        &lt;&#x2F;exclusions&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中的。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能。再来说第二个问题，这个服务器是怎么运行的。\n内嵌Tomcat运行原理\n​\t\tTomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉tomcat的话应该知道tomcat安装目录中保存有很多jar文件。\n​\t\t下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象啊。\n​\t\t如果是对象，那Spring容器是用来管理对象的，这个对象能交给Spring容器管理吗？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。怪不得我们没有安装这个tomcat但是还能用，闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;tomcat-embed-core&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;9.0.52&lt;&#x2F;version&gt;\n        &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;exclusion&gt;\n        &lt;&#x2F;exclusions&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后是一个一直运行的服务，而是直接停掉了，就是这个原因。\n更换内嵌Tomcat\n​\t\t那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器：\n\ntomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n\njetty：更轻量级，负载性能远不及tomcat\n\nundertow：负载性能勉强跑赢tomcat\n想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;exclusion&gt;\n        &lt;&#x2F;exclusions&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n总结\n\n内嵌Tomcat服务器是SpringBoot辅助功能之一\n内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n​\t\t到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识\n\n使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的\n\n学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等\n第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。\n\n\nJC-2.SpringBoot基础配置​\t\t入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它是辅助加快Spring程序的开发效率的。我们发现，现在几乎不用做任何配置功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。\n​\t\t如果想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做功能配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么覆盖SpringBoot的默认配置修改成自己的配置。\n​\t\nJC-2-1.属性配置​\t\tSpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的。\n\n​\t\t那该如何写呢？properties格式的文件书写规范是key&#x3D;value\nname=itheima\n\n​\t\t这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了。\n\n\n​\t\t根据提示敲回车，输入80端口，搞定。\nserver.port=80\n\n​\t\t下面就可以直接运行程序，测试效果了。\n​\t\t我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。\n​\t\t其实到这里我们应该得到如下三个信息：\n\nSpringBoot程序可以在application.properties文件中进行属性配置\napplication.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置\nSpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面\n\n总结\n\nSpringBoot默认配置文件是application.properties\n\n​\t\t做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。\n关闭运行日志图表（banner)\nspring.main.banner-mode=off\n\n设置运行日志的显示级别\nlogging.level.root=debug\n\n​\t\t你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。\n​\t\t我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。\n​\t\t打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n​\t\t能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然没有使用对应技术，配了也是白配。\n温馨提示\n​\t\t所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.5.4&lt;&#x2F;version&gt;\n    &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n总结\n\nSpringBoot中导入对应starter后，提供对应配置属性\n书写SpringBoot配置采用关键字+提示形式书写\n\nJC-2-2.配置文件分类​\t\t现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:\n\nproperties格式\nyml格式\nyaml格式\n\n​\t\t一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下。\n\napplication.properties（properties格式）\n\nserver.port=80\n\n\napplication.yml（yml格式）\n\nserver:\n  port: 81\n\n\napplication.yaml（yaml格式）\n\nserver:\n  port: 82\n\n​\t\t仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。\n总结\n\nSpringBoot提供了3种配置文件的格式\nproperties（传统格式&#x2F;默认格式）\nyml（主流格式）\nyaml\n\n\n\n思考\n​\t\t现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？\n配置文件优先级​\t\t其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。\n\napplication.properties（properties格式）\n\nserver.port=80\n\n\napplication.yml（yml格式）\n\nserver:\n  port: 81\n\n\napplication.yaml（yaml格式）\n\nserver:\n  port: 82\n\n​\t\t启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么。\napplication.properties  &gt;  application.yml  &gt;  application.yaml\n\n​\t\t虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。\n​\t\t最后我们把配置文件内容给修改一下\n\napplication.properties（properties格式）\n\nserver.port=80\nspring.main.banner-mode=off\n\n\napplication.yml（yml格式）\n\nserver:\n  port: 81\nlogging: \n  level: \n    root: debug\n\n\napplication.yaml（yaml格式）\n\nserver:\n  port: 82\n\n​\t\t我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，所有的配置项都会生效。\n总结\n\n配置文件间的加载优先级\tproperties（最高）&gt;  yml  &gt;  yaml（最低）\n不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n教你一招：自动提示功能消失解决方案​\t\t在做程序的过程中，可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。\n​\t\t先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下2种：\n\nIdea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能\n\nIdea认定你是合理的配置文件，但是Idea加载不到对应的提示信息\n这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：\n\n\n步骤①：打开设置，【Files】→【Project Structure…】\n\n步骤②：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块\n\n步骤③：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示\n\n步骤④：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了\n\n​\t\t到这里就做完了，其实就是Idea的一个小功能\n\n总结\n\n指定SpringBoot配置文件\n\nSetting → Project Structure → Facets\n选中对应项目&#x2F;工程\nCustomize Spring Boot\n选择配置文件\n\n\n\nJC-2-3.yaml文件​\t\tSpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。\n​\t\tYAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：\n\n.yml格式（主流）\n\n.yaml格式\n具体的语法格式要求如下：\n\n\n\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n#号 表示注释\n\n​\t\t上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开。\n​\t\t下面列出常见的数据书写格式，熟悉一下\nboolean: TRUE  \t\t\t\t\t\t#TRUE,true,True,FALSE,false，False均可\nfloat: 3.14    \t\t\t\t\t\t#6.8523015e+5  #支持科学计数法\nint: 123       \t\t\t\t\t\t#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制\nnull: ~        \t\t\t\t\t\t#使用~表示null\nstring: HelloWorld      \t\t\t#字符串可以直接书写\nstring2: &quot;Hello World&quot;  \t\t\t#可以使用双引号包裹特殊字符\ndate: 2018-02-17        \t\t\t#日期必须使用yyyy-MM-dd格式\ndatetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区\n\n​\t\t此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。\nsubject:\n\t- Java\n\t- 前端\n\t- 大数据\nenterprise:\n\tname: itcast\n    age: 16\n    subject:\n    \t- Java\n        - 前端\n        - 大数据\nlikes: [王者荣耀,刺激战场]\t\t\t#数组书写缩略格式\nusers:\t\t\t\t\t\t\t #对象数组格式一\n  - name: Tom\n   \tage: 4\n  - name: Jerry\n    age: 5\nusers:\t\t\t\t\t\t\t #对象数组格式二\n  -  \n    name: Tom\n    age: 4\n  -   \n    name: Jerry\n    age: 5\t\t\t    \nusers2: [ &#123; name:Tom , age:4 &#125; , &#123; name:Jerry , age:5 &#125; ]\t#对象数组缩略格式\n\n总结\n\nyaml语法规则\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n#号 表示注释\n\n\n注意属性名冒号后面与数据之间有一个空格\n字面值、对象数据格式、数组数据格式\n\n思考\n​\t\t现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据是给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。\nJC-2-4.yaml数据读取​\t\t对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式。\n读取单一数据​\t\tyaml中保存的单个数据，可以使用Spring中的注解@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}\n\n\n​\t\t记得使用@Value注解时，要将该注解写在某一个指定的Spring管控的bean的属性名上方，这样当bean进行初始化时候就可以读取到对应的单一数据了。\n总结\n\n使用@Value配合SpEL读取单个数据\n如果数据存在多层级，依次书写层级名称即可\n\n读取全部数据​\t\t读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n\n\n​\t\t数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法是getProperties（String），参数填写属性名即可\n总结\n\n使用Environment对象封装全部配置信息\n使用@Autowired自动装配数据到Environment对象中\n\n读取对象数据​\t\t单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作\n​\t\t首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。\n\n\n​\t\t这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。\n​\t\n温馨提示\n​\t\t细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。\n总结\n\n使用@ConfigurationProperties注解绑定配置信息到封装类中\n封装类需要定义为Spring管理的bean，否则无法进行属性注入\n\nyaml文件中的数据引用​\t\t如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\ncenter:\n\tdataDir: &#x2F;usr&#x2F;local&#x2F;fire&#x2F;data\n    tmpDir: &#x2F;usr&#x2F;local&#x2F;fire&#x2F;tmp\n    logDir: &#x2F;usr&#x2F;local&#x2F;fire&#x2F;log\n    msgDir: &#x2F;usr&#x2F;local&#x2F;fire&#x2F;msgDir\n\n​\t\t或者\ncenter:\n\tdataDir: D:&#x2F;usr&#x2F;local&#x2F;fire&#x2F;data\n    tmpDir: D:&#x2F;usr&#x2F;local&#x2F;fire&#x2F;tmp\n    logDir: D:&#x2F;usr&#x2F;local&#x2F;fire&#x2F;log\n    msgDir: D:&#x2F;usr&#x2F;local&#x2F;fire&#x2F;msgDir\n\n​\t\t这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\nbaseDir: &#x2F;usr&#x2F;local&#x2F;fire\ncenter:\n    dataDir: $&#123;baseDir&#125;&#x2F;data\n    tmpDir: $&#123;baseDir&#125;&#x2F;tmp\n    logDir: $&#123;baseDir&#125;&#x2F;log\n    msgDir: $&#123;baseDir&#125;&#x2F;msgDir\n\n​\t还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\nlesson: &quot;Spring\\tboot\\nlesson&quot;\n\n总结\n\n在配置文件中可以使用${属性名}方式引用属性值\n如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n​\t\t到这里有关yaml文件的基础使用就先告一段落，实用篇中再继续研究更深入的内容。\nJC-3.基于SpringBoot实现SSMP整合​\t\t重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式\n\n整合JUnit\n\n整合MyBatis\n\n整合MyBatis-Plus\n\n整合Druid\n上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。\n\n\nJC-3-1.整合JUnit​\t\tSpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。\n​\t\t我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式\n&#x2F;&#x2F;加载spring整合junit专用的类运行器\n@RunWith(SpringJUnit4ClassRunner.class)\n&#x2F;&#x2F;指定对应的配置信息\n@ContextConfiguration(classes &#x3D; SpringConfig.class)\npublic class AccountServiceTestCase &#123;\n    &#x2F;&#x2F;注入你要测试的对象\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testGetById()&#123;\n        &#x2F;&#x2F;执行要测试的对象对应的方法\n        System.out.println(accountService.findById(2));\n    &#125;\n&#125;\n\n\n​\t\t其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用的测试类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，每次都指定一样的东西，这个东西写起来没有技术含量啊，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。既然有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写\n​\t\tSpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下\n@SpringBootTest\nclass Springboot04JunitApplicationTests &#123;\n    &#x2F;&#x2F;注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() &#123;\n        &#x2F;&#x2F;执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(&quot;two...&quot;);\n    &#125;\n&#125;\n\n​\t\t看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——简化。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。\n​\t\t这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类\n@SpringBootTest(classes &#x3D; Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests &#123;\n    &#x2F;&#x2F;注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() &#123;\n        &#x2F;&#x2F;执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(&quot;two...&quot;);\n    &#125;\n&#125;\n\n​\t\t第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的\n@SpringBootTest\n@ContextConfiguration(classes &#x3D; Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests &#123;\n    &#x2F;&#x2F;注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() &#123;\n        &#x2F;&#x2F;执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(&quot;two...&quot;);\n    &#125;\n&#125;\n\n温馨提示\n​\t\t使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。\n总结\n\n导入测试对应的starter\n测试类使用@SpringBootTest修饰\n使用自动装配的形式添加要测试的对象\n测试类如果存在于引导类所在包或子包中无需指定引导类\n测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\nJC-3-2.整合MyBatis​\t\t整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行\n\n导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;3.5.6&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.47&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;!--1.导入mybatis与spring整合的jar包--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.3.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;!--导入spring操作数据库必选的包--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\nSpring核心配置\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;jdbc.properties&quot;)\npublic class SpringConfig &#123;\n&#125;\n\nMyBatis要交给Spring接管的bean\n&#x2F;&#x2F;定义mybatis专用的配置类\n@Configuration\npublic class MyBatisConfig &#123;\n&#x2F;&#x2F;    定义创建SqlSessionFactory对应的bean\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;\n        &#x2F;&#x2F;SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象\n        SqlSessionFactoryBean sfb &#x3D; new SqlSessionFactoryBean();\n        &#x2F;&#x2F;设置数据源替代原始配置中的environments的配置\n        sfb.setDataSource(dataSource);\n        &#x2F;&#x2F;设置类型别名替代原始配置中的typeAliases的配置\n        sfb.setTypeAliasesPackage(&quot;com.itheima.domain&quot;);\n        return sfb;\n    &#125;\n&#x2F;&#x2F;    定义加载所有的映射配置\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer()&#123;\n        MapperScannerConfigurer msc &#x3D; new MapperScannerConfigurer();\n        msc.setBasePackage(&quot;com.itheima.dao&quot;);\n        return msc;\n    &#125;\n\n&#125;\n\n数据源对应的bean，此处使用Druid数据源\n@Configuration\npublic class JdbcConfig &#123;\n    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)\n    private String driver;\n    @Value(&quot;$&#123;jdbc.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;jdbc.username&#125;&quot;)\n    private String userName;\n    @Value(&quot;$&#123;jdbc.password&#125;&quot;)\n    private String password;\n\n    @Bean(&quot;dataSource&quot;)\n    public DataSource dataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;\n\n数据库连接信息（properties格式）\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false\njdbc.username=root\njdbc.password=root\n\n上述格式基本上是最简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式\n\n\n步骤①：创建模块\n\n步骤②：勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库\n\n​\t或者手工导入对应技术的starter，和对应数据库的坐标\n&lt;dependencies&gt;\n    &lt;!--1.导入对应的starter--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n步骤③：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n​\t\t结束了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面写一个MyBatis程序运行需要的Dao（或者Mapper）就可以运行了\n实体类\npublic class Book &#123;\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n&#125;\n\n映射接口（Dao）\n@Mapper\npublic interface BookDao &#123;\n    @Select(&quot;select * from tbl_book where id &#x3D; #&#123;id&#125;&quot;)\n    public Book getById(Integer id);\n&#125;\n\n测试类\n@SpringBootTest\nclass Springboot05MybatisApplicationTests &#123;\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() &#123;\n        System.out.println(bookDao.getById(1));\n    &#125;\n&#125;\n\n​\t\t完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解\n​\t\t注意：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。使用SpringBoot2.4.3（不含）之前版本会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n    username: root\n    password: root\n\n​\t\t这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置为Asia&#x2F;Shanghai，同样可以解决这个问题。\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;Asia&#x2F;Shanghai\n    username: root\n    password: root\n\n​\t\t如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone&#x3D;+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。\n​\t\t此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用com.mysql.jdbc.Driver，换用com.mysql.cj.jdbc.Driver。前面的例子中已经更换了驱动了，在此说明一下。\nLoading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.\n\n总结\n\n整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n数据库连接相关信息转换成配置\n\n数据库SQL映射需要添加@Mapper被容器识别到\n\nMySQL 8.X驱动强制要求设置时区\n\n修改url，添加serverTimezone设定\n修改MySQL数据库配置\n\n\n驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n\nJC-3-3.整合MyBatis-Plus​\t\t做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话\n\n导入对应技术的starter坐标\n\n根据对应技术的要求做配置\n虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。\n\n\n​\t\t接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合\n步骤①：导入对应的starter\n&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n​\t\t关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式\nSpring-boot-start-***\n\n​\t而MyBatis与MyBatisPlus这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解\n\n\n\nstarter所属\n命名规则\n示例\n\n\n\n官方提供\nspring-boot-starter-技术名称\nspring-boot-starter-web spring-boot-starter-test\n\n\n第三方提供\n第三方技术名称-spring-boot-starter\nmybatis-spring-boot-starterdruid-spring-boot-starter\n\n\n第三方提供\n第三方技术名称-boot-starter（第三方技术名称过长，简化命名）\nmybatis-plus-boot-starter\n\n\n温馨提示\n​\t\t有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标。\n步骤②：配置数据源相关信息\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n​\t没了，就这么多，剩下的就是写MyBaitsPlus的程序了\n映射接口（Dao）\n@Mapper\npublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;\n&#125;\n\n​\t核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。\n\n\n​\t下面就可以写一个测试类进行测试了，此处省略。\n温馨提示\n​\t\t目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n\n总结\n\n手工添加MyBatis-Plus对应的starter\n数据层接口使用BaseMapper简化开发\n需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\nJC-3-4.整合Druid​\t\t使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。\n​\t\t前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。\n​\t\t在没有指定数据源时，我们的配置如下：\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;Asia&#x2F;Shanghai\n    username: root\n    password: root\n\n​\t\t此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。\n2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.\n2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n​\t\t上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。\n\n导入对应的技术坐标\n\n配置使用指定的数据源类型\n下面就切换一下数据源对象\n\n\n步骤①：导入对应的坐标（注意，是坐标，此处不是starter）\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n步骤②：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n    username: root\n    password: root\n    type: com.alibaba.druid.pool.DruidDataSource\n\n​\t\t这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。\n步骤①：导入对应的starter\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.2.6&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n步骤②：修改配置\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n      username: root\n      password: root\n\n​\t\t注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性是druid下面的属性，那你能想到什么？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n\n\n​\t与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。\n​\t这是我们做的第4个技术的整合方案，还是那两句话：导入对应starter，使用对应配置。没了，SpringBoot整合其他技术就这么简单粗暴。\n总结\n\n整合Druid需要导入Druid对应的starter\n根据Druid提供的配置方式进行配置\n整合第三方技术通用方式\n导入对应的starter\n根据提供的配置格式，配置非默认值对应的配置项\n\n\n\nJC-3-5.SSMP整合综合案例​\t\tSpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。\n​\t\t先看一下这个案例的最终效果\n主页面\n\n添加\n\n删除\n\n修改\n\n分页\n\n条件查询\n\n​\t整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个\n\n实体类开发————使用Lombok快速制作实体类\nDao开发————整合MyBatisPlus，制作数据层测试\nService开发————基于MyBatisPlus进行增量开发，制作业务层测试类\nController开发————基于Restful开发，使用PostMan测试接口功能\nController开发————前后端开发协议制作\n页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理\n列表\n新增\n修改\n删除\n分页\n查询\n\n\n项目异常处理\n按条件查询————页面功能调整、Controller修正功能、Service修正功能\n\n​\t\t可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟紧进度，完成这个小案例的制作。\n0.模块创建​\t\t对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。\n\n\n​\t\t我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。\n\n\n​\t\t一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。\n​\t\t下面我们创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\npom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\napplication.yml\nserver:\n  port: 80\n\n\n\n1.实体类开发​\t\t本案例对应的模块表结构如下：\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');\nINSERT INTO `tbl_book` VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');\nINSERT INTO `tbl_book` VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');\nINSERT INTO `tbl_book` VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');\nINSERT INTO `tbl_book` VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');\nINSERT INTO `tbl_book` VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');\nINSERT INTO `tbl_book` VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');\nINSERT INTO `tbl_book` VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');\nINSERT INTO `tbl_book` VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');\nINSERT INTO `tbl_book` VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');\nINSERT INTO `tbl_book` VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');\nINSERT INTO `tbl_book` VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+');\n\n​\t\t根据上述表结构，制作对应的实体类\n实体类\npublic class Book &#123;\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n&#125;\n\n​\t\t实体类的开发可以自动通过工具手工生成get&#x2F;set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。\n​\t\tLombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。\n&lt;dependencies&gt;\n    &lt;!--lombok--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n​\t\t使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加\nimport lombok.Data;\n@Data\npublic class Book &#123;\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n&#125;\n\n​\t\t到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面遇到了能用的实用开发技术时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些。\n总结\n\n实体类制作\n使用lombok简化开发\n导入lombok无需指定版本，由SpringBoot提供版本\n@Data注解\n\n\n\n2.数据层开发——基础CRUD​\t\t数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上。\n步骤①：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>com.baomidou&lt;/groupId>\n        &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n        &lt;version>3.4.3&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid-spring-boot-starter&lt;/artifactId>\n        &lt;version>1.2.6&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;scope>runtime&lt;/scope>\n    &lt;/dependency>\n&lt;/dependencies>\n\n步骤②：配置数据库连接相关的数据源配置\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n      username: root\n      password: root\n\n步骤③：使用MyBatisPlus的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定\n@Mapper\npublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;\n&#125;\n\n步骤④：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧\npackage com.itheima.dao;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.itheima.domain.Book;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\npublic class BookDaoTestCase &#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void testGetById()&#123;\n        System.out.println(bookDao.selectById(1));\n    &#125;\n\n    @Test\n    void testSave()&#123;\n        Book book &#x3D; new Book();\n        book.setType(&quot;测试数据123&quot;);\n        book.setName(&quot;测试数据123&quot;);\n        book.setDescription(&quot;测试数据123&quot;);\n        bookDao.insert(book);\n    &#125;\n\n    @Test\n    void testUpdate()&#123;\n        Book book &#x3D; new Book();\n        book.setId(17);\n        book.setType(&quot;测试数据abcdefg&quot;);\n        book.setName(&quot;测试数据123&quot;);\n        book.setDescription(&quot;测试数据123&quot;);\n        bookDao.updateById(book);\n    &#125;\n\n    @Test\n    void testDelete()&#123;\n        bookDao.deleteById(16);\n    &#125;\n\n    @Test\n    void testGetAll()&#123;\n        bookDao.selectList(null);\n    &#125;\n&#125;\n\n温馨提示\n​\t\tMyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置表名通用前缀\n      id-type: auto\t\t\t\t#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增\n\n查看MyBatisPlus运行日志​\t\t在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。\n​\t\tSpringBoot整合MyBatisPlus的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n​\t\t再来看运行结果，此时就显示了运行期执行SQL的情况。\nCreating a new SqlSession\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active\nJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring\n==>  Preparing: SELECT id,type,name,description FROM tbl_book\n==> Parameters: \n&lt;==    Columns: id, type, name, description\n&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕\n&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想\n&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式\n&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手\n&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者\n&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新\n&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖\n&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\n&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术\n&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中\n&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍\n&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+\n&lt;==        Row: 13, 测试类型, 测试数据, 测试描述数据\n&lt;==        Row: 14, 测试数据update, 测试数据update, 测试数据update\n&lt;==        Row: 15, -----------------, 测试数据123, 测试数据123\n&lt;==      Total: 15\n\n​\t\t其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。\n​\t\t此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可\n\n\n\n\n总结\n\n手工导入starter坐标（2个），mysql驱动（1个）\n\n配置数据源与MyBatisPlus对应的配置\n\n开发Dao接口（继承BaseMapper）\n\n制作测试类测试Dao功能是否有效\n\n使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志\n\n\n3.数据层开发——分页功能制作​\t\t前面仅仅是使用了MyBatisPlus提供的基础CRUD功能，实际上MyBatisPlus给我们提供了几乎所有的基础操作，这一节说一下如何实现数据库端的分页操作。\n​\t\tMyBatisPlus提供的分页操作API如下：\n@Test\nvoid testGetPage()&#123;\n    IPage page &#x3D; new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\n    System.out.println(page.getSize());\n    System.out.println(page.getTotal());\n    System.out.println(page.getPages());\n    System.out.println(page.getRecords());\n&#125;\n\n​\t\t其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据\n\n当前显示第几页\n每页显示几条数据\n\n​\t\t可以通过创建Page对象时利用构造方法初始化这两个数据。\nIPage page &#x3D; new Page(2,5);\n\n​\t\t将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？\nIPage page &#x3D; bookDao.selectPage(page, null);\n\n​\t\t原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了。\n@Test\nvoid testGetPage()&#123;\n    IPage page &#x3D; new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\t\t&#x2F;&#x2F;当前页码值\n    System.out.println(page.getSize());\t\t\t&#x2F;&#x2F;每页显示数\n    System.out.println(page.getTotal());\t\t&#x2F;&#x2F;数据总量\n    System.out.println(page.getPages());\t\t&#x2F;&#x2F;总页数\n    System.out.println(page.getRecords());\t\t&#x2F;&#x2F;详细数据\n&#125;\n\n​\t\t到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于MyBatisPlus的内部机制。\n​\t\t对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。\n​\t\t基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下：\n定义MyBatisPlus拦截器并将其设置为Spring管控的bean\n@Configuration\npublic class MPConfig &#123;\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return interceptor;\n    &#125;\n&#125;\n\n​\t\t上述代码第一行是创建MyBatisPlus的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。\n总结\n\n使用IPage封装分页数据\n分页操作依赖MyBatisPlus分页拦截器实现功能\n借助MyBatisPlus日志查阅执行SQL语句\n\n4.数据层开发——条件查询功能制作​\t\t除了分页功能，MyBatisPlus还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。这里给大家普及一下基本格式，详细的操作还是到MyBatisPlus的课程中查阅吧。\n​\t\t下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用。\n@Test\nvoid testGetBy()&#123;\n    QueryWrapper&lt;Book&gt; qw &#x3D; new QueryWrapper&lt;&gt;();\n    qw.like(&quot;name&quot;,&quot;Spring&quot;);\n    bookDao.selectList(qw);\n&#125;\n\n​\t\t其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。\n​\t\t这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n​\t\tMyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就避免了上述问题的出现。\n@Test\nvoid testGetBy2()&#123;\n    String name &#x3D; &quot;1&quot;;\n    LambdaQueryWrapper&lt;Book&gt; lqw &#x3D; new LambdaQueryWrapper&lt;Book&gt;();\n    lqw.like(Book::getName,name);\n    bookDao.selectList(lqw);\n&#125;\n\n​\t\t为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。\n@Test\nvoid testGetBy2()&#123;\n    String name &#x3D; &quot;1&quot;;\n    LambdaQueryWrapper&lt;Book&gt; lqw &#x3D; new LambdaQueryWrapper&lt;Book&gt;();\n    &#x2F;&#x2F;if(name !&#x3D; null) lqw.like(Book::getName,name);\t\t&#x2F;&#x2F;方式一：JAVA代码控制\n    lqw.like(name !&#x3D; null,Book::getName,name);\t\t\t\t&#x2F;&#x2F;方式二：API接口提供控制开关\n    bookDao.selectList(lqw);\n&#125;\n\n​\t\t其实就是个格式，没有区别。关于MyBatisPlus的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴建议还是完整的学习一下MyBatisPlus的知识吧，这里只是蜻蜓点水的用了几个操作而已。\n总结\n\n使用QueryWrapper对象封装查询条件\n\n推荐使用LambdaQueryWrapper对象\n\n所有查询操作封装成方法调用\n\n查询条件支持动态条件拼装\n\n\n5.业务层开发​\t\t数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。\n​\t\t一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\nlogin(String username,String password);\n\n​\t\t而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\nselectByUserNameAndPassword(String username,String password);\n\n​\t\t我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据\n接口：传入ID字段，查询出对应结果，结果是单条数据\n接口：传入离职字段，查询出对应结果，结果是多条数据\n\n​\t\t但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR\n\n​\t\t你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。\n​\t\t多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：\npublic interface BookService &#123;\n    Boolean save(Book book);\n    Boolean update(Book book);\n    Boolean delete(Integer id);\n    Book getById(Integer id);\n    List&lt;Book&gt; getAll();\n    IPage&lt;Book&gt; getPage(int currentPage,int pageSize);\n&#125;\n\n​\t\t业务层实现类如下，转调数据层即可：\n@Service\npublic class BookServiceImpl implements BookService &#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public Boolean save(Book book) &#123;\n        return bookDao.insert(book) &gt; 0;\n    &#125;\n\n    @Override\n    public Boolean update(Book book) &#123;\n        return bookDao.updateById(book) &gt; 0;\n    &#125;\n\n    @Override\n    public Boolean delete(Integer id) &#123;\n        return bookDao.deleteById(id) &gt; 0;\n    &#125;\n\n    @Override\n    public Book getById(Integer id) &#123;\n        return bookDao.selectById(id);\n    &#125;\n\n    @Override\n    public List&lt;Book&gt; getAll() &#123;\n        return bookDao.selectList(null);\n    &#125;\n\n    @Override\n    public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) &#123;\n        IPage page &#x3D; new Page(currentPage,pageSize);\n        bookDao.selectPage(page,null);\n        return page;\n    &#125;\n&#125;\n\n​\t\t别忘了对业务层接口进行测试，测试类如下：\n@SpringBootTest\npublic class BookServiceTest &#123;\n    @Autowired\n    private IBookService bookService;\n\n    @Test\n    void testGetById()&#123;\n        System.out.println(bookService.getById(4));\n    &#125;\n    @Test\n    void testSave()&#123;\n        Book book &#x3D; new Book();\n        book.setType(&quot;测试数据123&quot;);\n        book.setName(&quot;测试数据123&quot;);\n        book.setDescription(&quot;测试数据123&quot;);\n        bookService.save(book);\n    &#125;\n    @Test\n    void testUpdate()&#123;\n        Book book &#x3D; new Book();\n        book.setId(17);\n        book.setType(&quot;-----------------&quot;);\n        book.setName(&quot;测试数据123&quot;);\n        book.setDescription(&quot;测试数据123&quot;);\n        bookService.updateById(book);\n    &#125;\n    @Test\n    void testDelete()&#123;\n        bookService.removeById(18);\n    &#125;\n\n    @Test\n    void testGetAll()&#123;\n        bookService.list();\n    &#125;\n\n    @Test\n    void testGetPage()&#123;\n        IPage&lt;Book&gt; page &#x3D; new Page&lt;Book&gt;(2,5);\n        bookService.page(page);\n        System.out.println(page.getCurrent());\n        System.out.println(page.getSize());\n        System.out.println(page.getTotal());\n        System.out.println(page.getPages());\n        System.out.println(page.getRecords());\n    &#125;\n\n&#125;\n\n总结\n\nService接口名称定义成业务名称，并与Dao接口名称进行区分\n制作测试类测试Service功能是否有效\n\n业务层快速开发​\t\t其实MyBatisPlus技术不仅提供了数据层快速开发方案，业务层MyBatisPlus也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用。\n​\t\t业务层接口快速开发\npublic interface IBookService extends IService&lt;Book&gt; &#123;\n    &#x2F;&#x2F;添加非通用操作API接口\n&#125;\n\n​\t\t业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。\n@Service\npublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;\n    @Autowired\n    private BookDao bookDao;\n\t&#x2F;&#x2F;添加非通用操作API\n&#125;\n\n​\t\t如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。\n总结\n\n使用通用接口（ISerivce）快速开发Service\n使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl\n可以在通用接口基础上做功能重载或功能追加\n注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n6.表现层开发​\t\t终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行。\n​\t\t表现层接口如下:\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController2 &#123;\n\n    @Autowired\n    private IBookService bookService;\n\n    @GetMapping\n    public List&lt;Book&gt; getAll()&#123;\n        return bookService.list();\n    &#125;\n\n    @PostMapping\n    public Boolean save(@RequestBody Book book)&#123;\n        return bookService.save(book);\n    &#125;\n\n    @PutMapping\n    public Boolean update(@RequestBody Book book)&#123;\n        return bookService.modify(book);\n    &#125;\n\n    @DeleteMapping(&quot;&#123;id&#125;&quot;)\n    public Boolean delete(@PathVariable Integer id)&#123;\n        return bookService.delete(id);\n    &#125;\n\n    @GetMapping(&quot;&#123;id&#125;&quot;)\n    public Book getById(@PathVariable Integer id)&#123;\n        return bookService.getById(id);\n    &#125;\n\n    @GetMapping(&quot;&#123;currentPage&#125;&#x2F;&#123;pageSize&#125;&quot;)\n    public IPage&lt;Book&gt; getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;\n        return bookService.getPage(currentPage,pageSize, null);\n    &#125;\n&#125;\n\n​\t\t在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了。\n普通GET请求\n\nPUT请求传递json数据，后台实用@RequestBody接收数据\n\nGET请求传递路径变量，后台实用@PathVariable接收数据\n\n总结\n\n基于Restful制作表现层接口\n新增：POST\n删除：DELETE\n修改：PUT\n查询：GET\n\n\n接收参数\n实体数据：@RequestBody\n路径变量：@PathVariable\n\n\n\n7.表现层消息一致性处理​\t\t目前我们通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。\n​\t增删改操作结果\ntrue\n\n​\t查询单个数据操作结果\n&#123;\n    \"id\": 1,\n    \"type\": \"计算机理论\",\n    \"name\": \"Spring实战 第5版\",\n    \"description\": \"Spring入门经典教程\"\n&#125;\n\n​\t查询全部数据操作结果\n[\n    &#123;\n        \"id\": 1,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring实战 第5版\",\n        \"description\": \"Spring入门经典教程\"\n    &#125;,\n    &#123;\n        \"id\": 2,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring 5核心原理与30个类手写实战\",\n        \"description\": \"十年沉淀之作\"\n    &#125;\n]\n\n​\t\t每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议\n@Data\npublic class R &#123;\n    private Boolean flag;\n    private Object data;\n&#125;\n\n​\t\t其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了\n&#123;\n    &quot;flag&quot;: true,\n    &quot;data&quot;:&#123;\n        &quot;id&quot;: 1,\n        &quot;type&quot;: &quot;计算机理论&quot;,\n        &quot;name&quot;: &quot;Spring实战 第5版&quot;,\n        &quot;description&quot;: &quot;Spring入门经典教程&quot;\n    &#125;\n&#125;\n\n​\t\t表现层开发格式也需要转换一下\n\n\n\n\n\n\n​\t\t结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。\n总结\n\n设计统一的返回值结果类型便于前端开发读取数据\n\n返回值结果类型可以根据需求自行设定，没有固定格式\n\n返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n\n8.前后端联通性测试​\t\t后端的表现层接口开发完毕，就可以进行前端的开发了。\n​\t\t将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。\n​\t\n​\t\t在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。\n//列表\ngetAll() &#123;\n\taxios.get(\"/books\").then((res)=>&#123;\n\t\tconsole.log(res.data);\n\t&#125;);\n&#125;,\n\n​\t\t只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。\n总结\n\n单体项目中页面放置在resources&#x2F;static目录下\ncreated钩子函数用于初始化页面时发起调用\n页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n9.页面基础功能开发F-1.列表功能（非分页版）​\t\t列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。\n​\t\t页面数据模型定义\ndata:&#123;\n\tdataList: [],\t\t//当前页要展示的列表数据\n\t...\n&#125;,\n\n​\t\t异步请求获取数据\n&#x2F;&#x2F;列表\ngetAll() &#123;\n    axios.get(&quot;&#x2F;books&quot;).then((res)&#x3D;&gt;&#123;\n        this.dataList &#x3D; res.data.data;\n    &#125;);\n&#125;,\n\n​\t\t这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了。\n总结：\n\n将查询数据返回到页面，利用前端数据绑定进行数据展示\n\nF-2.添加功能​\t\t添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。\n​\t\t默认状态\ndata:&#123;\n\tdialogFormVisible: false,\t//添加表单是否可见\n\t...\n&#125;,\n\n​\t\t切换为显示状态\n&#x2F;&#x2F;弹出添加窗口\nhandleCreate() &#123;\n\tthis.dialogFormVisible &#x3D; true;\n&#125;,\n\n​\t\t由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。\n​\t\t定义清理数据操作\n//重置表单\nresetForm() &#123;\n    this.formData = &#123;&#125;;\n&#125;,\n\n​\t\t切换弹窗状态时清理数据\n//弹出添加窗口\nhandleCreate() &#123;\n    this.dialogFormVisible = true;\n    this.resetForm();\n&#125;,\n\n​\t\t至此准备工作完成，下面就要调用后台完成添加操作了。\n​\t\t添加操作\n//添加\nhandleAdd () &#123;\n    //发送异步请求\n    axios.post(\"/books\",this.formData).then((res)=>&#123;\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag)&#123;\n            this.dialogFormVisible = false;\n            this.$message.success(\"添加成功\");\n        &#125;else &#123;\n            this.$message.error(\"添加失败\");\n        &#125;\n    &#125;).finally(()=>&#123;\n        this.getAll();\n    &#125;);\n&#125;,\n\n\n将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n根据返回的操作结果决定下一步操作\n如何是true就关闭添加窗口，显示添加成功的消息\n如果是false保留添加窗口，显示添加失败的消息\n\n\n无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）\n\n​\t\t取消添加操作\n&#x2F;&#x2F;取消\ncancel()&#123;\n    this.dialogFormVisible &#x3D; false;\n    this.$message.info(&quot;操作取消&quot;);\n&#125;,\n\n总结\n\n请求方式使用POST调用后台对应操作\n添加操作结束后动态刷新页面加载数据\n根据操作结果不同，显示对应的提示信息\n弹出添加Div时清除表单数据\n\nF-3.删除功能​\t\t模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可。\n​\t\t删除操作\n&#x2F;&#x2F; 删除\nhandleDelete(row) &#123;\n    axios.delete(&quot;&#x2F;books&#x2F;&quot;+row.id).then((res)&#x3D;&gt;&#123;\n        if(res.data.flag)&#123;\n            this.$message.success(&quot;删除成功&quot;);\n        &#125;else&#123;\n            this.$message.error(&quot;删除失败&quot;);\n        &#125;\n    &#125;).finally(()&#x3D;&gt;&#123;\n        this.getAll();\n    &#125;);\n&#125;,\n\n​\t\t删除操作提示信息\n&#x2F;&#x2F; 删除\nhandleDelete(row) &#123;\n    &#x2F;&#x2F;1.弹出提示框\n    this.$confirm(&quot;此操作永久删除当前数据，是否继续？&quot;,&quot;提示&quot;,&#123;\n        type:&#39;info&#39;\n    &#125;).then(()&#x3D;&gt;&#123;\n        &#x2F;&#x2F;2.做删除业务\n        axios.delete(&quot;&#x2F;books&#x2F;&quot;+row.id).then((res)&#x3D;&gt;&#123;\n       \t\tif(res.data.flag)&#123;\n            \tthis.$message.success(&quot;删除成功&quot;);\n        \t&#125;else&#123;\n            \tthis.$message.error(&quot;删除失败&quot;);\n        \t&#125;\n        &#125;).finally(()&#x3D;&gt;&#123;\n            this.getAll();\n        &#125;);\n    &#125;).catch(()&#x3D;&gt;&#123;\n        &#x2F;&#x2F;3.取消删除\n        this.$message.info(&quot;取消删除操作&quot;);\n    &#125;);\n&#125;，\t\n\n总结\n\n请求方式使用Delete调用后台对应操作\n删除操作需要传递当前行数据对应的id值到后台\n删除操作结束后动态刷新页面加载数据\n根据操作结果不同，显示对应的提示信息\n删除操作前弹出提示框避免误操作\n\nF-4.修改功能​\t\t修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n\n弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据\n\n查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n\n查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据\n\n修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n所以整体上来看，修改功能就是前面几个功能的大合体\n查询并展示数据\n\n\n&#x2F;&#x2F;弹出编辑窗口\nhandleUpdate(row) &#123;\n    axios.get(&quot;&#x2F;books&#x2F;&quot;+row.id).then((res)&#x3D;&gt;&#123;\n        if(res.data.flag)&#123;\n            &#x2F;&#x2F;展示弹层，加载数据\n            this.formData &#x3D; res.data.data;\n            this.dialogFormVisible4Edit &#x3D; true;\n        &#125;else&#123;\n            this.$message.error(&quot;数据同步失败，自动刷新&quot;);\n        &#125;\n    &#125;);\n&#125;,\n\n​\t\t修改操作\n&#x2F;&#x2F;修改\nhandleEdit() &#123;\n    axios.put(&quot;&#x2F;books&quot;,this.formData).then((res)&#x3D;&gt;&#123;\n        &#x2F;&#x2F;如果操作成功，关闭弹层并刷新页面\n        if(res.data.flag)&#123;\n            this.dialogFormVisible4Edit &#x3D; false;\n            this.$message.success(&quot;修改成功&quot;);\n        &#125;else &#123;\n            this.$message.error(&quot;修改失败，请重试&quot;);\n        &#125;\n    &#125;).finally(()&#x3D;&gt;&#123;\n        this.getAll();\n    &#125;);\n&#125;,\n\n总结\n\n加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）\n利用前端双向数据绑定将查询到的数据进行回显（同查询全部）\n请求方式使用PUT调用后台对应操作（同新增传递数据）\n修改操作结束后动态刷新页面加载数据（同新增）\n根据操作结果不同，显示对应的提示信息（同新增）\n\n​\t\n10.业务消息一致性处理​\t\t目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。\n&#123;\n    \"timestamp\": \"2021-09-15T03:27:31.038+00:00\",\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"path\": \"/books\"\n&#125;\n\n​\t\t面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？\n&#123;\n    \"flag\": true,\n    \"data\":&#123;\n        \"id\": 1,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring实战 第5版\",\n        \"description\": \"Spring入门经典教程\"\n    &#125;\n&#125;\n\n​\t\t看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。\n​\t\t首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。\n@Data\npublic class R&#123;\n    private Boolean flag;\n    private Object data;\n    private String msg;\t\t&#x2F;&#x2F;用于封装消息\n&#125;\n\n​\t\t后台代码也要根据情况做处理，当前是模拟的错误。\n@PostMapping\npublic R save(@RequestBody Book book) throws IOException &#123;\n    Boolean flag &#x3D; bookService.insert(book);\n    return new R(flag , flag ? &quot;添加成功^_^&quot; : &quot;添加失败-_-!&quot;);\n&#125;\n\n​\t\t然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理。\n@RestControllerAdvice\npublic class ProjectExceptionAdvice &#123;\n    @ExceptionHandler(Exception.class)\n    public R doOtherException(Exception ex)&#123;\n        &#x2F;&#x2F;记录日志\n        &#x2F;&#x2F;发送消息给运维\n        &#x2F;&#x2F;发送邮件给开发人员,ex对象发送给开发人员\n        ex.printStackTrace();\n        return new R(false,null,&quot;系统错误，请稍后再试！&quot;);\n    &#125;\n&#125;\n\n​\t\t页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息。\n&#x2F;&#x2F;添加\nhandleAdd () &#123;\n\t&#x2F;&#x2F;发送ajax请求\n    axios.post(&quot;&#x2F;books&quot;,this.formData).then((res)&#x3D;&gt;&#123;\n        &#x2F;&#x2F;如果操作成功，关闭弹层，显示数据\n        if(res.data.flag)&#123;\n            this.dialogFormVisible &#x3D; false;\n            this.$message.success(&quot;添加成功&quot;);\n        &#125;else &#123;\n            this.$message.error(res.data.msg);\t\t\t&#x2F;&#x2F;消息来自于后台传递过来，而非固定内容\n        &#125;\n    &#125;).finally(()&#x3D;&gt;&#123;\n        this.getAll();\n    &#125;);\n&#125;,\n\n总结\n\n使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的\n异常处理器必须被扫描加载，否则无法生效\n表现层返回结果的模型类中添加消息属性用来传递消息到页面\n\n​\t\n11.页面功能开发F-5.分页功能​\t\t分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件。\n&lt;!--分页组件-->\n&lt;div class=\"pagination-container\">\n    &lt;el-pagination\n\t\tclass=\"pagiantion\"\n\t\t@current-change=\"handleCurrentChange\"\n\t\t:current-page=\"pagination.currentPage\"\n\t\t:page-size=\"pagination.pageSize\"\n\t\tlayout=\"total, prev, pager, next, jumper\"\n\t\t:total=\"pagination.total\">\n    &lt;/el-pagination>\n&lt;/div>\n\n​\t\t为了配合分页组件，封装分页对应的数据模型。\ndata:&#123;\n\tpagination: &#123;\t\n\t\t//分页相关模型数据\n\t\tcurrentPage: 1,\t//当前页码\n\t\tpageSize:10,\t//每页显示的记录数\n\t\ttotal:0,\t\t//总记录数\n\t&#125;\n&#125;,\n\n​\t\t修改查询全部功能为分页查询，通过路径变量传递页码信息参数。\ngetAll() &#123;\n    axios.get(&quot;&#x2F;books&#x2F;&quot;+this.pagination.currentPage+&quot;&#x2F;&quot;+this.pagination.pageSize).then((res) &#x3D;&gt; &#123;\n    &#125;);\n&#125;,\n\n​\t\t后台提供对应的分页功能。\n@GetMapping(&quot;&#x2F;&#123;currentPage&#125;&#x2F;&#123;pageSize&#125;&quot;)\npublic R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize)&#123;\n    IPage&lt;Book&gt; pageBook &#x3D; bookService.getPage(currentPage, pageSize);\n    return new R(null !&#x3D; pageBook ,pageBook);\n&#125;\n\n​\t\t页面根据分页操作结果读取对应数据，并进行数据模型绑定。\ngetAll() &#123;\n    axios.get(&quot;&#x2F;books&#x2F;&quot;+this.pagination.currentPage+&quot;&#x2F;&quot;+this.pagination.pageSize).then((res) &#x3D;&gt; &#123;\n        this.pagination.total &#x3D; res.data.data.total;\n        this.pagination.currentPage &#x3D; res.data.data.current;\n        this.pagination.pagesize &#x3D; res.data.data.size;\n        this.dataList &#x3D; res.data.data.records;\n    &#125;);\n&#125;,\n\n​\t\t对切换页码操作设置调用当前分页操作。\n&#x2F;&#x2F;切换页码\nhandleCurrentChange(currentPage) &#123;\n    this.pagination.currentPage &#x3D; currentPage;\n    this.getAll();\n&#125;,\n\n总结\n\n使用el分页组件\n定义分页组件绑定的数据模型\n异步调用获取分页数据\n分页数据页面回显\n\nF-6.删除功能维护​\t\t由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。\n@GetMapping(&quot;&#123;currentPage&#125;&#x2F;&#123;pageSize&#125;&quot;)\npublic R getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;\n    IPage&lt;Book&gt; page &#x3D; bookService.getPage(currentPage, pageSize);\n    &#x2F;&#x2F;如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentPage &gt; page.getPages())&#123;\n        page &#x3D; bookService.getPage((int)page.getPages(), pageSize);\n    &#125;\n    return new R(true, page);\n&#125;\n\n\n\nF-7.条件查询功能​\t\t最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了\n\n页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关数据转换成2个分页数据加若干个条件\n\n后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大\n\n查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略\n经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。\n页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递。\n页面封装查询条件字段\npagination: &#123;\t\t\n&#x2F;&#x2F;分页相关模型数据\n\tcurrentPage: 1,\t\t&#x2F;&#x2F;当前页码\n\tpageSize:10,\t\t&#x2F;&#x2F;每页显示的记录数\n\ttotal:0,\t\t\t&#x2F;&#x2F;总记录数\n\tname: &quot;&quot;,\n\ttype: &quot;&quot;,\n\tdescription: &quot;&quot;\n&#125;,\n\n页面添加查询条件字段对应的数据模型绑定名称\n&lt;div class&#x3D;&quot;filter-container&quot;&gt;\n    &lt;el-input placeholder&#x3D;&quot;图书类别&quot; v-model&#x3D;&quot;pagination.type&quot; class&#x3D;&quot;filter-item&quot;&#x2F;&gt;\n    &lt;el-input placeholder&#x3D;&quot;图书名称&quot; v-model&#x3D;&quot;pagination.name&quot; class&#x3D;&quot;filter-item&quot;&#x2F;&gt;\n    &lt;el-input placeholder&#x3D;&quot;图书描述&quot; v-model&#x3D;&quot;pagination.description&quot; class&#x3D;&quot;filter-item&quot;&#x2F;&gt;\n    &lt;el-button @click&#x3D;&quot;getAll()&quot; class&#x3D;&quot;dalfBut&quot;&gt;查询&lt;&#x2F;el-button&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot; class&#x3D;&quot;butT&quot; @click&#x3D;&quot;handleCreate()&quot;&gt;新建&lt;&#x2F;el-button&gt;\n&lt;&#x2F;div&gt;\n\n将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求\ngetAll() &#123;\n    &#x2F;&#x2F;1.获取查询条件,拼接查询条件\n    param &#x3D; &quot;?name&#x3D;&quot;+this.pagination.name;\n    param +&#x3D; &quot;&amp;type&#x3D;&quot;+this.pagination.type;\n    param +&#x3D; &quot;&amp;description&#x3D;&quot;+this.pagination.description;\n    console.log(&quot;-----------------&quot;+ param);\n    axios.get(&quot;&#x2F;books&#x2F;&quot;+this.pagination.currentPage+&quot;&#x2F;&quot;+this.pagination.pageSize+param).then((res) &#x3D;&gt; &#123;\n        this.dataList &#x3D; res.data.data.records;\n    &#125;);\n&#125;,\n\n后台代码中定义实体类封查询条件\n@GetMapping(&quot;&#123;currentPage&#125;&#x2F;&#123;pageSize&#125;&quot;)\npublic R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) &#123;\n    System.out.println(&quot;参数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;+book);\n    IPage&lt;Book&gt; pageBook &#x3D; bookService.getPage(currentPage,pageSize);\n    return new R(null !&#x3D; pageBook ,pageBook);\n&#125;\n\n对应业务层接口与实现类进行修正\npublic interface IBookService extends IService&lt;Book&gt; &#123;\n    IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook);\n&#125;\n\n@Service\npublic class BookServiceImpl2 extends ServiceImpl&lt;BookDao,Book&gt; implements IBookService &#123;\n    public IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook)&#123;\n        IPage page &#x3D; new Page(currentPage,pageSize);\n        LambdaQueryWrapper&lt;Book&gt; lqw &#x3D; new LambdaQueryWrapper&lt;Book&gt;();\n        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());\n        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());\n        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());\n        return bookDao.selectPage(page,lqw);\n    &#125;\n&#125;\n\n页面回显数据\ngetAll() &#123;\n    //1.获取查询条件,拼接查询条件\n    param = \"?name=\"+this.pagination.name;\n    param += \"&amp;type=\"+this.pagination.type;\n    param += \"&amp;description=\"+this.pagination.description;\n    console.log(\"-----------------\"+ param);\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param).then((res) => &#123;\n        this.pagination.total = res.data.data.total;\n        this.pagination.currentPage = res.data.data.current;\n        this.pagination.pagesize = res.data.data.size;\n        this.dataList = res.data.data.records;\n    &#125;);\n&#125;,\n\n总结\n\n定义查询条件数据模型（当前封装到分页数据模型中）\n异步调用分页功能并通过请求参数传递数据到后台\n\n基础篇完结​\t\t基础篇到这里就全部结束了，在基础篇中带着大家学习了如何创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。\nSpringBoot运维实用篇​\t\t基础篇发布以后，看到了很多小伙伴在网上的留言，也帮助超过100位小伙伴解决了一些遇到的问题，并且已经发现了部分问题具有典型性，预计将有些问题在后面篇章的合适位置添加到本套课程中，作为解决方案提供给大家。\n​\t\t从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全SpringBoot的知识图谱。比如在基础篇中只给大家讲了yaml的语法格式，但是具体写yaml文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。\n​\t\t实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。\n​\t\t下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：\n\nSpringBoot程序的打包与运行\n配置高级\n多环境开发\n日志\n\n​\t\t下面开启第一部分SpringBoot程序打包与运行的学习\nYW-1.SpringBoot程序的打包与运行​\t\t刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。\n\n\n\n\n​\t\t但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。\n\n\n​\t\t我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。\n\n\n​\t\t那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。\n温馨提示\n​\t\t企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。\n\n开发部门使用Git、SVN等版本控制工具上传工程到版本服务器\n服务器使用版本控制工具下载工程\n服务器上使用Maven工具在当前真机环境下重新构建项目\n启动服务\n\n​\t\t继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。\n程序打包​\t\tSpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。\nmvn package\n\n​\t\t打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。\n程序运行​\t\t程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。\njava -jar 工程包名.jar\n\n​\t\t执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。\n​\t\t特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。\n​\t\t特别关注：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n总结\n\nSpringBoot工程可以基于java环境下独立运行jar文件启动服务\nSpringBoot工程执行mvn命令package进行打包\n执行jar命令：java –jar 工程名.jar\n\nSpringBoot程序打包失败处理​\t\t有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象\n\n\n​\t\t要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。\n​\t\t搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。\n​\t\t在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n​\t\t我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征\n\n打包后文件的大小不同\n打包后所包含的内容不同\n打包程序中个别文件内容不同\n\n​\t\t先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：\n\n\n​\t\t不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。\n​\t\t\n​\t\t我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。\n​\t\t\n​\t\t原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。\n​\t\t\n​\t\t仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。\n​\t\t再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个JarLauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。\n​\t\t回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别\n\n小容量文件的MANIFEST.MF\nManifest-Version: 1.0\nImplementation-Title: springboot_08_ssmp\nImplementation-Version: 0.0.1-SNAPSHOT\nBuild-Jdk-Spec: 1.8\nCreated-By: Maven Jar Plugin 3.2.0\n\n大容量文件的MANIFEST.MF\nManifest-Version: 1.0\nSpring-Boot-Classpath-Index: BOOT-INF&#x2F;classpath.idx\nImplementation-Title: springboot_08_ssmp\nImplementation-Version: 0.0.1-SNAPSHOT\nSpring-Boot-Layers-Index: BOOT-INF&#x2F;layers.idx\nStart-Class: com.itheima.SSMPApplication\nSpring-Boot-Classes: BOOT-INF&#x2F;classes&#x2F;\nSpring-Boot-Lib: BOOT-INF&#x2F;lib&#x2F;\nBuild-Jdk-Spec: 1.8\nSpring-Boot-Version: 2.5.4\nCreated-By: Maven Jar Plugin 3.2.0\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n​\t\t大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.JarLauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.JarLauncher类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。\n​\t\t现在这组设定的作用就搞清楚了\n\nSpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包\n首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类\nJarLauncher类执行时会找到Start-Class属性，也就是启动类类名\n运行启动类时会运行当前工程的内容\n运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n​\t\t看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。\n​\t\t再来看之前的报错信息：\n\n\n​\t\t由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。\n​\t\t上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。\n总结\n\nspring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包\n\n命令行启动常见问题及解决方案​\t\t各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。\n# 查询端口\nnetstat -ano\n# 查询指定端口\nnetstat -ano |findstr &quot;端口号&quot;\n# 根据进程PID查询进程名称\ntasklist |findstr &quot;进程PID号&quot;\n# 根据PID杀死任务\ntaskkill &#x2F;F &#x2F;PID &quot;进程PID号&quot;\n# 根据进程名称杀死任务\ntaskkill -f -t -im &quot;进程名称&quot;\n\n​\t\t关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。\nSpringBoot项目快速启动（Linux版）​\t\t其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。\nYW-2.配置高级​\t\t关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。\nYW-2-1.临时属性设置​\t\t目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n                          \n​\t\tSpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\njava –jar springboot.jar –-server.port&#x3D;80\n\n​\t\t上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名&#x3D;属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。\n​\t\t如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\njava –jar springboot.jar –-server.port&#x3D;80 --logging.level.root&#x3D;debug\n\n属性加载优先级​\t\t现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n\n​\t\t我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。\n​\t\t比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。\n​\t\t我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。\n总结\n\n使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性\n临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值\n多个临时属性之间使用空格分隔\n临时属性必须是当前boot工程支持的属性，否则设置无效\n\n开发环境中使用临时属性​\t\t临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。\n​\t\t打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n\n​\t\t做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\npublic static void main(String[] args) &#123;\n&#125;\n\n​\t\t原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\npublic static void main(String[] args) &#123;\n    SpringApplication.run(SSMPApplication.class,args);\n&#125;\n\n​\t\t这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。\npublic static void main(String[] args) &#123;\n    SpringApplication.run(SSMPApplication.class);\n&#125;\n\n​\t\t或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\npublic static void main(String[] args) &#123;\n    String[] arg &#x3D; new String[1];\n    arg[0] &#x3D; &quot;--server.port&#x3D;8082&quot;;\n    SpringApplication.run(SSMPApplication.class, arg);\n&#125;\n\n总结\n\n启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性\n\n思考\n​\t\t现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。\nYW-2-2.配置文件分类​\t\tSpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：\n\n类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n类路径下config目录下配置文件\n程序包所在目录中配置文件\n程序包所在目录中config目录下配置文件\n\n​\t\t好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为\n\nfile ：config&#x2F;application.yml 【最高】\nfile ：application.yml\nclasspath：config&#x2F;application.yml\nclasspath：application.yml  【最低】\n\n​\t\t那为什么设计这种多种呢？说一个最典型的应用吧。\n\n场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。\n场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n​\t\t解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n​\t\t级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。\n总结\n\n配置文件分为4种\n\n项目类路径配置文件：服务于开发人员本机开发与测试\n项目类路径config目录中配置文件：服务于项目经理整体调控\n工程路径配置文件：服务于运维人员配置涉密线上环境\n工程路径config目录中配置文件：服务于运维经理整体调控\n\n\n多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n\nYW-2-3.自定义配置文件​\t\t之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n​\t\t自定义配置文件方式有如下两种：\n方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名\n\n\n方式二：使用临时属性设置配置文件路径，这个是全路径名\n\n\n​\t\t也可以设置加载多个配置文件\n\n\n​\t\t使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。\n温馨提示\n​\t\t我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。\n总结\n\n配置文件可以修改名称，通过启动参数设定\n配置文件可以修改路径，通过启动参数设定\n微服务开发中配置文件通过配置中心进行设置\n\nYW-3.多环境开发​\t\t讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。\n​\t\t什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n\nYW-3-1.多环境开发（yaml单一文件版）​\t\t那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\nserver:\n  port: 80\n\n​\t\t如何想设计两组环境呢？中间使用三个减号分隔开\nserver:\n  port: 80\n---\nserver:\n  port: 81\n\n​\t\t如何区分两种环境呢？起名字呗\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n​\t\t那用哪一个呢？设置默认启动哪个就可以了\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n​\t\t就这么简单，再多来一组环境也OK\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n---\nspring:\n\tprofiles: test\nserver:\n\tport: 82\n\n​\t\t其中关于环境名称定义上述格式是过时格式，标准格式如下\nspring:\n\tconfig:\n    \tactivate:\n        \ton-profile: pro\n\n总结\n\n多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\nyaml格式中设置多环境使用—区分环境设置边界\n每种环境的区别在于加载的配置属性不同\n启用某种环境时需要指定启动时使用该环境\n\nYW-3-2.多环境开发（yaml多文件版）​\t\t将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n主配置文件\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n\n环境配置文件\nserver:\n\tport: 80\n\n​\t\t环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。\napplication-pro.yaml\nserver:\n\tport: 80\n\napplication-dev.yaml\nserver:\n\tport: 81\n\n​\t\t文件的命名规则为：application-环境名.yml。\n​\t\t在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n主配置文件中设置公共配置（全局）\n环境分类配置文件中常用于设置冲突属性（局部）\n\n总结\n\n可以使用独立配置文件定义环境属性\n\n独立配置文件便于线上系统维护更新并保障系统安全性\n\n\nYW-3-3.多环境开发（properties多文件版）​\t\tSpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。\n主配置文件\nspring.profiles.active=pro\n\n环境配置文件\napplication-pro.properties\nserver.port=80\n\napplication-dev.properties\nserver.port=81\n\n​\t\t文件的命名规则为：application-环境名.properties。\n总结\n\nproperties文件多环境配置仅支持多文件格式\n\nYW-3-4.多环境开发独立配置文件书写技巧​\t\t作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n准备工作\n​\t\t将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\napplication-devDB.yml\napplication-devRedis.yml\napplication-devMVC.yml\n\n使用\n​\t\t使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\nspring:\n\tprofiles:\n    \tactive: dev\n        include: devDB,devRedis,devMVC\n\n​\t\t比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n注意\n​\t\t当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n改良\n​\t\t但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\nspring:\n\tprofiles:\n    \tactive: dev\n        group:\n        \t\"dev\": devDB,devRedis,devMVC\n      \t\t\"pro\": proDB,proRedis,proMVC\n      \t\t\"test\": testDB,testRedis,testMVC\n\n​\t\t现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！\n总结\n\n多环境开发使用group属性设置配置文件分组，便于线上维护管理\n\nYW-3-5.多环境开发控制​\t\t多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。\n​\t\t要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。\n​\t\tmaven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：\n\n先在maven环境中设置用什么具体的环境\n在SpringBoot中读取maven设置的环境即可\n\nmaven中设置多环境（使用属性方式区分环境）\n&lt;profiles>\n    &lt;profile>\n        &lt;id>env_dev&lt;/id>\n        &lt;properties>\n            &lt;profile.active>dev&lt;/profile.active>\n        &lt;/properties>\n        &lt;activation>\n            &lt;activeByDefault>true&lt;/activeByDefault>\t\t&lt;!--默认启动环境-->\n        &lt;/activation>\n    &lt;/profile>\n    &lt;profile>\n        &lt;id>env_pro&lt;/id>\n        &lt;properties>\n            &lt;profile.active>pro&lt;/profile.active>\n        &lt;/properties>\n    &lt;/profile>\n&lt;/profiles>\n\nSpringBoot中读取maven设置值\nspring:\n\tprofiles:\n    \tactive: @profile.active@\n\n​\t\t上面的@属性名@就是读取maven中配置的属性值的语法格式。\n总结\n\n当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值\n基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效\n\nYW-4.日志​\t\t运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：\n\n编程期调试代码\n运营期记录信息\n记录日常运营重要信息（峰值流量、平均响应时长……）\n记录应用报错信息（错误堆栈）\n记录运维过程数据（扩容、宕机、报警……）\n\n​\t\t或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。\nYW-4-1.代码中使用日志工具记录日志​\t\t日志的使用格式非常固定，直接上操作步骤：\n步骤①：添加日志记录操作\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController extends BaseClass&#123;\n    private static final Logger log &#x3D; LoggerFactory.getLogger(BookController.class);\n    @GetMapping\n    public String getById()&#123;\n        log.debug(&quot;debug...&quot;);\n        log.info(&quot;info...&quot;);\n        log.warn(&quot;warn...&quot;);\n        log.error(&quot;error...&quot;);\n        return &quot;springboot is running...2&quot;;\n    &#125;\n&#125;\n\n​\t\t上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。\n步骤②：设置日志输出级别\n​\t\t日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\nTRACE：运行堆栈信息，使用率低\nDEBUG：程序员调试代码使用\nINFO：记录运维过程数据\nWARN：记录运维过程报警数据\nERROR：记录错误堆栈信息\nFATAL：灾难信息，合并计入ERROR\n\n​\t\t一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n​\t\t这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n# 设置日志级别，root表示根节点，即整体应用日志级别\nlogging:\n\tlevel:\n    \troot: debug\n\n​\t\t还可以再设置更细粒度的控制\n步骤③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别\nlogging:\n\t# 设置日志组\n    group:\n    \t# 自定义组名，设置当前组中所包含的包\n        ebank: com.itheima.controller\n    level:\n    \troot: warn\n        # 为对应组设置日志级别\n        ebank: debug\n    \t# 为对包设置日志级别\n        com.itheima.controller: debug\n\n​\t\t说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。\n总结\n\n日志用于记录开发调试与运维过程消息\n日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR\n可以通过日志组或代码包的形式进行日志显示级别的控制\n\n教你一招：优化日志对象创建代码​\t\t写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController extends BaseClass&#123;\n    private static final Logger log &#x3D; LoggerFactory.getLogger(BookController.class);\t&#x2F;&#x2F;这一句可以不写了\n&#125;\n\n​\t\t导入lombok后使用注解搞定，日志对象名为log\n@Slf4j\t\t&#x2F;&#x2F;这个注解替代了下面那一行\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController extends BaseClass&#123;\n    private static final Logger log &#x3D; LoggerFactory.getLogger(BookController.class);\t&#x2F;&#x2F;这一句可以不写了\n&#125;\n\n总结\n\n基于lombok提供的@Slf4j注解为类快速添加日志对象\n\nYW-4-2.日志输出格式控制​\t\t日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n​\t\t对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。\nlogging:\n\tpattern:\n    \tconsole: \"%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n\"\n\n总结\n\n日志输出格式设置规则\n\nYW-4-3.日志文件​\t\t日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。\n​\t\t对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。\n​\t\t记录日志到文件中格式非常简单，设置日志文件名即可。\nlogging:\n\tfile:\n    \tname: server.log\n\n​\t\t虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：\nlogging:\n\tlogback:\n    \trollingpolicy:\n        \tmax-file-size: 3KB\n            file-name-pattern: server.%d&#123;yyyy-MM-dd&#125;.%i.log\n\n​\t\t以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n总结\n\n日志记录到文件\n日志文件格式设置\n\n运维实用篇完结​\t\t运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。\n​\t\t在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。\n​\t\t看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。\nSpringBoot开发实用篇​\t\t怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。\n​\t\t运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。\n​\t\t开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：\n\n热部署\n配置高级\n测试\n数据层解决方案\n整合第三方技术\n监控\n\n​\t\t看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习\nKF-1.热部署​\t\t什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n​\t\t热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n非springboot项目热部署实现原理\n​\t\t开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n​\t\t上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串”abc”改成”cba”，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。\n​\t\t看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。\nspringboot项目热部署实现原理\n​\t\t基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n​\t下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\nKF-1-1.手动启动热部署步骤①：导入开发者工具对应的坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n    &lt;optional&gt;true&lt;&#x2F;optional&gt;\n&lt;&#x2F;dependency&gt;\n\n步骤②：构建项目，可以使用快捷键激活此功能\n\n​\t\t对应的快捷键一定要记得\n&lt;CTR&gt;L+&lt;F9&gt;\n\n​\t\t以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。\n重启与重载\n​\t\t一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\nbase类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\nrestart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n​\t\t当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n总结\n\n使用开发者工具可以为当前项目开启热部署功能\n使用构建项目操作对工程进行热部署\n\n思考\n​\t\t上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。\n​\t\t\nKF-1-2.自动启动热部署​\t\t自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署\n步骤①：设置自动构建项目\n​\t\t打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目\n\n​\t\t自动构建项目选项勾选后\n步骤②：允许在程序运行时进行自动构建\n​\t\t使用快捷键【Ctrl】+【Alt】+【Shit】+【&#x2F;】打开维护面板，选择第1项【Registry…】\n\n​\t\t在选项中搜索comple，然后勾选对应项即可\n\n\n​\t\t这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。\n关注：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n总结\n\n自动热部署要开启自动构建项目\n自动热部署要开启在程序运行时自动构建项目\n\n思考\n​\t\t现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。\nKF-1-3.参与热部署监控的文件范围配置​\t\t通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n&#x2F;META-INF&#x2F;maven\n&#x2F;META-INF&#x2F;resources\n&#x2F;resources\n&#x2F;static\n&#x2F;public\n&#x2F;templates\n\n​\t\t以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\nspring:\n  devtools:\n    restart:\n      # 设置不参与热部署的文件或文件夹\n      exclude: static/**,public/**,config/application.yml\n\n总结\n\n通过配置可以修改不参与热部署的文件或目录\n\n思考\n​\t\t热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。\nKF-1-4.关闭热部署​\t\t线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\nspring:\n  devtools:\n    restart:\n      enabled: false\n\n​\t\t如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n@SpringBootApplication\npublic class SSMPApplication &#123;\n    public static void main(String[] args) &#123;\n        System.setProperty(&quot;spring.devtools.restart.enabled&quot;,&quot;false&quot;);\n        SpringApplication.run(SSMPApplication.class);\n    &#125;\n&#125;\n\n​\t\t其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。\n总结\n\n通过配置可以关闭热部署功能降低线上程序的资源消耗\n\nKF-2.配置高级​\t\t进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。\nKF-2-1.@ConfigurationProperties​\t\t在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n​\t\t然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n@Component\n@Data\npublic class ServerConfig &#123;\n    private String ipAddress;\n    private int port;\n    private long timeout;\n&#125;\n\n​\t\t使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上\n@Component\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;servers&quot;)\npublic class ServerConfig &#123;\n    private String ipAddress;\n    private int port;\n    private long timeout;\n&#125;\n\n​\t\t这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n​\t\t使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。\n步骤①：使用@Bean注解定义第三方bean\n@Bean\npublic DruidDataSource datasource()&#123;\n    DruidDataSource ds &#x3D; new DruidDataSource();\n    return ds;\n&#125;\n\n步骤②：在yml中定义要绑定的属性，注意datasource此时全小写\ndatasource:\n  driverClassName: com.mysql.jdbc.Driver\n\n步骤③：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n@Bean\n@ConfigurationProperties(prefix &#x3D; &quot;datasource&quot;)\npublic DruidDataSource datasource()&#123;\n    DruidDataSource ds &#x3D; new DruidDataSource();\n    return ds;\n&#125;\n\n​\t\t操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n​\t\t做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？\n步骤①：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类\n@SpringBootApplication\n@EnableConfigurationProperties(ServerConfig.class)\npublic class Springboot13ConfigurationApplication &#123;\n&#125;\n\n步骤②：在对应的类上直接使用@ConfigurationProperties进行属性绑定\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;servers&quot;)\npublic class ServerConfig &#123;\n    private String ipAddress;\n    private int port;\n    private long timeout;\n&#125;\n\n​\t\t有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。\n​\t\t最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息\n\n​\t\t出现这个提示后只需要添加一个坐标此提醒就消失了\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n总结\n\n使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性\n当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明\n\nKF-2-2.宽松绑定&#x2F;松散绑定​\t\t在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：\ndataSource:\n  driverClassName: com.mysql.jdbc.Driver\n\n​\t\t此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：\n@Bean\n@ConfigurationProperties(prefix &#x3D; &quot;dataSource&quot;)\npublic DruidDataSource datasource()&#123;\n    DruidDataSource ds &#x3D; new DruidDataSource();\n    return ds;\n&#125;\n\n​\t\t此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的\nConfiguration property name &#39;dataSource&#39; is not valid:\n\n    Invalid characters: &#39;S&#39;\n    Bean: datasource\n    Reason: Canonical names should be kebab-case (&#39;-&#39; separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify &#39;dataSource&#39; so that it conforms to the canonical names requirements.\n\n​\t\t为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n​\t\t什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n​\t\t在ServerConfig中的ipAddress属性名\n@Component\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;servers&quot;)\npublic class ServerConfig &#123;\n    private String ipAddress;\n&#125;\n\n​\t\t可以与下面的配置属性名规则全兼容\nservers:\n  ipAddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  IP_ADDRESS: 192.168.0.2      # 常量模式\n\n​\t\t也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n​\t\t到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\nConfiguration property name &#39;dataSource&#39; is not valid:\n\n    Invalid characters: &#39;S&#39;\n    Bean: datasource\n    Reason: Canonical names should be kebab-case (&#39;-&#39; separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify &#39;dataSource&#39; so that it conforms to the canonical names requirements.\n\n​\t\t其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。\n​\t\t最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。\n总结\n\n@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n@Value注解不支持松散绑定规则\n绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\nKF-2-3.常用计量单位绑定​\t\t在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n​\t\t但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？\n​\t\t除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize\n@Component\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;servers&quot;)\npublic class ServerConfig &#123;\n    @DurationUnit(ChronoUnit.HOURS)\n    private Duration serverTimeOut;\n    @DataSizeUnit(DataUnit.MEGABYTES)\n    private DataSize dataSize;\n&#125;\n\n\nDuration：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）\nDataSize：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）\n​\t\t使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\nDruation常用单位如下：\n\n\nDataSize常用单位如下：\n\n\n\n\nKF-2-4.校验​\t\t目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误。\t\tSpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤\n步骤①：开启校验框架\n&lt;!--1.导入JSR303规范-->\n&lt;dependency>\n    &lt;groupId>javax.validation&lt;/groupId>\n    &lt;artifactId>validation-api&lt;/artifactId>\n&lt;/dependency>\n&lt;!--使用hibernate框架提供的校验器做实现-->\n&lt;dependency>\n    &lt;groupId>org.hibernate.validator&lt;/groupId>\n    &lt;artifactId>hibernate-validator&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：在需要开启校验功能的类上使用注解@Validated开启校验功能\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\n//开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig &#123;\n&#125;\n\n步骤③：对具体的字段设置校验规则\n@Component\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;servers&quot;)\n&#x2F;&#x2F;开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig &#123;\n    &#x2F;&#x2F;设置具体的规则\n    @Max(value &#x3D; 8888,message &#x3D; &quot;最大值不能超过8888&quot;)\n    @Min(value &#x3D; 202,message &#x3D; &quot;最小值不能低于202&quot;)\n    private int port;\n&#125;\n\n​\t\t通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。\n总结\n\n开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式\n\nKF-2-5.数据类型转换​\t\t有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。\n​\t\t先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。\njava.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)\n\n​\t\t其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n    username: root\n    password: 0127\n\n​\t\t这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n​\t\t之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，支持二进制，八进制，十六进制\n\n\n​\t\t这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。\n​\t\t这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n总结\n\nyaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注\n\nKF-3.测试​\t\t说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。\nKF-3-1.加载测试专用属性​\t\t测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置\nenv:\n  maxMemory: 32GB\n  minMemory: 16GB\n\n​\t\t但是你现在想测试对应的兼容性，需要测试如下配置\nenv:\n  maxMemory: 16GB\n  minMemory: 8GB\n\n​\t\t这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n临时属性\n​\t\tspringboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：\n&#x2F;&#x2F;properties属性可以为当前测试用例添加临时的属性配置\n@SpringBootTest(properties &#x3D; &#123;&quot;test.prop&#x3D;testValue1&quot;&#125;)\npublic class PropertiesAndArgsTest &#123;\n\n    @Value(&quot;$&#123;test.prop&#125;&quot;)\n    private String msg;\n    \n    @Test\n    void testProperties()&#123;\n        System.out.println(msg);\n    &#125;\n&#125;\n\n​\t\t使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n临时参数\n​\t\t除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。\n&#x2F;&#x2F;args属性可以为当前测试用例添加临时的命令行参数\n@SpringBootTest(args&#x3D;&#123;&quot;--test.prop&#x3D;testValue2&quot;&#125;)\npublic class PropertiesAndArgsTest &#123;\n    \n    @Value(&quot;$&#123;test.prop&#125;&quot;)\n    private String msg;\n    \n    @Test\n    void testProperties()&#123;\n        System.out.println(msg);\n    &#125;\n&#125;\n\n​\t\t使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n​\t\t说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？\n\n\n​\t\t在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。\n​\t\t到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。\n总结\n\n加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n思考\n​\t\t应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。\nKF-3-2.加载测试专用配置​\t\t上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。\n​\t\t学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n步骤①：在测试包test中创建专用的测试环境配置类\n@Configuration\npublic class MsgConfig &#123;\n    @Bean\n    public String msg()&#123;\n        return \"bean msg\";\n    &#125;\n&#125;\n\n​\t\t上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据\n步骤②：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现\n@SpringBootTest\n@Import(&#123;MsgConfig.class&#125;)\npublic class ConfigurationTest &#123;\n\n    @Autowired\n    private String msg;\n\n    @Test\n    void testConfiguration()&#123;\n        System.out.println(msg);\n    &#125;\n&#125;\n\n​\t\t到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n总结\n\n定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n思考\n​\t\t当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。\nKF-3-3.Web环境模拟测试​\t\t在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个\n测试类中启动web环境\n​\t\t每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n@SpringBootTest(webEnvironment &#x3D; SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class WebTest &#123;\t\n&#125;\n\n​\t\t测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n\n\nMOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置\nDEFINED_PORT：使用自定义的端口作为web服务器端口\nRANDOM_PORT：使用随机端口作为web服务器端口\nNONE：不启动web环境\n\n​\t\t通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。\n​\t\t测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。\n测试类中发送请求\n​\t\t对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：\n步骤①：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest &#123;\n&#125;\n\n步骤②：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest &#123;\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) &#123;\n    &#125;\n&#125;\n\n步骤③：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest &#123;\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) throws Exception &#123;\n        //http://localhost:8080/books\n        //创建虚拟请求，当前访问/books\n        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n        //执行对应的请求\n        mvc.perform(builder);\n    &#125;\n&#125;\n\n​\t\t执行测试程序，现在就可以正常的发送&#x2F;books对应的请求了，注意访问路径不要写http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。\n总结\n\n在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试\n为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程\n\n思考\n​\t\t目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。\nweb环境请求结果比对\n​\t\t上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：\n\n响应状态匹配\n@Test\nvoid testStatus(@Autowired MockMvc mvc) throws Exception &#123;\n    MockHttpServletRequestBuilder builder &#x3D; MockMvcRequestBuilders.get(&quot;&#x2F;books&quot;);\n    ResultActions action &#x3D; mvc.perform(builder);\n    &#x2F;&#x2F;设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    &#x2F;&#x2F;定义本次调用的预期值\n    StatusResultMatchers status &#x3D; MockMvcResultMatchers.status();\n    &#x2F;&#x2F;预计本次调用时成功的：状态200\n    ResultMatcher ok &#x3D; status.isOk();\n    &#x2F;&#x2F;添加预计值到本次调用过程中进行匹配\n    action.andExpect(ok);\n&#125;\n\n响应体匹配（非json数据格式）\n@Test\nvoid testBody(@Autowired MockMvc mvc) throws Exception &#123;\n    MockHttpServletRequestBuilder builder &#x3D; MockMvcRequestBuilders.get(&quot;&#x2F;books&quot;);\n    ResultActions action &#x3D; mvc.perform(builder);\n    &#x2F;&#x2F;设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    &#x2F;&#x2F;定义本次调用的预期值\n    ContentResultMatchers content &#x3D; MockMvcResultMatchers.content();\n    ResultMatcher result &#x3D; content.string(&quot;springboot2&quot;);\n    &#x2F;&#x2F;添加预计值到本次调用过程中进行匹配\n    action.andExpect(result);\n&#125;\n\n响应体匹配（json数据格式，开发中的主流使用方式）\n@Test\nvoid testJson(@Autowired MockMvc mvc) throws Exception &#123;\n    MockHttpServletRequestBuilder builder &#x3D; MockMvcRequestBuilders.get(&quot;&#x2F;books&quot;);\n    ResultActions action &#x3D; mvc.perform(builder);\n    &#x2F;&#x2F;设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    &#x2F;&#x2F;定义本次调用的预期值\n    ContentResultMatchers content &#x3D; MockMvcResultMatchers.content();\n    ResultMatcher result &#x3D; content.json(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;springboot2\\&quot;,\\&quot;type\\&quot;:\\&quot;springboot\\&quot;&#125;&quot;);\n    &#x2F;&#x2F;添加预计值到本次调用过程中进行匹配\n    action.andExpect(result);\n&#125;\n\n响应头信息匹配\n@Test\nvoid testContentType(@Autowired MockMvc mvc) throws Exception &#123;\n    MockHttpServletRequestBuilder builder &#x3D; MockMvcRequestBuilders.get(&quot;&#x2F;books&quot;);\n    ResultActions action &#x3D; mvc.perform(builder);\n    &#x2F;&#x2F;设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    &#x2F;&#x2F;定义本次调用的预期值\n    HeaderResultMatchers header &#x3D; MockMvcResultMatchers.header();\n    ResultMatcher contentType &#x3D; header.string(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);\n    &#x2F;&#x2F;添加预计值到本次调用过程中进行匹配\n    action.andExpect(contentType);\n&#125;\n\n​\t\t基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n@Test\nvoid testGetById(@Autowired MockMvc mvc) throws Exception &#123;\n    MockHttpServletRequestBuilder builder &#x3D; MockMvcRequestBuilders.get(&quot;&#x2F;books&quot;);\n    ResultActions action &#x3D; mvc.perform(builder);\n\n    StatusResultMatchers status &#x3D; MockMvcResultMatchers.status();\n    ResultMatcher ok &#x3D; status.isOk();\n    action.andExpect(ok);\n\n    HeaderResultMatchers header &#x3D; MockMvcResultMatchers.header();\n    ResultMatcher contentType &#x3D; header.string(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);\n    action.andExpect(contentType);\n\n    ContentResultMatchers content &#x3D; MockMvcResultMatchers.content();\n    ResultMatcher result &#x3D; content.json(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;springboot\\&quot;,\\&quot;type\\&quot;:\\&quot;springboot\\&quot;&#125;&quot;);\n    action.andExpect(result);\n&#125;\n\n总结\n\nweb虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\nKF-3-4.数据层测试回滚​\t\t当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n​\t\tspringboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n@SpringBootTest\n@Transactional\n@Rollback(true)\npublic class DaoTest &#123;\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    void testSave()&#123;\n        Book book &#x3D; new Book();\n        book.setName(&quot;springboot3&quot;);\n        book.setType(&quot;springboot3&quot;);\n        book.setDescription(&quot;springboot3&quot;);\n\n        bookService.save(book);\n    &#125;\n&#125;\n\n​\t\t如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务，是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。\n总结\n\n在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务\n通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用\n\n思考\n​\t\t当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。\nKF-3-5.测试用例数据设定​\t\t对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\ntestcase:\n  book:\n    id: $&#123;random.int&#125;\n    id2: $&#123;random.int(10)&#125;\n    type: $&#123;random.int!5,10!&#125;\n    name: $&#123;random.value&#125;\n    uuid: $&#123;random.uuid&#125;\n    publishTime: $&#123;random.long&#125;\n\n​\t\t当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可\n@Component\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;testcase.book&quot;)\npublic class BookCase &#123;\n    private int id;\n    private int id2;\n    private int type;\n    private String name;\n    private String uuid;\n    private long publishTime;\n&#125;\n\n​\t\t对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：\n\n\n\n${random.int}表示随机整数\n${random.int(10)}表示10以内的随机数\n${random.int(10,20)}表示10到20的随机数\n其中()可以是任意字符，例如[]，!!均可\n\n总结\n\n使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\nKF-4.数据层解决方案​\t\t开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是SQL解决方案相关的内容，除此之外，数据的来源还可以是非SQL技术相关的数据操作，因此第二部分围绕着NOSQL解决方案讲解。至于什么是NOSQL解决方案，讲到了再说吧。下面就从SQL解决方案说起。\nKF-4-1.SQL​\t\t回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：\n\n数据源技术：Druid\n持久化技术：MyBatisPlus\n数据库技术：MySQL\n\n​\t\t下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。\n数据源技术​\t\t目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：\nINFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource\nINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited\n\n​\t\t如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n​\t\t虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。\n​\t\t数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。\n​\t\tspringboot提供了3款内嵌数据源技术，分别如下：\n\nHikariCP\nTomcat提供DataSource\nCommons DBCP\n\n​\t\t第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。\n​\t\t第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。\n​\t\t第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。\n​\t\tspringboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：\nspring:\n  datasource:\n    druid:\t\n   \t  url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n\n​\t\t换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: root\n\n​\t\t 当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n\n​\t\t这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n      maximum-pool-size: 50\n\n​\t\t如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n总结\n\nspringboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP\n\n持久化技术​\t\t说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。\n​\t\t这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：\n步骤①：导入jdbc对应的坐标，记得是starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId>\n&lt;/dependency\n\n步骤②：自动装配JdbcTemplate对象\n@SpringBootTest\nclass Springboot15SqlApplicationTests &#123;\n    @Test\n    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;\n    &#125;\n&#125;\n\n步骤③：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;\n    String sql = \"select * from tbl_book\";\n    List&lt;Map&lt;String, Object>> maps = jdbcTemplate.queryForList(sql);\n    System.out.println(maps);\n&#125;\n\n步骤④：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;\n\n    String sql = \"select * from tbl_book\";\n    RowMapper&lt;Book> rm = new RowMapper&lt;Book>() &#123;\n        @Override\n        public Book mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n            Book temp = new Book();\n            temp.setId(rs.getInt(\"id\"));\n            temp.setName(rs.getString(\"name\"));\n            temp.setType(rs.getString(\"type\"));\n            temp.setDescription(rs.getString(\"description\"));\n            return temp;\n        &#125;\n    &#125;;\n    List&lt;Book> list = jdbcTemplate.query(sql, rm);\n    System.out.println(list);\n&#125;\n\n步骤⑤：使用JdbcTemplate实现增删改操作\n@Test\nvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate)&#123;\n    String sql = \"insert into tbl_book values(3,'springboot1','springboot2','springboot3')\";\n    jdbcTemplate.update(sql);\n&#125;\n\n​\t\t如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\nspring:\n  jdbc:\n    template:\n      query-timeout: -1   # 查询超时时间\n      max-rows: 500       # 最大行数\n      fetch-size: -1      # 缓存行数\n\n总结\n\nSpringBoot内置JdbcTemplate持久化解决方案\n使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标\n\n数据库技术​\t\t截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。\n​\t\tspringboot提供了3款内置的数据库，分别是\n\nH2\nHSQL\nDerby\n\n​\t\t以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。\n​\t\t我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。\n​\t\t下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n步骤①：导入H2数据库对应的坐标，一共2个\n&lt;dependency>\n    &lt;groupId>com.h2database&lt;/groupId>\n    &lt;artifactId>h2&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：将工程设置为web工程，启动工程时启动H2数据库\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\n步骤③：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\nspring:\n  h2:\n    console:\n      enabled: true\n      path: /h2\n\n​\t\tweb端访问路径&#x2F;h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问&#x2F;h2路径就可以正常访问了\ndatasource:\n  url: jdbc:h2:~/test\n  hikari:\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: 123456\n\n步骤④：使用JdbcTemplate或MyBatisPlus技术操作数据库\n（略）\n​\t\t其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。\n总结\n\nH2内嵌式数据库启动方式，添加坐标，添加配置\nH2数据库线上运行时请务必关闭\n\n​\t\t到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。\n\n数据源技术：Druid、Hikari、tomcat DataSource、DBCP\n持久化技术：MyBatisPlus、MyBatis、JdbcTemplate\n数据库技术：MySQL、H2、HSQL、Derby\n\n​\t\t现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。\nKF-4-2.NoSQL​\t\tSQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。\n​\t\t因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。\nSpringBoot整合Redis​\t\tRedis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。\n​\t\tRedis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合\n安装​\t\twindows版安装包下载地址：https://github.com/tporadowski/redis/releases\n​\t\t下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。\n​\t\t啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。\n​\t\t安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。\n\n\n启动服务器\nredis-server.exe redis.windows.conf\n\n​\t\t初学者无需调整服务器对外服务端口，默认6379。\n启动客户端\nredis-cli.exe\n\n​\t\t如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。\n基本操作​\t\t服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。\t\t\n​\t\t放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可\nset name itheima\nset age 12\n\n​\t\t从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)\nget name\nget age\n\n​\t\t以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：\nhset a a1 aa1\t\t#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1\nhset a a2 aa2\n\n​\t\t获取hash结构中的数据命令如下\nhget a a1\t\t\t#得到aa1\nhget a a2\t\t\t#得到aa2\n\n​\t\t有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。\n整合​\t\t在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。\n​\t\t第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化\n​\t\t第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题\n​\t\t第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同\n​\t\t按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。\n​\t\t下面就开始springboot整合redis，操作步骤如下：\n步骤①：导入springboot整合redis的starter坐标\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n&lt;/dependency>\n\n​\t\t上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中\n\n\n步骤②：进行基础配置\nspring:\n  redis:\n    host: localhost\n    port: 6379\n\n​\t\t操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。\n步骤③：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate\n@SpringBootTest\nclass Springboot16RedisApplicationTests &#123;\n    @Autowired\n    private RedisTemplate redisTemplate;\n    @Test\n    void set() &#123;\n        ValueOperations ops = redisTemplate.opsForValue();\n        ops.set(\"age\",41);\n    &#125;\n    @Test\n    void get() &#123;\n        ValueOperations ops = redisTemplate.opsForValue();\n        Object age = ops.get(\"name\");\n        System.out.println(age);\n    &#125;\n    @Test\n    void hset() &#123;\n        HashOperations ops = redisTemplate.opsForHash();\n        ops.put(\"info\",\"b\",\"bb\");\n    &#125;\n    @Test\n    void hget() &#123;\n        HashOperations ops = redisTemplate.opsForHash();\n        Object val = ops.get(\"info\", \"b\");\n        System.out.println(val);\n    &#125;\n&#125;\n\n\n​\t\t在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：\n\n\n总结\n\nspringboot整合redis步骤\n导入springboot整合redis的starter坐标\n进行基础配置\n使用springboot整合redis的专用客户端接口RedisTemplate操作\n\n\n\nStringRedisTemplate\n​\t\t由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。\n@SpringBootTest\npublic class StringRedisTemplateTest &#123;\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Test\n    void get()&#123;\n        ValueOperations&lt;String, String&gt; ops &#x3D; stringRedisTemplate.opsForValue();\n        String name &#x3D; ops.get(&quot;name&quot;);\n        System.out.println(name);\n    &#125;\n&#125;\n\n\n\nredis客户端选择\n     springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n\n步骤①：导入jedis坐标\n&lt;dependency>\n    &lt;groupId>redis.clients&lt;/groupId>\n    &lt;artifactId>jedis&lt;/artifactId>\n&lt;/dependency>\n\n​\t\tjedis坐标受springboot管理，无需提供版本号\n步骤②：配置客户端技术类型，设置为jedis\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n\n步骤③：根据需要设置对应的配置\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n    lettuce:\n      pool:\n        max-active: 16\n    jedis:\n      pool:\n        max-active: 16\n\nlettcus与jedis区别\n\njedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\nlettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n总结\n\nspringboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis\n如果需要切换redis客户端实现技术，可以通过配置的形式进行\n\nSpringBoot整合MongoDB​\t\t使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。\n​\t\tMongoDB是一个开源、高性能、无模式的文档型数据库，它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。\n​\t\t上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：\n\n淘宝用户数据\n存储位置：数据库\n特征：永久性存储，修改频度极低\n\n\n游戏装备数据、游戏道具数据\n存储位置：数据库、Mongodb\n特征：永久性存储与临时存储相结合、修改频度较高\n\n\n直播数据、打赏数据、粉丝数据\n存储位置：数据库、Mongodb\n特征：永久性存储与临时存储相结合，修改频度极高\n\n\n物联网数据\n存储位置：Mongodb\n特征：临时存储，修改频度飞速\n\n\n\n​\t\t快速了解一下MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合\n安装​\t\twindows版安装包下载地址：https://www.mongodb.com/try/download\n​\t\t下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。\n​\t\t解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令\n\n​\t\tmongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下\n\n​\t\t如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。\n\n\n​\t\t根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。\nregsvr32 vcruntime140_1.dll\n\n启动服务器\nmongod --dbpath&#x3D;..\\data\\db\n\n​\t\t启动服务器时需要指定数据存储位置，通过参数–dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。\n启动客户端\nmongo --host&#x3D;127.0.0.1 --port&#x3D;27017\n\n基本操作​\t\tMongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。\n​\t\t同类型的软件较多，本次安装的软件时Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用。\n\n\n​\t\t打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect…】\n\n​\t\t进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置\n\n\n​\t\t如果输入设置值即可连接（默认不修改即可连接本机27017端口）\n\n​\t\t连接成功后在命令输入区域输入命令即可操作MongoDB。\n​\t\t创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可\n​\t\t创建集合：在Collections上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用\n​\t\t新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）\t\ndb.集合名称.insert&#x2F;save&#x2F;insertOne(文档)\n\n​\t\t删除文档：\ndb.集合名称.remove(条件)\n\n​\t\t修改文档：\ndb.集合名称.update(条件，&#123;操作种类:&#123;文档&#125;&#125;)\n\n​\t\t查询文档：\n基础查询\n查询全部：\t\t   db.集合.find();\n查第一条：\t\t   db.集合.findOne()\n查询指定数量文档：\tdb.集合.find().limit(10)\t\t\t\t\t&#x2F;&#x2F;查10条文档\n跳过指定数量文档：\tdb.集合.find().skip(20)\t\t\t\t\t&#x2F;&#x2F;跳过20条文档\n统计：\t\t\t  \tdb.集合.count()\n排序：\t\t\t\tdb.集合.sort(&#123;age:1&#125;)\t\t\t\t\t\t&#x2F;&#x2F;按age升序排序\n投影：\t\t\t\tdb.集合名称.find(条件,&#123;name:1,age:1&#125;)\t\t &#x2F;&#x2F;仅保留name与age域\n\n条件查询\n基本格式：\t\t\tdb.集合.find(&#123;条件&#125;)\n模糊查询：\t\t\tdb.集合.find(&#123;域名:&#x2F;正则表达式&#x2F;&#125;)\t\t  &#x2F;&#x2F;等同SQL中的like，比like强大，可以执行正则所有规则\n条件比较运算：\t\t   db.集合.find(&#123;域名:&#123;$gt:值&#125;&#125;)\t\t\t\t&#x2F;&#x2F;等同SQL中的数值比较操作，例如：name&gt;18\n包含查询：\t\t\tdb.集合.find(&#123;域名:&#123;$in:[值1，值2]&#125;&#125;)\t\t&#x2F;&#x2F;等同于SQL中的in\n条件连接查询：\t\t   db.集合.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)\t   &#x2F;&#x2F;等同于SQL中的and、or\n\n​\t\t有关MongoDB的基础操作就普及到这里，需要全面掌握MongoDB技术，请参看相关教程学习。\n整合​\t\t使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。\n​\t\t第一，先导入对应技术的整合starter坐标\n​\t\t第二，配置必要信息\n​\t\t第三，使用提供的API操作即可\n​\t\t下面就开始springboot整合MongoDB，操作步骤如下：\n步骤①：导入springboot整合MongoDB的starter坐标\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-mongodb&lt;/artifactId>\n&lt;/dependency>\n\n​\t\t上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中\n\n\n步骤②：进行基础配置\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost/itheima\n\n​\t\t操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。\n步骤③：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作\n@SpringBootTest\nclass Springboot17MongodbApplicationTests &#123;\n    @Autowired\n    private MongoTemplate mongoTemplate;\n    @Test\n    void contextLoads() &#123;\n        Book book = new Book();\n        book.setId(2);\n        book.setName(\"springboot2\");\n        book.setType(\"springboot2\");\n        book.setDescription(\"springboot2\");\n        mongoTemplate.save(book);\n    &#125;\n    @Test\n    void find()&#123;\n        List&lt;Book> all = mongoTemplate.findAll(Book.class);\n        System.out.println(all);\n    &#125;\n&#125;\n\n​\t\t整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉，有关springboot整合MongoDB我们就讲到这里。有兴趣可以继续学习MongoDB的操作，然后再来这里通过编程的形式操作MongoDB。\n总结\n\nspringboot整合MongoDB步骤\n导入springboot整合MongoDB的starter坐标\n进行基础配置\n使用springboot整合MongoDB的专用客户端接口MongoTemplate操作\n\n\n\nSpringBoot整合ES​\t\tNoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。\n​\t\tES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。\n​\t\t那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。\n​\t\t要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：\n\n将被查询的字段的数据全部文本信息进行查分，分成若干个词\n\n例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。\n\n\n将分词得到的结果存储起来，对应每条数据的id\n\n例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1\n\n例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2\n\n此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中\n\n\n\n分词结果关键字\n对应id\n\n\n\n中华\n1\n\n\n人民\n1,2\n\n\n共和国\n1\n\n\n代表\n2\n\n\n大会\n2\n\n\n\n\n\n当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。\n\n\n​\t\t上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做倒排索引。\n​\t\t通过上述内容的学习，发现使用ES其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下ES的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。\n安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;www.elastic.co/cn/downloads/elasticsearch\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\nbin目录：包含所有的可执行命令\nconfig目录：包含ES服务器使用的配置文件\njdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题\nlib目录：包含ES运行的依赖jar文件\nlogs目录：包含ES运行后产生的所有日志文件\nmodules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包\nplugins目录：包含ES软件安装的插件，默认为空\n\n启动服务器\nelasticsearch.bat\n\n​\t\t双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问http://localhost:9200看到如下信息视为ES服务器正常启动\n&#123;\n  &quot;name&quot; : &quot;CZBK-**********&quot;,\n  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,\n  &quot;cluster_uuid&quot; : &quot;j137DSswTPG8U4Yb-0T1Mg&quot;,\n  &quot;version&quot; : &#123;\n    &quot;number&quot; : &quot;7.16.2&quot;,\n    &quot;build_flavor&quot; : &quot;default&quot;,\n    &quot;build_type&quot; : &quot;zip&quot;,\n    &quot;build_hash&quot; : &quot;2b937c44140b6559905130a8650c64dbd0879cfb&quot;,\n    &quot;build_date&quot; : &quot;2021-12-18T19:42:46.604893745Z&quot;,\n    &quot;build_snapshot&quot; : false,\n    &quot;lucene_version&quot; : &quot;8.10.1&quot;,\n    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,\n    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;\n  &#125;,\n  &quot;tagline&quot; : &quot;You Know, for Search&quot;\n&#125;\n\n基本操作​\t\tES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。\n​\t\t要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。\n\n创建索引，books是索引名称，下同\nPUT请求\t\thttp:&#x2F;&#x2F;localhost:9200&#x2F;books\n\n发送请求后，看到如下信息即索引创建成功\n&#123;\n    \"acknowledged\": true,\n    \"shards_acknowledged\": true,\n    \"index\": \"books\"\n&#125;\n\n重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因\n&#123;\n    \"error\": &#123;\n        \"root_cause\": [\n            &#123;\n                \"type\": \"resource_already_exists_exception\",\n                \"reason\": \"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists\",\n                \"index_uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n                \"index\": \"books\"\n            &#125;\n        ],\n        \"type\": \"resource_already_exists_exception\",\n        \"reason\": \"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists\",\t# books索引已经存在\n        \"index_uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n        \"index\": \"book\"\n    &#125;,\n    \"status\": 400\n&#125;\n\n查询索引\nGET请求\t\thttp:&#x2F;&#x2F;localhost:9200&#x2F;books\n\n查询索引得到索引相关信息，如下\n&#123;\n    \"book\": &#123;\n        \"aliases\": &#123;&#125;,\n        \"mappings\": &#123;&#125;,\n        \"settings\": &#123;\n            \"index\": &#123;\n                \"routing\": &#123;\n                    \"allocation\": &#123;\n                        \"include\": &#123;\n                            \"_tier_preference\": \"data_content\"\n                        &#125;\n                    &#125;\n                &#125;,\n                \"number_of_shards\": \"1\",\n                \"provided_name\": \"books\",\n                \"creation_date\": \"1645768584849\",\n                \"number_of_replicas\": \"1\",\n                \"uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n                \"version\": &#123;\n                    \"created\": \"7160299\"\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下\n&#123;\n    \"error\": &#123;\n        \"root_cause\": [\n            &#123;\n                \"type\": \"index_not_found_exception\",\n                \"reason\": \"no such index [book]\",\n                \"resource.type\": \"index_or_alias\",\n                \"resource.id\": \"book\",\n                \"index_uuid\": \"_na_\",\n                \"index\": \"book\"\n            &#125;\n        ],\n        \"type\": \"index_not_found_exception\",\n        \"reason\": \"no such index [book]\",\t\t# 没有book索引\n        \"resource.type\": \"index_or_alias\",\n        \"resource.id\": \"book\",\n        \"index_uuid\": \"_na_\",\n        \"index\": \"book\"\n    &#125;,\n    \"status\": 404\n&#125;\n\n删除索引\nDELETE请求\thttp:&#x2F;&#x2F;localhost:9200&#x2F;books\n\n删除所有后，给出删除结果\n&#123;\n    \"acknowledged\": true\n&#125;\n\n如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因\n&#123;\n    &quot;error&quot;: &#123;\n        &quot;root_cause&quot;: [\n            &#123;\n                &quot;type&quot;: &quot;index_not_found_exception&quot;,\n                &quot;reason&quot;: &quot;no such index [books]&quot;,\n                &quot;resource.type&quot;: &quot;index_or_alias&quot;,\n                &quot;resource.id&quot;: &quot;book&quot;,\n                &quot;index_uuid&quot;: &quot;_na_&quot;,\n                &quot;index&quot;: &quot;book&quot;\n            &#125;\n        ],\n        &quot;type&quot;: &quot;index_not_found_exception&quot;,\n        &quot;reason&quot;: &quot;no such index [books]&quot;,\t\t# 没有books索引\n        &quot;resource.type&quot;: &quot;index_or_alias&quot;,\n        &quot;resource.id&quot;: &quot;book&quot;,\n        &quot;index_uuid&quot;: &quot;_na_&quot;,\n        &quot;index&quot;: &quot;book&quot;\n    &#125;,\n    &quot;status&quot;: 404\n&#125;\n\n创建索引并指定分词器\n​\t\t前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n​\t\t分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：\nPUT请求\t\thttp://localhost:9200/books\n\n请求参数如下（注意是json格式的参数）\n&#123;\n    \"mappings\":&#123;\t\t\t\t\t\t\t#定义mappings属性，替换创建索引时对应的mappings属性\t\t\n        \"properties\":&#123;\t\t\t\t\t\t#定义索引中包含的属性设置\n            \"id\":&#123;\t\t\t\t\t\t\t#设置索引中包含id属性\n                \"type\":\"keyword\"\t\t\t#当前属性可以被直接搜索\n            &#125;,\n            \"name\":&#123;\t\t\t\t\t\t#设置索引中包含name属性\n                \"type\":\"text\",              #当前属性是文本信息，参与分词  \n                \"analyzer\":\"ik_max_word\",   #使用IK分词器进行分词             \n                \"copy_to\":\"all\"\t\t\t\t#分词结果拷贝到all属性中\n            &#125;,\n            \"type\":&#123;\n                \"type\":\"keyword\"\n            &#125;,\n            \"description\":&#123;\n                \"type\":\"text\",\t                \n                \"analyzer\":\"ik_max_word\",                \n                \"copy_to\":\"all\"\n            &#125;,\n            \"all\":&#123;\t\t\t\t\t\t\t#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询\n                \"type\":\"text\",\t                \n                \"analyzer\":\"ik_max_word\"\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n​\t\t创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中\n&#123;\n    \"books\": &#123;\n        \"aliases\": &#123;&#125;,\n        \"mappings\": &#123;\t\t\t\t\t\t#mappings属性已经被替换\n            \"properties\": &#123;\n                \"all\": &#123;\n                    \"type\": \"text\",\n                    \"analyzer\": \"ik_max_word\"\n                &#125;,\n                \"description\": &#123;\n                    \"type\": \"text\",\n                    \"copy_to\": [\n                        \"all\"\n                    ],\n                    \"analyzer\": \"ik_max_word\"\n                &#125;,\n                \"id\": &#123;\n                    \"type\": \"keyword\"\n                &#125;,\n                \"name\": &#123;\n                    \"type\": \"text\",\n                    \"copy_to\": [\n                        \"all\"\n                    ],\n                    \"analyzer\": \"ik_max_word\"\n                &#125;,\n                \"type\": &#123;\n                    \"type\": \"keyword\"\n                &#125;\n            &#125;\n        &#125;,\n        \"settings\": &#123;\n            \"index\": &#123;\n                \"routing\": &#123;\n                    \"allocation\": &#123;\n                        \"include\": &#123;\n                            \"_tier_preference\": \"data_content\"\n                        &#125;\n                    &#125;\n                &#125;,\n                \"number_of_shards\": \"1\",\n                \"provided_name\": \"books\",\n                \"creation_date\": \"1645769809521\",\n                \"number_of_replicas\": \"1\",\n                \"uuid\": \"DohYKvr_SZO4KRGmbZYmTQ\",\n                \"version\": &#123;\n                    \"created\": \"7160299\"\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。\n\n添加文档，有三种方式\nPOST请求\thttp://localhost:9200/books/_doc\t\t#使用系统生成id\nPOST请求\thttp://localhost:9200/books/_create/1\t#使用指定id\nPOST请求\thttp://localhost:9200/books/_doc/1\t\t#使用指定id，不存在创建，存在更新（版本递增）\n\n文档通过请求参数传递，数据格式json\n&#123;\n    \"name\":\"springboot\",\n    \"type\":\"springboot\",\n    \"description\":\"springboot\"\n&#125;  \n\n查询文档\nGET请求\thttp://localhost:9200/books/_doc/1\t\t #查询单个文档 \t\t\nGET请求\thttp://localhost:9200/books/_search\t\t #查询全部文档\n\n条件查询\nGET请求\thttp://localhost:9200/books/_search?q=name:springboot\t# q=查询属性名:查询属性值\n\n删除文档\nDELETE请求\thttp://localhost:9200/books/_doc/1\n\n修改文档（全量更新）\nPUT请求\thttp://localhost:9200/books/_doc/1\n\n文档通过请求参数传递，数据格式json\n&#123;\n    \"name\":\"springboot\",\n    \"type\":\"springboot\",\n    \"description\":\"springboot\"\n&#125;\n\n修改文档（部分更新）\nPOST请求\thttp://localhost:9200/books/_update/1\n\n文档通过请求参数传递，数据格式json\n&#123;\t\t\t\n    \"doc\":&#123;\t\t\t\t\t\t#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新\n        \"name\":\"springboot\"\t\t#仅更新提供的属性值，未提供的属性值不参与更新操作\n    &#125;\n&#125;\n\n整合​\t\t使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。\n​\t\t下面就开始springboot整合ES，操作步骤如下：\n步骤①：导入springboot整合ES的starter坐标\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：进行基础配置\nspring:\n  elasticsearch:\n    rest:\n      uris: http://localhost:9200\n\n​\t\t配置ES服务器地址，端口9200\n步骤③：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作\n@SpringBootTest\nclass Springboot18EsApplicationTests &#123;\n    @Autowired\n    private ElasticsearchRestTemplate template;\n&#125;\n\n​\t\t上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。\n​\t\t下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：\n步骤①：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter\n&lt;dependency>\n    &lt;groupId>org.elasticsearch.client&lt;/groupId>\n    &lt;artifactId>elasticsearch-rest-high-level-client&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：使用编程的形式设置连接的ES服务器，并获取客户端对象\n@SpringBootTest\nclass Springboot18EsApplicationTests &#123;\n    private RestHighLevelClient client;\n      @Test\n      void testCreateClient() throws IOException &#123;\n          HttpHost host = HttpHost.create(\"http://localhost:9200\");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n  \n          client.close();\n      &#125;\n&#125;\n\n​\t\t配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。\n步骤③：使用客户端对象操作ES，例如创建索引\n@SpringBootTest\nclass Springboot18EsApplicationTests &#123;\n    private RestHighLevelClient client;\n      @Test\n      void testCreateIndex() throws IOException &#123;\n          HttpHost host = HttpHost.create(\"http://localhost:9200\");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n          \n          CreateIndexRequest request = new CreateIndexRequest(\"books\");\n          client.indices().create(request, RequestOptions.DEFAULT); \n          \n          client.close();\n      &#125;\n&#125;\n\n​\t\t高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。\n​\t\t当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。\n@SpringBootTest\nclass Springboot18EsApplicationTests &#123;\n    @BeforeEach\t\t&#x2F;&#x2F;在测试类中每个操作运行前运行的方法\n    void setUp() &#123;\n        HttpHost host &#x3D; HttpHost.create(&quot;http:&#x2F;&#x2F;localhost:9200&quot;);\n        RestClientBuilder builder &#x3D; RestClient.builder(host);\n        client &#x3D; new RestHighLevelClient(builder);\n    &#125;\n\n    @AfterEach\t\t&#x2F;&#x2F;在测试类中每个操作运行后运行的方法\n    void tearDown() throws IOException &#123;\n        client.close();\n    &#125;\n\n    private RestHighLevelClient client;\n\n    @Test\n    void testCreateIndex() throws IOException &#123;\n        CreateIndexRequest request &#x3D; new CreateIndexRequest(&quot;books&quot;);\n        client.indices().create(request, RequestOptions.DEFAULT);\n    &#125;\n&#125;\n\n​\t\t现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果\n创建索引（IK分词器）：\n@Test\nvoid testCreateIndexByIK() throws IOException &#123;\n    CreateIndexRequest request = new CreateIndexRequest(\"books\");\n    String json = \"&#123;\\n\" +\n            \"    \\\"mappings\\\":&#123;\\n\" +\n            \"        \\\"properties\\\":&#123;\\n\" +\n            \"            \\\"id\\\":&#123;\\n\" +\n            \"                \\\"type\\\":\\\"keyword\\\"\\n\" +\n            \"            &#125;,\\n\" +\n            \"            \\\"name\\\":&#123;\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\",\\n\" +\n            \"                \\\"copy_to\\\":\\\"all\\\"\\n\" +\n            \"            &#125;,\\n\" +\n            \"            \\\"type\\\":&#123;\\n\" +\n            \"                \\\"type\\\":\\\"keyword\\\"\\n\" +\n            \"            &#125;,\\n\" +\n            \"            \\\"description\\\":&#123;\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\",\\n\" +\n            \"                \\\"copy_to\\\":\\\"all\\\"\\n\" +\n            \"            &#125;,\\n\" +\n            \"            \\\"all\\\":&#123;\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\"\\n\" +\n            \"            &#125;\\n\" +\n            \"        &#125;\\n\" +\n            \"    &#125;\\n\" +\n            \"&#125;\";\n    //设置请求中的参数\n    request.source(json, XContentType.JSON);\n    client.indices().create(request, RequestOptions.DEFAULT);\n&#125;\n\n​\t\tIK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。\t\n添加文档：\n@Test\n//添加文档\nvoid testCreateDoc() throws IOException &#123;\n    Book book = bookDao.selectById(1);\n    IndexRequest request = new IndexRequest(\"books\").id(book.getId().toString());\n    String json = JSON.toJSONString(book);\n    request.source(json,XContentType.JSON);\n    client.index(request,RequestOptions.DEFAULT);\n&#125;\n\n​\t\t添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。\t\n批量添加文档：\n@Test\n//批量添加文档\nvoid testCreateDocAll() throws IOException &#123;\n    List&lt;Book> bookList = bookDao.selectList(null);\n    BulkRequest bulk = new BulkRequest();\n    for (Book book : bookList) &#123;\n        IndexRequest request = new IndexRequest(\"books\").id(book.getId().toString());\n        String json = JSON.toJSONString(book);\n        request.source(json,XContentType.JSON);\n        bulk.add(request);\n    &#125;\n    client.bulk(bulk,RequestOptions.DEFAULT);\n&#125;\n\n​\t\t批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。\n按id查询文档：\n@Test\n//按id查询\nvoid testGet() throws IOException &#123;\n    GetRequest request = new GetRequest(\"books\",\"1\");\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    String json = response.getSourceAsString();\n    System.out.println(json);\n&#125;\n\n​\t\t根据id查询文档使用的请求对象是GetRequest。\n按条件查询文档：\n@Test\n//按条件查询\nvoid testSearch() throws IOException &#123;\n    SearchRequest request = new SearchRequest(\"books\");\n\n    SearchSourceBuilder builder = new SearchSourceBuilder();\n    builder.query(QueryBuilders.termQuery(\"all\",\"spring\"));\n    request.source(builder);\n\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    SearchHits hits = response.getHits();\n    for (SearchHit hit : hits) &#123;\n        String source = hit.getSourceAsString();\n        //System.out.println(source);\n        Book book = JSON.parseObject(source, Book.class);\n        System.out.println(book);\n    &#125;\n&#125;\n\n​\t\t按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。\n​\t\tspringboot整合ES的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合ES的客户端对象。至于操作，由于ES操作种类过多，所以显得操作略微有点复杂。有关springboot整合ES就先学习到这里吧。\n总结\n\nspringboot整合ES步骤\n导入springboot整合ES的High Level Client坐标\n手工管理客户端对象，包括初始化和关闭操作\n使用High Level Client根据操作的种类不同，选择不同的Request对象完成对应操作\n\n\n\nKF-5.整合第三方技术​\t\t通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调API。\n​\t\tspringboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。\nKF-5-1.缓存​\t\t企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t          应用程序直接与数据库打交道，访问效率低\n​\t\t为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。\n\n\n                                         使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高\n\n​\t\t缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。\nSpringBoot内置缓存解决方案​\t\tspringboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。\n步骤①：导入springboot提供的缓存技术对应的starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-cache&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    &#125;\n&#125;\n\n步骤③：设置操作的数据是否使用缓存\n@Service\npublic class BookServiceImpl implements BookService &#123;\n    @Autowired\n    private BookDao bookDao;\n\n    @Cacheable(value=\"cacheSpace\",key=\"#id\")\n    public Book getById(Integer id) &#123;\n        return bookDao.selectById(id);\n    &#125;\n&#125;\n\n​\t\t在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。\n​\t\t使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。\n手机验证码案例​\t\t为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。\n​\t\t手机验证码案例需求如下：\n\n输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）\n输入手机号和验证码验证结果\n\n​\t\t为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。\n步骤①：导入springboot提供的缓存技术对应的starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-cache&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    &#125;\n&#125;\n\n步骤③：定义验证码对应的实体类，封装手机号与验证码两个属性\n@Data\npublic class SMSCode &#123;\n    private String tele;\n    private String code;\n&#125;\n\n步骤④：定义验证码功能的业务层接口与实现类\npublic interface SMSCodeService &#123;\n    public String sendCodeToSMS(String tele);\n    public boolean checkCode(SMSCode smsCode);\n&#125;\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @CachePut(value = \"smsCode\", key = \"#tele\")\n    public String sendCodeToSMS(String tele) &#123;\n        String code = codeUtils.generator(tele);\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true\n        String code = smsCode.getCode();\n        String cacheCode = codeUtils.get(smsCode.getTele());\n        return code.equals(cacheCode);\n    &#125;\n&#125;\n\n​\t\t获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。\n​\t\t对于校验验证码的功能建议放入工具类中进行。\n步骤⑤：定义验证码的生成策略与根据手机号读取验证码的功能\n@Component\npublic class CodeUtils &#123;\n    private String [] patch = &#123;\"000000\",\"00000\",\"0000\",\"000\",\"00\",\"0\",\"\"&#125;;\n\n    public String generator(String tele)&#123;\n        int hash = tele.hashCode();\n        int encryption = 20206666;\n        long result = hash ^ encryption;\n        long nowTime = System.currentTimeMillis();\n        result = result ^ nowTime;\n        long code = result % 1000000;\n        code = code &lt; 0 ? -code : code;\n        String codeStr = code + \"\";\n        int len = codeStr.length();\n        return patch[len] + codeStr;\n    &#125;\n\n    @Cacheable(value = \"smsCode\",key=\"#tele\")\n    public String get(String tele)&#123;\n        return null;\n    &#125;\n&#125;\n\n步骤⑥：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验\n@RestController\n@RequestMapping(\"/sms\")\npublic class SMSCodeController &#123;\n    @Autowired\n    private SMSCodeService smsCodeService;\n    \n    @GetMapping\n    public String getCode(String tele)&#123;\n        String code = smsCodeService.sendCodeToSMS(tele);\n        return code;\n    &#125;\n    \n    @PostMapping\n    public boolean checkCode(SMSCode smsCode)&#123;\n        return smsCodeService.checkCode(smsCode);\n    &#125;\n&#125;\n\n\n\nSpringBoot整合Ehcache缓存​\t\t手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合Ehcache技术。Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整\n步骤①：导入Ehcache的坐标\n&lt;dependency>\n    &lt;groupId>net.sf.ehcache&lt;/groupId>\n    &lt;artifactId>ehcache&lt;/artifactId>\n&lt;/dependency>\n\n​\t\t此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。\n步骤②：配置缓存技术实现使用Ehcache\nspring:\n  cache:\n    type: ehcache\n    ehcache:\n      config: ehcache.xml\n\n​\t\t配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。\n​\t\t由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\">\n    &lt;diskStore path=\"D:\\ehcache\" />\n\n    &lt;!--默认缓存策略 -->\n    &lt;!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false-->\n    &lt;!-- diskPersistent：是否启用磁盘持久化-->\n    &lt;!-- maxElementsInMemory：最大缓存数量-->\n    &lt;!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘-->\n    &lt;!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码-->\n    &lt;!-- timeToLiveSeconds：最大存活时间-->\n    &lt;!-- memoryStoreEvictionPolicy：缓存清除策略-->\n    &lt;defaultCache\n        eternal=\"false\"\n        diskPersistent=\"false\"\n        maxElementsInMemory=\"1000\"\n        overflowToDisk=\"false\"\n        timeToIdleSeconds=\"60\"\n        timeToLiveSeconds=\"60\"\n        memoryStoreEvictionPolicy=\"LRU\" />\n\n    &lt;cache\n        name=\"smsCode\"\n        eternal=\"false\"\n        diskPersistent=\"false\"\n        maxElementsInMemory=\"1000\"\n        overflowToDisk=\"false\"\n        timeToIdleSeconds=\"10\"\n        timeToLiveSeconds=\"10\"\n        memoryStoreEvictionPolicy=\"LRU\" />\n&lt;/ehcache>\n\n​\t\t注意前面的案例中，设置了数据保存的位置是smsCode\n@CachePut(value = \"smsCode\", key = \"#tele\")\npublic String sendCodeToSMS(String tele) &#123;\n    String code = codeUtils.generator(tele);\n    return code;\n&#125;\t\n\n​\t\t这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。\n​\t\t到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。\n总结\n\nspringboot使用Ehcache作为缓存实现需要导入Ehcache的坐标\n修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件\n\n​\t\t\nSpringBoot整合Redis缓存​\t\t上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。\n​\t\t比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。\n步骤①：导入redis的坐标\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：配置缓存技术实现使用redis\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n\n​\t\t如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n    redis:\n      use-key-prefix: false\n      key-prefix: sms_\n      cache-null-values: false\n      time-to-live: 10s\n\n总结\n\nspringboot使用redis作为缓存实现需要导入redis的坐标\n修改设置，配置缓存供应商为redis，并提供对应的缓存配置\n\nSpringBoot整合Memcached缓存​\t\t目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。\n​\t\t按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。\n安装\n​\t\twindows版安装包下载地址：https://www.runoob.com/memcached/window-install-memcached.html\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n​\t\t可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：\n\n\n​\t\t此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行\n\n\n​\t\t然后再次执行安装服务的命令即可，如下：\nmemcached.exe -d install\n\n​\t\t服务安装完毕后可以使用命令启动和停止服务，如下：\nmemcached.exe -d start\t\t# 启动服务\nmemcached.exe -d stop\t\t# 停止服务\n\n​\t\t也可以在任务管理器中进行服务状态的切换\n\n\n变更缓存为Memcached\n​\t\t由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。\n​\t\tmemcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached\n步骤①：导入xmemcached的坐标\n&lt;dependency>\n    &lt;groupId>com.googlecode.xmemcached&lt;/groupId>\n    &lt;artifactId>xmemcached&lt;/artifactId>\n    &lt;version>2.4.7&lt;/version>\n&lt;/dependency>\n\n步骤②：配置memcached，制作memcached的配置类\n@Configuration\npublic class XMemcachedConfig &#123;\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException &#123;\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(\"localhost:11211\");\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    &#125;\n&#125;\n\n​\t\tmemcached默认对外服务端口11211。\n步骤③：使用xmemcached客户端操作缓存，注入MemcachedClient对象\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @Autowired\n    private CodeUtils codeUtils;\n    @Autowired\n    private MemcachedClient memcachedClient;\n\n    public String sendCodeToSMS(String tele) &#123;\n        String code = codeUtils.generator(tele);\n        try &#123;\n            memcachedClient.set(tele,10,code);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        String code = null;\n        try &#123;\n            code = memcachedClient.get(smsCode.getTele()).toString();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return smsCode.getCode().equals(code);\n    &#125;\n&#125;\n\n​\t\t设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。\n​\t\t上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。\n定义配置属性\n​\t\t以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。\n\n定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息\n@Component\n@ConfigurationProperties(prefix = \"memcached\")\n@Data\npublic class XMemcachedProperties &#123;\n    private String servers;\n    private int poolSize;\n    private long opTimeout;\n&#125;\n\n定义memcached节点信息\nmemcached:\n  servers: localhost:11211\n  poolSize: 10\n  opTimeout: 3000\n\n在memcached配置类中加载信息\n\n\n@Configuration\npublic class XMemcachedConfig &#123;\n    @Autowired\n    private XMemcachedProperties props;\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException &#123;\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(props.getServers());\n        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());\n        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    &#125;\n&#125;\n\n总结\n\nmemcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限\n由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存\n导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存\n初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载\n\n思考\n​\t\t到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。\nSpringBoot整合jetcache缓存​\t\t目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。\n​\t\tjetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。\n​\t\t做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：\n\n本地缓存（Local）\nLinkedHashMap\nCaffeine\n\n\n远程缓存（Remote）\nRedis\nTair\n\n\n\n​\t\t其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。\n纯远程方案步骤①：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis\n&lt;dependency>\n    &lt;groupId>com.alicp.jetcache&lt;/groupId>\n    &lt;artifactId>jetcache-starter-redis&lt;/artifactId>\n    &lt;version>2.6.2&lt;/version>\n&lt;/dependency>\n\n步骤②：远程方案基本配置\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n​\t\t其中poolConfig是必配项，否则会报错\n步骤③：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    &#125;\n&#125;\n\n步骤④：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(name=\"jetCache_\",expire = 10,timeUnit = TimeUnit.SECONDS)\n    private Cache&lt;String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) &#123;\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    &#125;\n&#125;\n\n​\t\t通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。\n​\t\t上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n​\t\t如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(area&#x3D;&quot;sms&quot;,name&#x3D;&quot;jetCache_&quot;,expire &#x3D; 10,timeUnit &#x3D; TimeUnit.SECONDS)\n    private Cache&lt;String ,String&gt; jetCache;\n\n    public String sendCodeToSMS(String tele) &#123;\n        String code &#x3D; codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        String code &#x3D; jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    &#125;\n&#125;\n\n纯本地方案​\t\t远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。\n步骤①：导入springboot整合jetcache对应的坐标starter\n&lt;dependency>\n    &lt;groupId>com.alicp.jetcache&lt;/groupId>\n    &lt;artifactId>jetcache-starter-redis&lt;/artifactId>\n    &lt;version>2.6.2&lt;/version>\n&lt;/dependency>\n\n步骤②：本地缓存基本配置\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n\n​\t\t为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。\n步骤③：启用缓存\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    &#125;\n&#125;\n\n步骤④：创建缓存对象Cache时，标注当前使用本地缓存\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @CreateCache(name=\"jetCache_\",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)\n    private Cache&lt;String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) &#123;\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    &#125;\n&#125;\n\n​\t\tcacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType&#x3D;CacheType.LOCAL即使用本地缓存。\n本地+远程方案​\t\t本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n​\t\t在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @CreateCache(name=\"jetCache_\",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)\n    private Cache&lt;String ,String> jetCache;\n&#125;\n\n​\t\tcacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息\n\n\n\n属性\n默认值\n说明\n\n\n\njetcache.statIntervalMinutes\n0\n统计间隔，0表示不统计\n\n\njetcache.hiddenPackages\n无\n自动生成name时，隐藏指定的包名前缀\n\n\njetcache.[local|remote].${area}.type\n无\n缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair\n\n\njetcache.[local|remote].${area}.keyConvertor\n无\nkey转换器，当前仅支持fastjson\n\n\njetcache.[local|remote].${area}.valueEncoder\njava\n仅remote类型的缓存需要指定，可选java和kryo\n\n\njetcache.[local|remote].${area}.valueDecoder\njava\n仅remote类型的缓存需要指定，可选java和kryo\n\n\njetcache.[local|remote].${area}.limit\n100\n仅local类型的缓存需要指定，缓存实例最大元素数\n\n\njetcache.[local|remote].${area}.expireAfterWriteInMillis\n无穷大\n默认过期时间，毫秒单位\n\n\njetcache.local.${area}.expireAfterAccessInMillis\n0\n仅local类型的缓存有效，毫秒单位，最大不活动间隔\n\n\n​\t\t以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。\n方法缓存\n​\t\tjetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可\n步骤①：导入springboot整合jetcache对应的坐标starter\n&lt;dependency>\n    &lt;groupId>com.alicp.jetcache&lt;/groupId>\n    &lt;artifactId>jetcache-starter-redis&lt;/artifactId>\n    &lt;version>2.6.2&lt;/version>\n&lt;/dependency>\n\n步骤②：配置缓存\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      keyConvertor: fastjson\n      valueEncode: java\n      valueDecode: java\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n​\t\t由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。\n​\t\t注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。\n@Data\npublic class Book implements Serializable &#123;\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n&#125;\n\n步骤③：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\n//开启方法注解缓存\n@EnableMethodCache(basePackages = \"com.itheima\")\npublic class Springboot20JetCacheApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    &#125;\n&#125;\n\n步骤④：使用注解@Cached标注当前方法使用缓存\n@Service\npublic class BookServiceImpl implements BookService &#123;\n    @Autowired\n    private BookDao bookDao;\n    \n    @Override\n    @Cached(name=\"book_\",key=\"#id\",expire = 3600,cacheType = CacheType.REMOTE)\n    public Book getById(Integer id) &#123;\n        return bookDao.selectById(id);\n    &#125;\n&#125;\n\n远程方案的数据同步​\t\t由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据\n更新缓存\n@CacheUpdate(name&#x3D;&quot;book_&quot;,key&#x3D;&quot;#book.id&quot;,value&#x3D;&quot;#book&quot;)\npublic boolean update(Book book) &#123;\n    return bookDao.updateById(book) &gt; 0;\n&#125;\n\n删除缓存\n@CacheInvalidate(name&#x3D;&quot;book_&quot;,key &#x3D; &quot;#id&quot;)\npublic boolean delete(Integer id) &#123;\n    return bookDao.deleteById(id) &gt; 0;\n&#125;\n\n定时刷新缓存\n@Cached(name&#x3D;&quot;book_&quot;,key&#x3D;&quot;#id&quot;,expire &#x3D; 3600,cacheType &#x3D; CacheType.REMOTE)\n@CacheRefresh(refresh &#x3D; 5)\npublic Book getById(Integer id) &#123;\n    return bookDao.selectById(id);\n&#125;\n\n数据报表​\t\tjetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可\njetcache:\n  statIntervalMinutes: 1\n\n​\t\t设置后，每1分钟在控制台输出缓存数据命中信息\n[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003\ncache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\nbook_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\n\n总结\n\njetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案\njetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种\n注意数据进入远程缓存时的类型转换问题\njetcache提供方法缓存，并提供了对应的缓存更新与刷新功能\njetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况\n\n思考\n​\t\tjetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。\nSpringBoot整合j2cache缓存​\t\tjetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：\n步骤①：导入j2cache、redis、ehcache坐标\n&lt;dependency>\n    &lt;groupId>net.oschina.j2cache&lt;/groupId>\n    &lt;artifactId>j2cache-core&lt;/artifactId>\n    &lt;version>2.8.4-release&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>net.oschina.j2cache&lt;/groupId>\n    &lt;artifactId>j2cache-spring-boot2-starter&lt;/artifactId>\n    &lt;version>2.8.0-release&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>net.sf.ehcache&lt;/groupId>\n    &lt;artifactId>ehcache&lt;/artifactId>\n&lt;/dependency>\n\n​\t\tj2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标\n步骤②：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件\n# 1级缓存\nj2cache.L1.provider_class = ehcache\nehcache.configXml = ehcache.xml\n\n# 2级缓存\nj2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProvider\nj2cache.L2.config_section = redis\nredis.hosts = localhost:6379\n\n# 1级缓存中的数据如何到达二级缓存\nj2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy\n\n​\t\t此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。\n​\t\t一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。\n步骤③：使用缓存\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService &#123;\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @Autowired\n    private CacheChannel cacheChannel;\n\n    public String sendCodeToSMS(String tele) &#123;\n        String code = codeUtils.generator(tele);\n        cacheChannel.set(\"sms\",tele,code);\n        return code;\n    &#125;\n\n    public boolean checkCode(SMSCode smsCode) &#123;\n        String code = cacheChannel.get(\"sms\",smsCode.getTele()).asString();\n        return smsCode.getCode().equals(code);\n    &#125;\n&#125;\n\n​\t\tj2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。\n​\t\tj2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：\n#J2Cache configuration\n#########################################\n# Cache Broadcast Method\n# values:\n# jgroups -> use jgroups's multicast\n# redis -> use redis publish/subscribe mechanism (using jedis)\n# lettuce -> use redis publish/subscribe mechanism (using lettuce, Recommend)\n# rabbitmq -> use RabbitMQ publisher/consumer mechanism\n# rocketmq -> use RocketMQ publisher/consumer mechanism\n# none -> don't notify the other nodes in cluster\n# xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy\n#########################################\nj2cache.broadcast = redis\n\n# jgroups properties\njgroups.channel.name = j2cache\njgroups.configXml = /network.xml\n\n# RabbitMQ properties\nrabbitmq.exchange = j2cache\nrabbitmq.host = localhost\nrabbitmq.port = 5672\nrabbitmq.username = guest\nrabbitmq.password = guest\n\n# RocketMQ properties\nrocketmq.name = j2cache\nrocketmq.topic = j2cache\n# use ; to split multi hosts\nrocketmq.hosts = 127.0.0.1:9876\n\n#########################################\n# Level 1&amp;2 provider\n# values:\n# none -> disable this level cache\n# ehcache -> use ehcache2 as level 1 cache\n# ehcache3 -> use ehcache3 as level 1 cache\n# caffeine -> use caffeine as level 1 cache(only in memory)\n# redis -> use redis as level 2 cache (using jedis)\n# lettuce -> use redis as level 2 cache (using lettuce)\n# readonly-redis -> use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.\n# memcached -> use memcached as level 2 cache (xmemcached),\n# [classname] -> use custom provider\n#########################################\n\nj2cache.L1.provider_class = caffeine\nj2cache.L2.provider_class = redis\n\n# When L2 provider isn't `redis`, using `L2.config_section = redis` to read redis configurations\n# j2cache.L2.config_section = redis\n\n# Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)\n# NOTICE: redis hash mode (redis.storage = hash) do not support this feature)\nj2cache.sync_ttl_to_redis = true\n\n# Whether to cache null objects by default (default false)\nj2cache.default_cache_null_object = true\n\n#########################################\n# Cache Serialization Provider\n# values:\n# fst -> using fast-serialization (recommend)\n# kryo -> using kryo serialization\n# json -> using fst's json serialization (testing)\n# fastjson -> using fastjson serialization (embed non-static class not support)\n# java -> java standard\n# fse -> using fse serialization\n# [classname implements Serializer]\n#########################################\n\nj2cache.serialization = json\n#json.map.person = net.oschina.j2cache.demo.Person\n\n#########################################\n# Ehcache configuration\n#########################################\n\n# ehcache.configXml = /ehcache.xml\n\n# ehcache3.configXml = /ehcache3.xml\n# ehcache3.defaultHeapSize = 1000\n\n#########################################\n# Caffeine configuration\n# caffeine.region.[name] = size, xxxx[s|m|h|d]\n#\n#########################################\ncaffeine.properties = /caffeine.properties\n\n#########################################\n# Redis connection configuration\n#########################################\n\n#########################################\n# Redis Cluster Mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\nredis.mode = single\n\n#redis storage mode (generic|hash)\nredis.storage = generic\n\n## redis pub/sub channel name\nredis.channel = j2cache\n## redis pub/sub server (using redis.hosts when empty)\nredis.channel.host =\n\n#cluster name just for sharded\nredis.cluster_name = j2cache\n\n## redis cache namespace optional, default[empty]\nredis.namespace =\n\n## redis command scan parameter count, default[1000]\n#redis.scanCount = 1000\n\n## connection\n# Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379\n\nredis.hosts = 127.0.0.1:6379\nredis.timeout = 2000\nredis.password =\nredis.database = 0\nredis.ssl = false\n\n## redis pool properties\nredis.maxTotal = 100\nredis.maxIdle = 10\nredis.maxWaitMillis = 5000\nredis.minEvictableIdleTimeMillis = 60000\nredis.minIdle = 1\nredis.numTestsPerEvictionRun = 10\nredis.lifo = false\nredis.softMinEvictableIdleTimeMillis = 10\nredis.testOnBorrow = true\nredis.testOnReturn = false\nredis.testWhileIdle = true\nredis.timeBetweenEvictionRunsMillis = 300000\nredis.blockWhenExhausted = false\nredis.jmxEnabled = false\n\n#########################################\n# Lettuce scheme\n#\n# redis -> single redis server\n# rediss -> single redis server with ssl\n# redis-sentinel -> redis sentinel\n# redis-cluster -> cluster servers\n#\n#########################################\n\n#########################################\n# Lettuce Mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\n## redis command scan parameter count, default[1000]\n#lettuce.scanCount = 1000\nlettuce.mode = single\nlettuce.namespace =\nlettuce.storage = hash\nlettuce.channel = j2cache\nlettuce.scheme = redis\nlettuce.hosts = 127.0.0.1:6379\nlettuce.password =\nlettuce.database = 0\nlettuce.sentinelMasterId =\nlettuce.maxTotal = 100\nlettuce.maxIdle = 10\nlettuce.minIdle = 10\n# timeout in milliseconds\nlettuce.timeout = 10000\n# redis cluster topology refresh interval in milliseconds\nlettuce.clusterTopologyRefresh = 3000\n\n#########################################\n# memcached server configurations\n# refer to https://gitee.com/mirrors/XMemcached\n#########################################\n\nmemcached.servers = 127.0.0.1:11211\nmemcached.username =\nmemcached.password =\nmemcached.connectionPoolSize = 10\nmemcached.connectTimeout = 1000\nmemcached.failureMode = false\nmemcached.healSessionInterval = 1000\nmemcached.maxQueuedNoReplyOperations = 100\nmemcached.opTimeout = 100\nmemcached.sanitizeKeys = false\n\n总结\n\nj2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案\nj2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式\nj2cache操作接口通过CacheChannel实现\n\nKF-5-2.任务​\t\tspringboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。\nQuartz​\t\tQuartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。\n\n工作（Job）：用于定义具体执行的工作\n工作明细（JobDetail）：用于描述定时工作相关的信息\n触发器（Trigger）：描述了工作明细与调度器的对应关系\n调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n\n​\t\t简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。\n步骤①：导入springboot整合Quartz的starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-quartz&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean\npublic class MyQuartz extends QuartzJobBean &#123;\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;\n        System.out.println(\"quartz task run...\");\n    &#125;\n&#125;\n\n步骤③：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean\n@Configuration\npublic class QuartzConfig &#123;\n    @Bean\n    public JobDetail printJobDetail()&#123;\n        //绑定具体的工作\n        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();\n    &#125;\n    @Bean\n    public Trigger printJobTrigger()&#123;\n        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(\"0/5 * * * * ?\");\n        //绑定对应的工作明细\n        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();\n    &#125;\n&#125;\n\n​\t\t工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。\n​\t\t触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。\n总结\n\nspringboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象\nJobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象\nTrigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器\n\n思考\n​\t\t上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，如何用呢？咱们下节再说。\nTask​\t\tspring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做\n步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling\n@SpringBootApplication\n//开启定时任务功能\n@EnableScheduling\npublic class Springboot22TaskApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot22TaskApplication.class, args);\n    &#125;\n&#125;\n\n步骤②：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式\n@Component\npublic class MyBean &#123;\n    @Scheduled(cron = \"0/1 * * * * ?\")\n    public void print()&#123;\n        System.out.println(Thread.currentThread().getName()+\" :spring task run...\");\n    &#125;\n&#125;\n\n​\t\t完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。\n​\t\t如何想对定时任务进行相关配置，可以通过配置文件进行\nspring:\n  task:\n   \tscheduling:\n      pool:\n       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1\n      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-      \n        shutdown:\n          await-termination: false\t\t# 线程池关闭时等待所有任务完成\n          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n\n总结\n\nspring task需要使用注解@EnableScheduling开启定时任务功能\n\n为定时执行的的任务设置执行周期，描述方式cron表达式\n\n\nKF-5-3.邮件​\t\tspringboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。\n​\t\t学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。\n\nSMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件的传输协议\nPOP3（Post Office Protocol - Version 3）：用于接收电子邮件的标准协议\nIMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议\n\n​\t\t简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。\n发送简单邮件步骤①：导入springboot整合javamail的starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-mail&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：配置邮箱的登录信息\nspring:\n  mail:\n    host: smtp.126.com\n    username: test@126.com\n    password: test\n\n​\t\tjava程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。\n​\t\thost配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。\n​\t\tpassword并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：\n\n步骤③：使用JavaMailSender接口发送邮件\n@Service\npublic class SendMailServiceImpl implements SendMailService &#123;\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = \"test@qq.com\";\n    //接收人\n    private String to = \"test@126.com\";\n    //标题\n    private String subject = \"测试邮件\";\n    //正文\n    private String context = \"测试邮件正文内容\";\n\n    @Override\n    public void sendMail() &#123;\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from+\"(小甜甜)\");\n        message.setTo(to);\n        message.setSubject(subject);\n        message.setText(context);\n        javaMailSender.send(message);\n    &#125;\n&#125;\n\n​\t\t将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。\n发送多组件邮件（附件、复杂正文）​\t\t发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。\n发送网页正文邮件\n@Service\npublic class SendMailServiceImpl2 implements SendMailService &#123;\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    &#x2F;&#x2F;发送人\n    private String from &#x3D; &quot;test@qq.com&quot;;\n    &#x2F;&#x2F;接收人\n    private String to &#x3D; &quot;test@126.com&quot;;\n    &#x2F;&#x2F;标题\n    private String subject &#x3D; &quot;测试邮件&quot;;\n    &#x2F;&#x2F;正文\n    private String context &#x3D; &quot;&lt;img src&#x3D;&#39;ABC.JPG&#39;&#x2F;&gt;&lt;a href&#x3D;&#39;https:&#x2F;&#x2F;www.itcast.cn&#39;&gt;点开有惊喜&lt;&#x2F;a&gt;&quot;;\n\n    public void sendMail() &#123;\n        try &#123;\n            MimeMessage message &#x3D; javaMailSender.createMimeMessage();\n            MimeMessageHelper helper &#x3D; new MimeMessageHelper(message);\n            helper.setFrom(to+&quot;(小甜甜)&quot;);\n            helper.setTo(from);\n            helper.setSubject(subject);\n            helper.setText(context,true);\t\t&#x2F;&#x2F;此处设置正文支持html解析\n\n            javaMailSender.send(message);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n发送带有附件的邮件\n@Service\npublic class SendMailServiceImpl2 implements SendMailService &#123;\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    &#x2F;&#x2F;发送人\n    private String from &#x3D; &quot;test@qq.com&quot;;\n    &#x2F;&#x2F;接收人\n    private String to &#x3D; &quot;test@126.com&quot;;\n    &#x2F;&#x2F;标题\n    private String subject &#x3D; &quot;测试邮件&quot;;\n    &#x2F;&#x2F;正文\n    private String context &#x3D; &quot;测试邮件正文&quot;;\n\n    public void sendMail() &#123;\n        try &#123;\n            MimeMessage message &#x3D; javaMailSender.createMimeMessage();\n            MimeMessageHelper helper &#x3D; new MimeMessageHelper(message,true);\t\t&#x2F;&#x2F;此处设置支持附件\n            helper.setFrom(to+&quot;(小甜甜)&quot;);\n            helper.setTo(from);\n            helper.setSubject(subject);\n            helper.setText(context);\n\n            &#x2F;&#x2F;添加附件\n            File f1 &#x3D; new File(&quot;springboot_23_mail-0.0.1-SNAPSHOT.jar&quot;);\n            File f2 &#x3D; new File(&quot;resources\\\\logo.png&quot;);\n\n            helper.addAttachment(f1.getName(),f1);\n            helper.addAttachment(&quot;最靠谱的培训结构.png&quot;,f2);\n\n            javaMailSender.send(message);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n总结\n\nspringboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程\n\nKF-5-4.消息​\t\tspringboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。\n消息的概念​\t\t从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。\n​\t\t为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。\n​\t\t对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。\n​\t\t对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。\n​\t\t所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。\n​\t\t所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。\n​\t\t以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。\nJava处理消息的标准规范​\t\t目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：\n\nJMS\nAMQP\nMQTT\n\n​\t\t为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及\nJMS​\t\tJMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。\nJMS消息模型\n​\t\tJMS规范中规范了消息有两种模型。分别是点对点模型和发布订阅模型。\n​\t\t点对点模型：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。\n​\t\t发布订阅模型：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。\n​\t\t以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。\nJMS消息种类\n​\t\t根据消息中包含的数据种类划分，可以将消息划分成6种消息。\n\nTextMessage\nMapMessage\nBytesMessage\nStreamMessage\nObjectMessage\nMessage （只有消息头和属性）\n\n​\t\tJMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。\nAMQP​\t\tJMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。\n​\t\t这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。\n​\t\t单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。\n​\t\tAMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS操作。优点\n​\t\t具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现\nJMS消息种类\n​\t\tAMQP消息种类：byte[]\n​\t\tAMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。\nAMQP消息模型\n\ndirect exchange\nfanout exchange\ntopic exchange\nheaders exchange\nsystem exchange\n\n​\t\t目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ\nMQTT​\t\tMQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。\n​\t\t除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。\nKafKa​\t\tKafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。\n​\t\t本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。\n购物订单发送手机短信案例​\t\t为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。\n​\t\t手机验证码案例需求如下：\n\n执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件\n\n消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）\n由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：\n\n\n订单业务\n​\t\t业务层接口\npublic interface OrderService &#123;\n    void order(String id);\n&#125;\n\n​\t\t模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类\n​\t\t业务层实现\n@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Autowired\n    private MessageService messageService;\n    \n    @Override\n    public void order(String id) &#123;\n        &#x2F;&#x2F;一系列操作，包含各种服务调用，处理各种业务\n        System.out.println(&quot;订单处理开始&quot;);\n        &#x2F;&#x2F;短信消息处理\n        messageService.sendMessage(id);\n        System.out.println(&quot;订单处理结束&quot;);\n        System.out.println();\n    &#125;\n&#125;\n\n​\t\t业务层转调短信处理的服务MessageService\n​\t\t表现层服务\n@RestController\n@RequestMapping(&quot;&#x2F;orders&quot;)\npublic class OrderController &#123;\n\n    @Autowired\n    private OrderService orderService;\n\n    @PostMapping(&quot;&#123;id&#125;&quot;)\n    public void order(@PathVariable String id)&#123;\n        orderService.order(id);\n    &#125;\n&#125;\n\n​\t\t表现层对外开发接口，传入订单id即可（模拟）\n短信处理业务\n​\t\t业务层接口\npublic interface MessageService &#123;\n    void sendMessage(String id);\n    String doMessage();\n&#125;\n\n​\t\t短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计\n​\t\t业务层实现\n@Service\npublic class MessageServiceImpl implements MessageService &#123;\n    private ArrayList&lt;String&gt; msgList &#x3D; new ArrayList&lt;String&gt;();\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(&quot;待发送短信的订单已纳入处理队列，id：&quot;+id);\n        msgList.add(id);\n    &#125;\n\n    @Override\n    public String doMessage() &#123;\n        String id &#x3D; msgList.remove(0);\n        System.out.println(&quot;已完成短信发送业务，id：&quot;+id);\n        return id;\n    &#125;\n&#125;\n\n​\t\t短信处理业务层实现中使用集合先模拟消息队列，观察效果\n​\t\t表现层服务\n@RestController\n@RequestMapping(&quot;&#x2F;msgs&quot;)\npublic class MessageController &#123;\n\n    @Autowired\n    private MessageService messageService;\n\n    @GetMapping\n    public String doMessage()&#123;\n        String id &#x3D; messageService.doMessage();\n        return id;\n    &#125;\n&#125;\n\n​\t\t短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。\n​\t\t下面开启springboot整合各种各样的消息中间件，从严格满足JMS规范的ActiveMQ开始\nSpringBoot整合ActiveMQ​\t\tActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。\n安装​\t\twindows版安装包下载地址：https://activemq.apache.org/components/classic/download&#x2F;\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n启动服务器\nactivemq.bat\n\n​\t\t运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。\n访问web管理服务\n​\t\tActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。\nhttp:&#x2F;&#x2F;127.0.0.1:8161&#x2F;\n\n​\t\tweb管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：\n\n\n​\t\t首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：\n\n​\t\t看到上述界面视为启动ActiveMQ服务成功。\n启动失败\n​\t\t在ActiveMQ启动时要占用多个端口，以下为正常启动信息：\nwrapper  | --&gt; Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http:&#x2F;&#x2F;wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current&#x3D;249344k  free&#x3D;235037k  max&#x3D;932352k\njvm 1    |     JVM args: -Dactivemq.home&#x3D;..&#x2F;.. -Dactivemq.base&#x3D;..&#x2F;.. -Djavax.net.ssl.keyStorePassword&#x3D;password -Djavax.net.ssl.trustStorePassword&#x3D;password -Djavax.net.ssl.keyStore&#x3D;..&#x2F;..&#x2F;conf&#x2F;broker.ks -Djavax.net.ssl.trustStore&#x3D;..&#x2F;..&#x2F;conf&#x2F;broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner&#x3D;true -Djava.util.logging.config.file&#x3D;logging.properties -Dactivemq.conf&#x3D;..&#x2F;..&#x2F;conf -Dactivemq.data&#x3D;..&#x2F;..&#x2F;data -Djava.security.auth.login.config&#x3D;..&#x2F;..&#x2F;conf&#x2F;login.config -Xmx1024m -Djava.library.path&#x3D;..&#x2F;..&#x2F;bin&#x2F;win64 -Dwrapper.key&#x3D;7ySrCD75XhLCpLjd -Dwrapper.port&#x3D;32000 -Dwrapper.jvm.port.min&#x3D;31000 -Dwrapper.jvm.port.max&#x3D;31999 -Dwrapper.pid&#x3D;9364 -Dwrapper.version&#x3D;3.2.3 -Dwrapper.native_library&#x3D;wrapper -Dwrapper.cpu.timeout&#x3D;10 -Dwrapper.jvmid&#x3D;1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp:&#x2F;&#x2F;CZBK-20210302VL:61616?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    |  INFO | Listening for connections at: amqp:&#x2F;&#x2F;CZBK-20210302VL:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector amqp started\njvm 1    |  INFO | Listening for connections at: stomp:&#x2F;&#x2F;CZBK-20210302VL:61613?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector stomp started\njvm 1    |  INFO | Listening for connections at: mqtt:&#x2F;&#x2F;CZBK-20210302VL:1883?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector mqtt started\njvm 1    |  INFO | Starting Jetty server\njvm 1    |  INFO | Creating Jetty connector\njvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f&#123;&#x2F;,null,STARTING&#125; has uncovered http methods for path: &#x2F;\njvm 1    |  INFO | Listening for connections at ws:&#x2F;&#x2F;CZBK-20210302VL:61614?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector ws started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) started\njvm 1    |  INFO | For help or more information please see: http:&#x2F;&#x2F;activemq.apache.org\njvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mb\njvm 1    |  INFO | ActiveMQ WebConsole available at http:&#x2F;&#x2F;127.0.0.1:8161&#x2F;\njvm 1    |  INFO | ActiveMQ Jolokia REST API available at http:&#x2F;&#x2F;127.0.0.1:8161&#x2F;api&#x2F;jolokia&#x2F;\n\n​\t\t其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看【命令行启动常见问题及解决方案】\nwrapper  | --&gt; Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http:&#x2F;&#x2F;wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current&#x3D;249344k  free&#x3D;235038k  max&#x3D;932352k\njvm 1    |     JVM args: -Dactivemq.home&#x3D;..&#x2F;.. -Dactivemq.base&#x3D;..&#x2F;.. -Djavax.net.ssl.keyStorePassword&#x3D;password -Djavax.net.ssl.trustStorePassword&#x3D;password -Djavax.net.ssl.keyStore&#x3D;..&#x2F;..&#x2F;conf&#x2F;broker.ks -Djavax.net.ssl.trustStore&#x3D;..&#x2F;..&#x2F;conf&#x2F;broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner&#x3D;true -Djava.util.logging.config.file&#x3D;logging.properties -Dactivemq.conf&#x3D;..&#x2F;..&#x2F;conf -Dactivemq.data&#x3D;..&#x2F;..&#x2F;data -Djava.security.auth.login.config&#x3D;..&#x2F;..&#x2F;conf&#x2F;login.config -Xmx1024m -Djava.library.path&#x3D;..&#x2F;..&#x2F;bin&#x2F;win64 -Dwrapper.key&#x3D;QPJoy9ZoXeWmmwTS -Dwrapper.port&#x3D;32000 -Dwrapper.jvm.port.min&#x3D;31000 -Dwrapper.jvm.port.max&#x3D;31999 -Dwrapper.pid&#x3D;14836 -Dwrapper.version&#x3D;3.2.3 -Dwrapper.native_library&#x3D;wrapper -Dwrapper.cpu.timeout&#x3D;10 -Dwrapper.jvmid&#x3D;1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp:&#x2F;&#x2F;CZBK-20210302VL:61616?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)\njvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)\njvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)\njvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)\njvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\njvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)\njvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)\njvm 1    |      ... 46 more\njvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)\njvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)\njvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)\njvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)\njvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)\njvm 1    |      at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:237)\njvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)\njvm 1    |      ... 52 more\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting down\njvm 1    |  INFO | socketQueue interrupted - stopping\njvm 1    |  INFO | Connector openwire stopped\njvm 1    |  INFO | Could not accept connection during shutdown  : null (null)\njvm 1    |  INFO | Connector amqp stopped\njvm 1    |  INFO | Connector stomp stopped\njvm 1    |  INFO | Connector mqtt stopped\njvm 1    |  INFO | Connector ws stopped\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] stopped\njvm 1    |  INFO | Stopping async queue tasks\njvm 1    |  INFO | Stopping async topic tasks\njvm 1    |  INFO | Stopped KahaDB\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 seconds\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdown\njvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;org.apache.activemq.xbean.XBeanBrokerService#0&#39; defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#39;refresh&#39; before accessing beans via the ApplicationContext\njvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#39;refresh&#39; before accessing beans via the ApplicationContext\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#39;refresh&#39; before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      ... 16 more\njvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#39;refresh&#39; before accessing beans via the ApplicationContext\njvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#39;refresh&#39; before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\nwrapper  | &lt;-- Wrapper Stopped\n请按任意键继续. . .\n\n整合​\t\t做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工\n步骤①：导入springboot整合ActiveMQ的starter\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-activemq&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：配置ActiveMQ的服务器地址\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n\n步骤③：使用JmsMessagingTemplate操作ActiveMQ\n@Service\npublic class MessageServiceActivemqImpl implements MessageService &#123;\n    @Autowired\n    private JmsMessagingTemplate messagingTemplate;\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(\"待发送短信的订单已纳入处理队列，id：\"+id);\n        messagingTemplate.convertAndSend(\"order.queue.id\",id);\n    &#125;\n\n    @Override\n    public String doMessage() &#123;\n        String id = messagingTemplate.receiveAndConvert(\"order.queue.id\",String.class);\n        System.out.println(\"已完成短信发送业务，id：\"+id);\n        return id;\n    &#125;\n&#125;\n\n​\t\t发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。\n​\t\t接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Component\npublic class MessageListener &#123;\n    @JmsListener(destination &#x3D; &quot;order.queue.id&quot;)\n    @SendTo(&quot;order.other.queue.id&quot;)\n    public String receive(String id)&#123;\n        System.out.println(&quot;已完成短信发送业务，id：&quot;+id);\n        return &quot;new:&quot;+id;\n    &#125;\n&#125;\n\n​\t\t使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。\n​\t\t如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。\n步骤⑤：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n    pub-sub-domain: true\n\n​\t\tpub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。\n总结\n\nspringboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列\n操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener\n配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型\n\nSpringBoot整合RabbitMQ​\t\tRabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。\nErlang安装\n​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;www.erlang.org/downloads\n​\t\t下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。\n​\t\t安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：\n\n​\t\tErlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。\n\nERLANG_HOME\nPATH\n\n安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;rabbitmq.com&#x2F;install-windows.html\n​\t\t下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件\n\n\n启动服务器\nrabbitmq-service.bat start\t\t# 启动服务\nrabbitmq-service.bat stop\t\t# 停止服务\nrabbitmqctl status\t\t\t\t# 查看服务状态\n\n​\t\t运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。\n​\t\t注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。\n​\t\t说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。\n​\t\t说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。\n\n\n访问web管理服务\n​\t\tRabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。\nrabbitmq-plugins.bat list\t\t\t\t\t\t\t# 查看当前所有插件的运行状态\nrabbitmq-plugins.bat enable rabbitmq_management\t\t# 启动rabbitmq_management插件\n\n​\t\t启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面\nhttp:&#x2F;&#x2F;localhost:15672\n\n​\t\tweb管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：\n\n​\t\t首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：\n\n整合(direct模型)​\t\tRabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。\n步骤①：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：配置RabbitMQ的服务器地址\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n\n步骤③：初始化直连模式系统设置\n​\t\t由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等\n@Configuration\npublic class RabbitConfigDirect &#123;\n    @Bean\n    public Queue directQueue()&#123;\n        return new Queue(&quot;direct_queue&quot;);\n    &#125;\n    @Bean\n    public Queue directQueue2()&#123;\n        return new Queue(&quot;direct_queue2&quot;);\n    &#125;\n    @Bean\n    public DirectExchange directExchange()&#123;\n        return new DirectExchange(&quot;directExchange&quot;);\n    &#125;\n    @Bean\n    public Binding bindingDirect()&#123;\n        return BindingBuilder.bind(directQueue()).to(directExchange()).with(&quot;direct&quot;);\n    &#125;\n    @Bean\n    public Binding bindingDirect2()&#123;\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(&quot;direct2&quot;);\n    &#125;\n&#125;\n\n​\t\t队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。\n步骤④：使用AmqpTemplate操作RabbitMQ\n@Service\npublic class MessageServiceRabbitmqDirectImpl implements MessageService &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(\"待发送短信的订单已纳入处理队列（rabbitmq direct），id：\"+id);\n        amqpTemplate.convertAndSend(\"directExchange\",\"direct\",id);\n    &#125;\n&#125;\n\n​\t\tamqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。\n步骤⑤：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Component\npublic class MessageListener &#123;\n    @RabbitListener(queues &#x3D; &quot;direct_queue&quot;)\n    public void receive(String id)&#123;\n        System.out.println(&quot;已完成短信发送业务(rabbitmq direct)，id：&quot;+id);\n    &#125;\n&#125;\n\n​\t\t使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n整合(topic模型)步骤①：同上\n步骤②：同上\n步骤③：初始化主题模式系统设置\n@Configuration\npublic class RabbitConfigTopic &#123;\n    @Bean\n    public Queue topicQueue()&#123;\n        return new Queue(&quot;topic_queue&quot;);\n    &#125;\n    @Bean\n    public Queue topicQueue2()&#123;\n        return new Queue(&quot;topic_queue2&quot;);\n    &#125;\n    @Bean\n    public TopicExchange topicExchange()&#123;\n        return new TopicExchange(&quot;topicExchange&quot;);\n    &#125;\n    @Bean\n    public Binding bindingTopic()&#123;\n        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with(&quot;topic.*.id&quot;);\n    &#125;\n    @Bean\n    public Binding bindingTopic2()&#123;\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(&quot;topic.orders.*&quot;);\n    &#125;\n&#125;\n\n​\t\t主题模式支持routingKey匹配模式，*表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。\t\n\n\n\n匹配键\ntopic.*.*\ntopic.#\n\n\n\ntopic.order.id\ntrue\ntrue\n\n\norder.topic.id\nfalse\nfalse\n\n\ntopic.sm.order.id\nfalse\ntrue\n\n\ntopic.sm.id\nfalse\ntrue\n\n\ntopic.id.order\ntrue\ntrue\n\n\ntopic.id\nfalse\ntrue\n\n\ntopic.order\nfalse\ntrue\n\n\n步骤④：使用AmqpTemplate操作RabbitMQ\n@Service\npublic class MessageServiceRabbitmqTopicImpl implements MessageService &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(\"待发送短信的订单已纳入处理队列（rabbitmq topic），id：\"+id);\n        amqpTemplate.convertAndSend(\"topicExchange\",\"topic.orders.id\",id);\n    &#125;\n&#125;\n\n​\t\t发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。\n步骤⑤：使用消息监听器在服务器启动后，监听指定队列\n@Component\npublic class MessageListener &#123;\n    @RabbitListener(queues &#x3D; &quot;topic_queue&quot;)\n    public void receive(String id)&#123;\n        System.out.println(&quot;已完成短信发送业务(rabbitmq topic 1)，id：&quot;+id);\n    &#125;\n    @RabbitListener(queues &#x3D; &quot;topic_queue2&quot;)\n    public void receive2(String id)&#123;\n        System.out.println(&quot;已完成短信发送业务(rabbitmq topic 22222222)，id：&quot;+id);\n    &#125;\n&#125;\n\n​\t\t使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n总结\n\nspringboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列\n操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener\nRabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同\n\nSpringBoot整合RocketMQ​\t\tRocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。\n安装​\t\twindows版安装包下载地址：https://rocketmq.apache.org&#x2F;\n​\t\t下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件\n\n​\t\tRocketMQ安装后需要配置环境变量，具体如下：\n\nROCKETMQ_HOME\nPATH\nNAMESRV_ADDR （建议）： 127.0.0.1:9876\n\n​\t\t关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。\nRocketMQ工作模式\n​\t\t在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。\n\n\n启动服务器\nmqnamesrv\t\t# 启动命名服务器\nmqbroker\t\t# 启动broker\n\n​\t\t运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。\n​\t\t运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。\n测试服务器启动状态\n​\t\tRocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。\ntools org.apache.rocketmq.example.quickstart.Producer\t\t# 生产消息\ntools org.apache.rocketmq.example.quickstart.Consumer\t\t# 消费消息\n\n整合（异步消息）步骤①：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本\n&lt;dependency>\n    &lt;groupId>org.apache.rocketmq&lt;/groupId>\n    &lt;artifactId>rocketmq-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.2.1&lt;/version>\n&lt;/dependency>\n\n步骤②：配置RocketMQ的服务器地址\nrocketmq:\n  name-server: localhost:9876\n  producer:\n    group: group_rocketmq\n\n​\t\t设置默认的生产者消费者所属组group。\n步骤③：使用RocketMQTemplate操作RocketMQ\n@Service\npublic class MessageServiceRocketmqImpl implements MessageService &#123;\n    @Autowired\n    private RocketMQTemplate rocketMQTemplate;\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(\"待发送短信的订单已纳入处理队列（rocketmq），id：\"+id);\n        SendCallback callback = new SendCallback() &#123;\n            @Override\n            public void onSuccess(SendResult sendResult) &#123;\n                System.out.println(\"消息发送成功\");\n            &#125;\n            @Override\n            public void onException(Throwable e) &#123;\n                System.out.println(\"消息发送失败！！！！！\");\n            &#125;\n        &#125;;\n        rocketMQTemplate.asyncSend(\"order_id\",id,callback);\n    &#125;\n&#125;\n\n\n​\t\t使用asyncSend方法发送异步消息。\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Component\n@RocketMQMessageListener(topic &#x3D; &quot;order_id&quot;,consumerGroup &#x3D; &quot;group_rocketmq&quot;)\npublic class MessageListener implements RocketMQListener&lt;String&gt; &#123;\n    @Override\n    public void onMessage(String id) &#123;\n        System.out.println(&quot;已完成短信发送业务(rocketmq)，id：&quot;+id);\n    &#125;\n&#125;\n\n​\t\tRocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。\n​\t\t使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定组、指定名称的消息队列。\n总结\n\nspringboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列\n操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener\n\nSpringBoot整合Kafka安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;kafka.apache.org&#x2F;downloads\n​\t\t下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件\n\n​\t\t建议使用windows版2.8.1版本。\n启动服务器\n​\t\tkafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。\nzookeeper-server-start.bat ..\\..\\config\\zookeeper.properties\t\t# 启动zookeeper\nkafka-server-start.bat ..\\..\\config\\server.properties\t\t\t\t# 启动kafka\n\n​\t\t运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。\n​\t\t运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。\n创建主题\n​\t\t和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。\n# 创建topic\nkafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima\n# 查询topic\nkafka-topics.bat --zookeeper 127.0.0.1:2181 --list\t\t\t\t\t\n# 删除topic\nkafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima\n\n测试服务器启动状态\n​\t\tKafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。\nkafka-console-producer.bat --broker-list localhost:9092 --topic itheima\t\t\t\t\t\t\t# 测试生产消息\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning\t# 测试消息消费\n\n整合步骤①：导入springboot整合Kafka的starter，此坐标由springboot维护版本\n&lt;dependency>\n    &lt;groupId>org.springframework.kafka&lt;/groupId>\n    &lt;artifactId>spring-kafka&lt;/artifactId>\n&lt;/dependency>\n\n步骤②：配置Kafka的服务器地址\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    consumer:\n      group-id: order\n\n​\t\t设置默认的生产者消费者所属组id。\n步骤③：使用KafkaTemplate操作Kafka\n@Service\npublic class MessageServiceKafkaImpl implements MessageService &#123;\n    @Autowired\n    private KafkaTemplate&lt;String,String> kafkaTemplate;\n\n    @Override\n    public void sendMessage(String id) &#123;\n        System.out.println(\"待发送短信的订单已纳入处理队列（kafka），id：\"+id);\n        kafkaTemplate.send(\"itheima2022\",id);\n    &#125;\n&#125;\n\n​\t\t使用send方法发送消息，需要传入topic名称。\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Component\npublic class MessageListener &#123;\n    @KafkaListener(topics &#x3D; &quot;itheima2022&quot;)\n    public void onMessage(ConsumerRecord&lt;String,String&gt; record)&#123;\n        System.out.println(&quot;已完成短信发送业务(kafka)，id：&quot;+record.value());\n    &#125;\n&#125;\n\n​\t\t使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。\n总结\n\nspringboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列\n\n操作Kafka需要配置Kafka服务器地址，默认端口9092\n\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中\n\n\nKF-6.监控​\t\t在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。\n​\t\t什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。\n​\t\t本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。\nKF-6-1.监控的意义​\t\t对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是监控服务状态是否处理宕机状态。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，监控服务运行指标。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，监控程序运行日志。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，管理服务状态。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。\n​\t\t通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。\n\n\n​\t\t此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。\n\n\n​\t\t新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。\n\n\n​\t\t如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。\n\n\n​\t\t被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。\n​\t\t以上描述的整个过程就是一个监控系统的基本流程。\n总结\n\n监控是一个非常重要的工作，是保障程序正常运行的基础手段\n监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示\n被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控\n\n思考\n​\t\t下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。\nKF-6-2.可视化监控平台​\t\tspringboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为Spring Boot Admin。\n​\t\tSpring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。\n​\t\t下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。\n服务端开发\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n&lt;dependency>\n    &lt;groupId>de.codecentric&lt;/groupId>\n    &lt;artifactId>spring-boot-admin-starter-server&lt;/artifactId>\n    &lt;version>2.5.4&lt;/version>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\n​\t\t上述过程可以通过创建项目时使用勾选的形式完成。\n\n\n步骤②：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用\n@SpringBootApplication\n@EnableAdminServer\npublic class Springboot25AdminServerApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot25AdminServerApplication.class, args);\n    &#125;\n&#125;\n\n​\t\t做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。\n\n\n​\t\t由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。\n客户端开发\n​\t\t客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n&lt;dependency>\n    &lt;groupId>de.codecentric&lt;/groupId>\n    &lt;artifactId>spring-boot-admin-starter-client&lt;/artifactId>\n    &lt;version>2.5.4&lt;/version>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\n​\t\t上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。\n步骤②：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\n\n​\t\t做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。\n\n\n​\t\t可以看到，当前监控了1个程序，点击进去查看详细信息。\n\n\n​\t\t由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n开放指定信息给服务器看\n\n允许服务器以HTTP请求的方式获取对应的信息\n配置如下：\n\n\nserver:\n  port: 80\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n​\t\t上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。\n\n\n​\t\t但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n\n​\t\t健康明细信息如下：\n\n\n​\t\t目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。\nendpoints:\n  web:\n    exposure:\n      include: \"*\"\n\n​\t\t配置后再刷新服务器页面，就可以看到所有的信息了。\n\n\n​\t\t以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。\n配置多个客户端\n​\t\t可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。\n\n\n​\t\t进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n类加载面板中可以查阅到开发者自定义的类，如左图\n\n​                        \n\n映射中可以查阅到当前应用配置的所有请求\n\n​                        \n\n性能指标中可以查阅当前应用独有的请求路径统计数据\n\n​                        \n总结\n\n开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可\n开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n思考\n​\t\t之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。\nKF-6-3.监控原理​\t\t通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以&#x2F;actuator开头\n\n\n​\t\t首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n​\t\t通过发送请求，可以得到一组json信息，如下\n&#123;\n    \"_links\": &#123;\n        \"self\": &#123;\n            \"href\": \"http://localhost:81/actuator\",\n            \"templated\": false\n        &#125;,\n        \"beans\": &#123;\n            \"href\": \"http://localhost:81/actuator/beans\",\n            \"templated\": false\n        &#125;,\n        \"caches-cache\": &#123;\n            \"href\": \"http://localhost:81/actuator/caches/&#123;cache&#125;\",\n            \"templated\": true\n        &#125;,\n        \"caches\": &#123;\n            \"href\": \"http://localhost:81/actuator/caches\",\n            \"templated\": false\n        &#125;,\n        \"health\": &#123;\n            \"href\": \"http://localhost:81/actuator/health\",\n            \"templated\": false\n        &#125;,\n        \"health-path\": &#123;\n            \"href\": \"http://localhost:81/actuator/health/&#123;*path&#125;\",\n            \"templated\": true\n        &#125;,\n        \"info\": &#123;\n            \"href\": \"http://localhost:81/actuator/info\",\n            \"templated\": false\n        &#125;,\n        \"conditions\": &#123;\n            \"href\": \"http://localhost:81/actuator/conditions\",\n            \"templated\": false\n        &#125;,\n        \"shutdown\": &#123;\n            \"href\": \"http://localhost:81/actuator/shutdown\",\n            \"templated\": false\n        &#125;,\n        \"configprops\": &#123;\n            \"href\": \"http://localhost:81/actuator/configprops\",\n            \"templated\": false\n        &#125;,\n        \"configprops-prefix\": &#123;\n            \"href\": \"http://localhost:81/actuator/configprops/&#123;prefix&#125;\",\n            \"templated\": true\n        &#125;,\n        \"env\": &#123;\n            \"href\": \"http://localhost:81/actuator/env\",\n            \"templated\": false\n        &#125;,\n        \"env-toMatch\": &#123;\n            \"href\": \"http://localhost:81/actuator/env/&#123;toMatch&#125;\",\n            \"templated\": true\n        &#125;,\n        \"loggers\": &#123;\n            \"href\": \"http://localhost:81/actuator/loggers\",\n            \"templated\": false\n        &#125;,\n        \"loggers-name\": &#123;\n            \"href\": \"http://localhost:81/actuator/loggers/&#123;name&#125;\",\n            \"templated\": true\n        &#125;,\n        \"heapdump\": &#123;\n            \"href\": \"http://localhost:81/actuator/heapdump\",\n            \"templated\": false\n        &#125;,\n        \"threaddump\": &#123;\n            \"href\": \"http://localhost:81/actuator/threaddump\",\n            \"templated\": false\n        &#125;,\n        \"metrics-requiredMetricName\": &#123;\n            \"href\": \"http://localhost:81/actuator/metrics/&#123;requiredMetricName&#125;\",\n            \"templated\": true\n        &#125;,\n        \"metrics\": &#123;\n            \"href\": \"http://localhost:81/actuator/metrics\",\n            \"templated\": false\n        &#125;,\n        \"scheduledtasks\": &#123;\n            \"href\": \"http://localhost:81/actuator/scheduledtasks\",\n            \"templated\": false\n        &#125;,\n        \"mappings\": &#123;\n            \"href\": \"http://localhost:81/actuator/mappings\",\n            \"templated\": false\n        &#125;\n    &#125;\n&#125;\n\n​\t\t其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n&#123;\n    &quot;status&quot;: &quot;UP&quot;,\n    &quot;components&quot;: &#123;\n        &quot;diskSpace&quot;: &#123;\n            &quot;status&quot;: &quot;UP&quot;,\n            &quot;details&quot;: &#123;\n                &quot;total&quot;: 297042808832,\n                &quot;free&quot;: 72284409856,\n                &quot;threshold&quot;: 10485760,\n                &quot;exists&quot;: true\n            &#125;\n        &#125;,\n        &quot;ping&quot;: &#123;\n            &quot;status&quot;: &quot;UP&quot;\n        &#125;\n    &#125;\n&#125;\n\n​\t\t当前信息与监控面板中的数据存在着对应关系\n\n\n​\t\t原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以&#x2F;actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。\n​\t\t到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n​\t\t这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。\n​\t\tActuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**&#x2F;actuator可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求&#x2F;actuator&#x2F;端点名称**来获取详细信息。以下列出了所有端点信息说明：\n\n\n\nID\n描述\n默认启用\n\n\n\nauditevents\n暴露当前应用程序的审计事件信息。\n是\n\n\nbeans\n显示应用程序中所有 Spring bean 的完整列表。\n是\n\n\ncaches\n暴露可用的缓存。\n是\n\n\nconditions\n显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。\n是\n\n\nconfigprops\n显示所有 @ConfigurationProperties 的校对清单。\n是\n\n\nenv\n暴露 Spring ConfigurableEnvironment 中的属性。\n是\n\n\nflyway\n显示已应用的 Flyway 数据库迁移。\n是\n\n\nhealth\n显示应用程序健康信息\n是\n\n\nhttptrace\n显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求&#x2F;响应交换）。\n是\n\n\ninfo\n显示应用程序信息。\n是\n\n\nintegrationgraph\n显示 Spring Integration 图。\n是\n\n\nloggers\n显示和修改应用程序中日志记录器的配置。\n是\n\n\nliquibase\n显示已应用的 Liquibase 数据库迁移。\n是\n\n\nmetrics\n显示当前应用程序的指标度量信息。\n是\n\n\nmappings\n显示所有 @RequestMapping 路径的整理清单。\n是\n\n\nscheduledtasks\n显示应用程序中的调度任务。\n是\n\n\nsessions\n允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。\n是\n\n\nshutdown\n正常关闭应用程序。\n否\n\n\nthreaddump\n执行线程 dump。\n是\n\n\nheapdump\n返回一个 hprof 堆 dump 文件。\n是\n\n\njolokia\n通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。\n是\n\n\nlogfile\n返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。\n是\n\n\nprometheus\n以可以由 Prometheus 服务器抓取的格式暴露指标。\n是\n\n\n​\t\t上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\nmanagement:\n  endpoint:\n    health:\t\t\t\t\t\t# 端点名称\n      show-details: always\n    info:\t\t\t\t\t\t# 端点名称\n      enabled: true\t\t\t\t# 是否开放\n\n​\t\t为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\nmanagement:\n  endpoints:\n    enabled-by-default: true\t# 是否开启默认端点，默认值true\n\n​\t\t上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n\n​\t\t整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\nmanagement:\n  endpoint:\t\t# 具体端点的配置\n    health:\n      show-details: always\n    info:\n      enabled: true\n  endpoints:\t# 全部端点的配置\n    web:\n      exposure:\n        include: &quot;*&quot;\n    enabled-by-default: true\n\n总结\n\n被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n\n端点功能的开放与关闭可以通过配置进行控制\n\nweb端默认无法获取所有端点信息，通过配置开放端点功能\n\n\nKF-6-4.自定义监控指标​\t\t端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\nINFO端点\n​\t\tinfo端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n配置形式\n在yml文件中通过设置info节点的信息就可以快速配置端点信息\ninfo:\n  appName: @project.artifactId@\n  version: @project.version@\n  company: 传智教育\n  author: itheima\n\n配置完毕后，对应信息显示在监控平台上\n\n\n也可以通过请求端点信息路径获取对应json信息\n\n\n编程形式\n通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n@Component\npublic class InfoConfig implements InfoContributor &#123;\n    @Override\n    public void contribute(Info.Builder builder) &#123;\n        builder.withDetail(&quot;runTime&quot;,System.currentTimeMillis());\t\t&#x2F;&#x2F;添加单个信息\n        Map infoMap &#x3D; new HashMap();\t\t\n        infoMap.put(&quot;buildTime&quot;,&quot;2006&quot;);\n        builder.withDetails(infoMap);\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;添加一组信息\n    &#125;\n&#125;\n\nHealth端点\n​\t\thealth端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n@Component\npublic class HealthConfig extends AbstractHealthIndicator &#123;\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;\n        boolean condition &#x3D; true;\n        if(condition) &#123;\n            builder.status(Status.UP);\t\t\t\t\t&#x2F;&#x2F;设置运行状态为启动状态\n            builder.withDetail(&quot;runTime&quot;, System.currentTimeMillis());\n            Map infoMap &#x3D; new HashMap();\n            infoMap.put(&quot;buildTime&quot;, &quot;2006&quot;);\n            builder.withDetails(infoMap);\n        &#125;else&#123;\n            builder.status(Status.OUT_OF_SERVICE);\t\t&#x2F;&#x2F;设置运行状态为不在服务状态\n            builder.withDetail(&quot;上线了吗？&quot;,&quot;你做梦&quot;);\n        &#125;\n    &#125;\n&#125;\n\n​\t\t当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。\n\n\nMetrics端点\n​\t\tmetrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n@Service\npublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;\n    @Autowired\n    private BookDao bookDao;\n\n    private Counter counter;\n\n    public BookServiceImpl(MeterRegistry meterRegistry)&#123;\n        counter &#x3D; meterRegistry.counter(&quot;用户付费操作次数：&quot;);\n    &#125;\n\n    @Override\n    public boolean delete(Integer id) &#123;\n        &#x2F;&#x2F;每次执行删除业务等同于执行了付费业务\n        counter.increment();\n        return bookDao.deleteById(id) &gt; 0;\n    &#125;\n&#125;\n\n​\t\t在性能指标中就出现了自定义的性能指标监控项\n\n\n自定义端点\n​\t\t可以根据业务需要自定义端点，方便业务监控\n@Component\n@Endpoint(id&#x3D;&quot;pay&quot;,enableByDefault &#x3D; true)\npublic class PayEndpoint &#123;\n    @ReadOperation\n    public Object getPay()&#123;\n        Map payMap &#x3D; new HashMap();\n        payMap.put(&quot;level 1&quot;,&quot;300&quot;);\n        payMap.put(&quot;level 2&quot;,&quot;291&quot;);\n        payMap.put(&quot;level 3&quot;,&quot;666&quot;);\n        return payMap;\n    &#125;\n&#125;\n\n​\t\t由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n\n总结\n\n端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\ninfo端点通过配置和编程的方式都可以添加端点指标\nhealth端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\nmetrics指标通过在业务中添加监控操作设置指标\n可以自定义端点添加更多的指标\n\n开发实用篇完结​\t\t开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。\n​\t\t整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。\n​\t\t实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。\n​\t\t开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。\nSpringBoot原理篇​\t\t在学习前面三篇的时候，好多小伙伴一直在B站评论区嚷嚷着期待原理篇，今天可以正式的宣布了，他来了他来了他脚踏祥云进来了（此处请自行脑补BGM）。\n​\t\t其实从本人的角度出发，看了这么多学习java的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，先应用熟练，培养技术应用的条件反射，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， 原理真不是看源码，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如spirng程序，写起来很费劲，springboot出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。\n​\t\tspringboot技术本身就是为了加速spring程序的开发的，可以大胆的说，springboot技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将springboot定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是spirngboot的原理。没有的事，springboot作为一款工具，压根就没有原理。我们下面要学习的其实就是spirngboot程序的工作流程。\n​\t\t下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：\n\n自动配置工作流程\n自定义starter开发\nspringboot程序启动流程\n\n​\t\t下面开启第一部分自动配置工作流程的学习\nYL-1.自动配置工作流程​\t\t自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。\nYL-1-1.bean的加载方式​\t\t关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。\nhttps:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1P44y1N7QG\n\n方式一：配置文件+&lt;bean/&gt;标签​\t\t最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;!--xml方式声明自己开发的bean--&gt;\n    &lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;Cat&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;Dog&quot;&#x2F;&gt;\n\n    &lt;!--xml方式声明第三方开发的bean--&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&#x2F;&gt;\n    &lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n方式二：配置文件扫描+注解定义bean​\t\t由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。\n@Component(&quot;tom&quot;)\npublic class Cat &#123;\n&#125;\n\n@Service\npublic class Mouse &#123;\n&#125;\n\n​\t\t当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。\n@Component\npublic class DbConfig &#123;\n    @Bean\n    public DruidDataSource dataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        return ds;\n    &#125;\n&#125;\n\n​\t\t上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n    &quot;&gt;\n    &lt;!--指定扫描加载bean的位置--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.itheima.bean,com.itheima.config&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n​\t\t方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。\n方式三：注解方式声明配置类​\t\t方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。\n​\t\t定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。\n@ComponentScan(&#123;\"com.itheima.bean\",\"com.itheima.config\"&#125;)\npublic class SpringConfig3 &#123;\n    @Bean\n    public DogFactoryBean dog()&#123;\n        return new DogFactoryBean();\n    &#125;\n&#125;\n\n使用FactroyBean接口​\t\t补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。\npublic class DogFactoryBean implements FactoryBean&lt;Dog&gt; &#123;\n    @Override\n    public Dog getObject() throws Exception &#123;\n        Dog d &#x3D; new Dog();\n        &#x2F;&#x2F;.........\n        return d;\n    &#125;\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return Dog.class;\n    &#125;\n    @Override\n    public boolean isSingleton() &#123;\n        return true;\n    &#125;\n&#125;\n\n​\t\t有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。\n​\t\t通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。\n@ComponentScan(&#123;\"com.itheima.bean\",\"com.itheima.config\"&#125;)\npublic class SpringConfig3 &#123;\n    @Bean\n    public DogFactoryBean dog()&#123;\n        return new DogFactoryBean();\n    &#125;\n&#125;\n\n注解格式导入XML格式配置的bean​\t\t再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n@Configuration\n@ImportResource(&quot;applicationContext1.xml&quot;)\npublic class SpringConfig32 &#123;\n&#125;\n\nproxyBeanMethods属性​\t\t前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n@Configuration(proxyBeanMethods &#x3D; true)\npublic class SpringConfig33 &#123;\n    @Bean\n    public Cat cat()&#123;\n        return new Cat();\n    &#125;\n&#125;\n\n​\t\t下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。\npublic class App33 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig33.class);\n        String[] names &#x3D; ctx.getBeanDefinitionNames();\n        for (String name : names) &#123;\n            System.out.println(name);\n        &#125;\n        System.out.println(&quot;-------------------------&quot;);\n        SpringConfig33 springConfig33 &#x3D; ctx.getBean(&quot;springConfig33&quot;, SpringConfig33.class);\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n    &#125;\n&#125;\n\n方式四：使用@Import注解注入bean​\t\t使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。\n​\t\t有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。\n​\t\t所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。\n@Import(&#123;Dog.class,DbConfig.class&#125;)\npublic class SpringConfig4 &#123;\n&#125;\n\n使用@Import注解注入配置类​\t\t除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。\n@Import(DogFactoryBean.class)\npublic class SpringConfig4 &#123;\n&#125;\n\n方式五：编程形式注册bean​\t\t前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\npublic class App5 &#123;\n    public static void main(String[] args) &#123;\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.register(Mouse.class);\n    &#125;\n&#125;\n\n​\t\t其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。\npublic class App5 &#123;\n    public static void main(String[] args) &#123;\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.registerBean(\"tom\", Cat.class,0);\n        ctx.registerBean(\"tom\", Cat.class,1);\n        ctx.registerBean(\"tom\", Cat.class,2);\n        System.out.println(ctx.getBean(Cat.class));\n    &#125;\n&#125;\n\n方式六：导入实现了ImportSelector接口的类​\t\t在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。\n​\t\t现在又多了一种控制bean加载的方式，或者说是选择bean的方式。\npublic class MyImportSelector implements ImportSelector &#123;\n    @Override\n    public String[] selectImports(AnnotationMetadata metadata) &#123;\n        //各种条件的判定，判定完毕后，决定是否装载指定的bean\n        boolean flag = metadata.hasAnnotation(\"org.springframework.context.annotation.Configuration\");\n        if(flag)&#123;\n            return new String[]&#123;\"com.itheima.bean.Dog\"&#125;;\n        &#125;\n        return new String[]&#123;\"com.itheima.bean.Cat\"&#125;;\n    &#125;\n&#125;\n\n\n方式七：导入实现了ImportBeanDefinitionRegistrar接口的类​\t\t方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。\npublic class MyRegistrar implements ImportBeanDefinitionRegistrar &#123;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;\n        BeanDefinition beanDefinition = \t\n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    &#125;\n&#125;\n\n方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类​\t\t上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。\n​\t\tspring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。\npublic class MyPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;\n        BeanDefinition beanDefinition = \n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    &#125;\n&#125;\n\n\n​\t\t总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。\n总结\n\nbean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean\n@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载\nspring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean\n\nYL-1-2.bean的加载控制​\t\t前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。\n​\t\t企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。\npublic class MyImportSelector implements ImportSelector &#123;\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;\n        try &#123;\n            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.itheima.bean.Mouse&quot;);\n            if(clazz !&#x3D; null) &#123;\n                return new String[]&#123;&quot;com.itheima.bean.Cat&quot;&#125;;\n            &#125;\n        &#125; catch (ClassNotFoundException e) &#123;\n&#x2F;&#x2F;            e.printStackTrace();\n            return new String[0];\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n​\t\t通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。\n​\t\t下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。\n@Bean\n@ConditionalOnClass(name = \"com.itheima.bean.Wolf\")\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t@ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。\n@Bean\n@ConditionalOnMissingClass(\"com.itheima.bean.Dog\")\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n@Bean\n@ConditionalOnClass(name = \"com.itheima.bean.Wolf\")\n@ConditionalOnMissingClass(\"com.itheima.bean.Mouse\")\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。\n@Bean\n@ConditionalOnWebApplication\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t下面是判定容器环境是否是非web环境。\n@Bean\n@ConditionalOnNotWebApplication\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？\n@Bean\n@ConditionalOnBean(name=\"jerry\")\npublic Cat tom()&#123;\n    return new Cat();\n&#125;\n\n​\t\t以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！\npublic class SpringConfig &#123;\n    @Bean\n    @ConditionalOnClass(name&#x3D;&quot;com.mysql.jdbc.Driver&quot;)\n    public DruidDataSource dataSource()&#123;\n        return new DruidDataSource();\n    &#125;\n&#125;\n\n​\t\t其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。\n总结\n\nspringboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\nYL-1-3.bean的依赖属性配置管理​\t\tbean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n\n​\t\t然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n@ConfigurationProperties(prefix &#x3D; &quot;cartoon&quot;)\n@Data\npublic class CartoonProperties &#123;\n    private Cat cat;\n    private Mouse mouse;\n&#125;\n\n​\t\t最后在使用的位置注入对应的配置即可。\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse&#123;\n    @Autowired\n    private CartoonProperties cartoonProperties;\n&#125;\n\n​\t\t建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。\n总结\n\nbean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties\n设置属性类加载指定前缀的配置信息\n在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。\n\nYL-1-4.自动配置原理（工作流程）​\t\t经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。\n​\t\t啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。\n​\t\t自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。\n​\t\t而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：\n​\t\t阶段一：准备阶段\n\nspringboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个技术集A\n\n收集常用技术(技术集A)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的设置集B\n阶段二：加载阶段\n\nspringboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成初始化环境\n\nspringboot将技术集A包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n\nspringboot会对技术集A中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与初始化环境，这个时候就可以根据这个初始化环境与springboot的技术集A进行比对了，哪个匹配上加载哪个\n\n因为有些技术不做配置就无法工作，所以springboot开始对设置集B下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量\n\n但是默认配置不一定能解决问题，于是springboot开放修改设置集B的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n\n​\t\t以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的技术集A\n\npublic class CartoonCatAndMouse&#123;\n&#125;\n\n\n然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的设置集B\n\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n\n\n将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n@ConfigurationProperties(prefix &#x3D; &quot;cartoon&quot;)\n@Data\npublic class CartoonProperties &#123;\n    private Cat cat;\n    private Mouse mouse;\n&#125;\n\n\n最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware &#123;\n    private CartoonProperties cartoonProperties;\n&#125;\n\n\n当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件\n\n@ConditionalOnClass(name&#x3D;&quot;org.springframework.data.redis.core.RedisOperations&quot;)\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware &#123;\n    private CartoonProperties cartoonProperties;\n&#125;\n\n​\t\t做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\ncom.itheima.bean.CartoonCatAndMouse\n\n​\t\t其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n自动配置从根本上来说就是一个bean的加载\n通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\nspringboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n​\t\t你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n​\t\t以上内容是自动配置的工作流程。\n总结\n\nspringboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean\n在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置\n配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\nYL-1-5.变更自动配置​\t\t知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：\n方式一：通过yaml配置设置排除指定的自动配置类\nspring:\n  autoconfigure:\n    exclude:\n      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\n\n方式二：通过注解参数排除自动配置类\n@EnableAutoConfiguration(excludeName &#x3D; &quot;&quot;,exclude &#x3D; &#123;&#125;)\n\n方式三：排除坐标（应用面较窄）\n如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;exclusion&gt;\n        &lt;&#x2F;exclusions&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n总结\n\nspringboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能\n\nYL-2.自定义starter开发​\t\t自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。\nYL-2-1.案例：记录系统访客独立IP访问次数​\t\t本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n​\t\t例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n         IP访问监控\n+-----ip-address-----+--num--+\n|     192.168.0.135  |   15  |\n|     61.129.65.248  |   20  |\n+--------------------+-------+\n\n​\t\t在进行具体制作之前，先对功能做具体的分析\n\n数据记录在什么位置\n最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。\n\n统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n\n为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。\n\n输出频度，默认10秒\n数据特征：累计数据 &#x2F; 阶段数据，默认累计数据\n输出格式：详细模式 &#x2F; 极简模式\n\n\n\n​\t\t在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\nYL-2-2.IP计数业务功能开发（自定义starter）​\t\t本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n步骤一：创建全新的模块，定义业务功能类\n​\t\t功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数\npublic class IpCountService &#123;\n    private Map&lt;String,Integer&gt; ipCountMap &#x3D; new HashMap&lt;String,Integer&gt;();\n&#125;\n\n​\t\t有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n步骤二：制作统计功能\n​\t\t制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\npublic class IpCountService &#123;\n    private Map&lt;String,Integer&gt; ipCountMap &#x3D; new HashMap&lt;String,Integer&gt;();\n    public void count()&#123;\n        &#x2F;&#x2F;每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        &#x2F;&#x2F;1.获取当前操作的IP地址\n        String ip &#x3D; null;\n        &#x2F;&#x2F;2.根据IP地址从Map取值，并递增\n        Integer count &#x3D; ipCountMap.get(ip);\n        if(count &#x3D;&#x3D; null)&#123;\n            ipCountMap.put(ip,1);\n        &#125;else&#123;\n            ipCountMap.put(ip,count + 1);\n        &#125;\n    &#125;\n&#125;\n\n​\t\t因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。\npublic class IpCountService &#123;\n    private Map&lt;String,Integer&gt; ipCountMap &#x3D; new HashMap&lt;String,Integer&gt;();\n    @Autowired\n    &#x2F;&#x2F;当前的request对象的注入工作由使用当前starter的工程提供自动装配\n    private HttpServletRequest httpServletRequest;\n    public void count()&#123;\n        &#x2F;&#x2F;每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        &#x2F;&#x2F;1.获取当前操作的IP地址\n        String ip &#x3D; httpServletRequest.getRemoteAddr();\n        &#x2F;&#x2F;2.根据IP地址从Map取值，并递增\n        Integer count &#x3D; ipCountMap.get(ip);\n        if(count &#x3D;&#x3D; null)&#123;\n            ipCountMap.put(ip,1);\n        &#125;else&#123;\n            ipCountMap.put(ip,count + 1);\n        &#125;\n    &#125;\n&#125;\n\n步骤三：定义自动配置类\n​\t\t我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\npublic class IpAutoConfiguration &#123;\n    @Bean\n    public IpCountService ipCountService()&#123;\n        return new IpCountService();\n    &#125;\n&#125;\n\n​\t\t自动配置类需要在spring.factories文件中做配置方可自动运行。\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.itcast.autoconfig.IpAutoConfiguration\n\n步骤四：在原始项目中模拟调用，测试功能\n​\t\t原始调用项目中导入当前开发的starter\n&lt;dependency&gt;\n    &lt;groupId&gt;cn.itcast&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;ip_spring_boot_starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n​\t\t推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n    @Autowired\n    private IpCountService ipCountService;\n    @GetMapping(&quot;&#123;currentPage&#125;&#x2F;&#123;pageSize&#125;&quot;)\n    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book)&#123;\n        ipCountService.count();\n        IPage&lt;Book&gt; page &#x3D; bookService.getPage(currentPage, pageSize,book);\n        if( currentPage &gt; page.getPages())&#123;\n            page &#x3D; bookService.getPage((int)page.getPages(), pageSize,book);\n        &#125;\n        return new R(true, page);\n    &#125;\n&#125;\n\n温馨提示\n​\t\t由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！\n当前效果\n​\t\t每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。\nYL-2-3.定时任务报表开发​\t\t当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。\n步骤一：开启定时任务功能\n​\t\t定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n@EnableScheduling\npublic class IpAutoConfiguration &#123;\n    @Bean\n    public IpCountService ipCountService()&#123;\n        return new IpCountService();\n    &#125;\n&#125;\n\n步骤二：制作显示统计数据功能\n​\t\t定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\npublic class IpCountService &#123;\n    private Map&lt;String,Integer&gt; ipCountMap &#x3D; new HashMap&lt;String,Integer&gt;();\n    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)\n    public void print()&#123;\n        System.out.println(&quot;         IP访问监控&quot;);\n        System.out.println(&quot;+-----ip-address-----+--num--+&quot;);\n        for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;\n            String key &#x3D; entry.getKey();\n            Integer value &#x3D; entry.getValue();\n            System.out.println(String.format(&quot;|%18s  |%5d  |&quot;,key,value));\n        &#125;\n        System.out.println(&quot;+--------------------+-------+&quot;);\n      &#125;\n&#125;\n\n​\t\t其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\nYL-2-4.使用属性配置设置功能参数​\t\t由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n步骤一：定义参数格式\n​\t\t设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）\ntools:\n  ip:\n    cycle: 10\n    cycleReset: false\n    model: &quot;detail&quot;\n\n步骤二：定义封装参数的属性类，读取配置参数\n​\t\t为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n​\t\t日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n@ConfigurationProperties(prefix &#x3D; &quot;tools.ip&quot;)\npublic class IpProperties &#123;\n    &#x2F;**\n     * 日志显示周期\n     *&#x2F;\n    private Long cycle &#x3D; 5L;\n    &#x2F;**\n     * 是否周期内重置数据\n     *&#x2F;\n    private Boolean cycleReset &#x3D; false;\n    &#x2F;**\n     * 日志输出模式  detail：详细模式  simple：极简模式\n     *&#x2F;\n    private String model &#x3D; LogModel.DETAIL.value;\n    public enum LogModel&#123;\n        DETAIL(&quot;detail&quot;),\n        SIMPLE(&quot;simple&quot;);\n        private String value;\n        LogModel(String value) &#123;\n            this.value &#x3D; value;\n        &#125;\n        public String getValue() &#123;\n            return value;\n        &#125;\n    &#125;\n&#125;\n\n步骤三：加载属性类\n@EnableScheduling\n@EnableConfigurationProperties(IpProperties.class)\npublic class IpAutoConfiguration &#123;\n    @Bean\n    public IpCountService ipCountService()&#123;\n        return new IpCountService();\n    &#125;\n&#125;\n\n步骤四：应用配置属性\n​\t\t在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n​\t\t注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\npublic class IpCountService &#123;\n    private Map&lt;String,Integer&gt; ipCountMap &#x3D; new HashMap&lt;String,Integer&gt;();\n    @Autowired\n    private IpProperties ipProperties;\n    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)\n    public void print()&#123;\n        if(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue()))&#123;\n            System.out.println(&quot;         IP访问监控&quot;);\n            System.out.println(&quot;+-----ip-address-----+--num--+&quot;);\n            for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;\n                String key &#x3D; entry.getKey();\n                Integer value &#x3D; entry.getValue();\n                System.out.println(String.format(&quot;|%18s  |%5d  |&quot;,key,value));\n            &#125;\n            System.out.println(&quot;+--------------------+-------+&quot;);\n        &#125;else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue()))&#123;\n            System.out.println(&quot;     IP访问监控&quot;);\n            System.out.println(&quot;+-----ip-address-----+&quot;);\n            for (String key: ipCountMap.keySet()) &#123;\n                System.out.println(String.format(&quot;|%18s  |&quot;,key));\n            &#125;\n            System.out.println(&quot;+--------------------+&quot;);\n        &#125;\n        &#x2F;&#x2F;阶段内统计数据归零\n        if(ipProperties.getCycleReset())&#123;\n            ipCountMap.clear();\n        &#125;\n    &#125;\n&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\nYL-2-5.使用属性配置设置定时器参数​\t\t在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。\n步骤一：@Scheduled注解使用#{}读取bean属性值\n​\t\t此处读取bean名称为ipProperties的bean的cycle属性值\n@Scheduled(cron &#x3D; &quot;0&#x2F;#&#123;ipProperties.cycle&#125; * * * * ?&quot;)\npublic void print()&#123;\n&#125;\n\n步骤二：属性类定义bean并指定bean的访问名称\n​\t\t如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n@Component(&quot;ipProperties&quot;)\n@ConfigurationProperties(prefix &#x3D; &quot;tools.ip&quot;)\npublic class IpProperties &#123;\n&#125;\n\n步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类\n@EnableScheduling\n&#x2F;&#x2F;@EnableConfigurationProperties(IpProperties.class)\n@Import(IpProperties.class)\npublic class IpAutoConfiguration &#123;\n    @Bean\n    public IpCountService ipCountService()&#123;\n        return new IpCountService();\n    &#125;\n&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\nYL-2-6.拦截器开发​\t\t基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中\n步骤一：开发拦截器\n​\t\t使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\npublic class IpCountInterceptor implements HandlerInterceptor &#123;\n    @Autowired\n    private IpCountService ipCountService;\n    @Override\n    public boolean preHandle(HttpServletRequest request, \n                             HttpServletResponse response, Object handler) throws Exception &#123;\n        ipCountService.count();\n        return true;\n    &#125;\n&#125;\n\n步骤二：配置拦截器\n​\t\t配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer &#123;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n    @Bean\n    public IpCountInterceptor ipCountInterceptor()&#123;\n        return new IpCountInterceptor();\n    &#125;\n&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n​\t\t到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。\nYL-2-7.功能性完善——开启yml提示功能​\t\t我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。\n​\t\tspringboot提供有专用的工具实现此功能，仅需要导入下列坐标。\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-configuration-processor&lt;/artifactId>\n    &lt;optional>true&lt;/optional>\n&lt;/dependency>\n\n​\t\t程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。\n&#123;\n  &quot;groups&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;tools.ip&quot;,\n      &quot;type&quot;: &quot;cn.itcast.properties.IpProperties&quot;,\n      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;\n    &#125;\n  ],\n  &quot;properties&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;tools.ip.cycle&quot;,\n      &quot;type&quot;: &quot;java.lang.Long&quot;,\n      &quot;description&quot;: &quot;日志显示周期&quot;,\n      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;,\n      &quot;defaultValue&quot;: 5\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;tools.ip.cycle-reset&quot;,\n      &quot;type&quot;: &quot;java.lang.Boolean&quot;,\n      &quot;description&quot;: &quot;是否周期内重置数据&quot;,\n      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;,\n      &quot;defaultValue&quot;: false\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;tools.ip.model&quot;,\n      &quot;type&quot;: &quot;java.lang.String&quot;,\n      &quot;description&quot;: &quot;日志输出模式  detail：详细模式  simple：极简模式&quot;,\n      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;\n    &#125;\n  ],\n  &quot;hints&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;tools.ip.model&quot;,\n      &quot;values&quot;: [\n        &#123;\n          &quot;value&quot;: &quot;detail&quot;,\n          &quot;description&quot;: &quot;详细模式.&quot;\n        &#125;,\n        &#123;\n          &quot;value&quot;: &quot;simple&quot;,\n          &quot;description&quot;: &quot;极简模式.&quot;\n        &#125;\n      ]\n    &#125;\n  ]\n&#125;\n\n总结\n\n自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\nYL-3.SpringBoot程序启动流程解析​\t\t原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。\n​\t\t其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。\n​\t\tspringboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n环境属性（Environment）\n系统配置（spring.factories）\n参数（Arguments、application.properties）\n\n​\t\t以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\nSpringboot30StartupApplication【10】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);\n    SpringApplication【1332】-&gt;return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);\n        SpringApplication【1343】-&gt;return new SpringApplication(primarySources).run(args);\n            SpringApplication【1343】-&gt;SpringApplication(primarySources)\n            # 加载各种配置信息，初始化各种配置对象\n                SpringApplication【266】-&gt;this(null, primarySources);\n                    SpringApplication【280】-&gt;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)\n                        SpringApplication【281】-&gt;this.resourceLoader &#x3D; resourceLoader;\n                        # 初始化资源加载器\n                        SpringApplication【283】-&gt;this.primarySources &#x3D; new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));\n                        # 初始化配置类的类名信息（格式转换）\n                        SpringApplication【284】-&gt;this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();\n                        # 确认当前容器加载的类型\n                        SpringApplication【285】-&gt;this.bootstrapRegistryInitializers &#x3D; getBootstrapRegistryInitializersFromSpringFactories();\n                        # 获取系统配置引导信息\n                        SpringApplication【286】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n                        # 获取ApplicationContextInitializer.class对应的实例\n                        SpringApplication【287】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n                        # 初始化监听器，对初始化过程及运行过程进行干预\n                        SpringApplication【288】-&gt;this.mainApplicationClass &#x3D; deduceMainApplicationClass();\n                        # 初始化了引导类类名信息，备用\n            SpringApplication【1343】-&gt;new SpringApplication(primarySources).run(args)\n            # 初始化容器，得到ApplicationContext对象\n                SpringApplication【323】-&gt;StopWatch stopWatch &#x3D; new StopWatch();\n                # 设置计时器\n                SpringApplication【324】-&gt;stopWatch.start();\n                # 计时开始\n                SpringApplication【325】-&gt;DefaultBootstrapContext bootstrapContext &#x3D; createBootstrapContext();\n                # 系统引导信息对应的上下文对象\n                SpringApplication【327】-&gt;configureHeadlessProperty();\n                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）\n                    java.awt.headless&#x3D;true\n                SpringApplication【328】-&gt;SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);\n                # 获取当前注册的所有监听器\n                SpringApplication【329】-&gt;listeners.starting(bootstrapContext, this.mainApplicationClass);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【331】-&gt;ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);\n                # 获取参数\n                SpringApplication【333】-&gt;ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n                # 将前期读取的数据加载成了一个环境对象，用来描述信息\n                SpringApplication【333】-&gt;configureIgnoreBeanInfo(environment);\n                # 做了一个配置，备用\n                SpringApplication【334】-&gt;Banner printedBanner &#x3D; printBanner(environment);\n                # 初始化logo\n                SpringApplication【335】-&gt;context &#x3D; createApplicationContext();\n                # 创建容器对象，根据前期配置的容器类型进行判定并创建\n                SpringApplication【363】-&gt;context.setApplicationStartup(this.applicationStartup);\n                # 设置启动模式\n                SpringApplication【337】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n                # 对容器进行设置，参数来源于前期的设定\n                SpringApplication【338】-&gt;refreshContext(context);\n                # 刷新容器环境\n                SpringApplication【339】-&gt;afterRefresh(context, applicationArguments);\n                # 刷新完毕后做后处理\n                SpringApplication【340】-&gt;stopWatch.stop();\n                # 计时结束\n                SpringApplication【341】-&gt;if (this.logStartupInfo) &#123;\n                # 判定是否记录启动时间的日志\n                SpringApplication【342】-&gt;    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n                # 创建日志对应的对象，输出日志信息，包含启动时间\n                SpringApplication【344】-&gt;listeners.started(context);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【345】-&gt;callRunners(context, applicationArguments);\n                # 调用运行器\n                SpringApplication【353】-&gt;listeners.running(context);\n                # 监听器执行了对应的操作步骤\n\n​\t\t上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？\n​\t\t遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\npublic class Abc implements InitializingBean, DisposableBean &#123;\n    public void destroy() throws Exception &#123;\n        &#x2F;&#x2F;销毁操作\n    &#125;\n    public void afterPropertiesSet() throws Exception &#123;\n        &#x2F;&#x2F;初始化操作\n    &#125;\n&#125;\n\n​\t\tspringboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。\n​\t\tspringboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\norg.springframework.boot.context.event.ApplicationStartingEvent\n应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent\n\n\norg.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\n环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent\n\n\norg.springframework.boot.context.event.ApplicationContextInitializedEvent\n上下文初始化事件\n\n\norg.springframework.boot.context.event.ApplicationPreparedEvent\n应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent\n\n\norg.springframework.context.event.ContextRefreshedEvent\n上下文刷新事件\n\n\norg.springframework.boot.context.event.ApplicationStartedEvent\n应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent\n\n\norg.springframework.boot.context.event.ApplicationReadyEvent\n应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求\n\n\norg.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）\n\n​\t\t上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。\n&#x2F;&#x2F;设定监听器，在应用启动开始事件时进行功能追加\npublic class MyListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;\n    public void onApplicationEvent(ApplicationStartingEvent event) &#123;\n\t\t&#x2F;&#x2F;自定义事件处理逻辑\n    &#125;\n&#125;\n\n​\t\t按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n总结\n\nspringboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码\n\n原理篇完结​\t\t原理篇到这里就要结束了，springboot2整套课程的基础篇、实用篇和原理篇就全部讲完了。至于后面的番外篇由于受B站视频上传总量不得超过200个视频的约束，番外篇的内容不会在当前课程中发布了，会重新定义一个课程继续发布，至于具体时间，暂时还无法给到各位小伙伴。\n​\t\t原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到reflush方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将spring的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，( ´•︵•&#96; )\n​\t\t课程做到这里就要和各位小伙伴先say顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于IT研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。\n​\t\t番外篇，さようなら！ 안녕히 계십시오！แล้วเจอกัน！До свидания ！خداحافظ ！\n","slug":"SringBoot","date":"2022-10-17T04:00:00.000Z","categories_index":"java,框架,spring","tags_index":"java,框架,spring","author_index":"Leixng"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"SpringMVC教程一、什么是SpringMVC【Spring Web MVC】是最初建立在 Servlet API 之上的 Web 框架，从一开始就包含在【Spring Framework】中。正式名称【Spring Web MVC】来自其源模块的名称 ( spring-webmvc)，但它更常被称为【Spring MVC】。\n\n\n\n\n\n\n\n\n\nMVC 设计概述\n回顾mvc：\n1、mvc的发展历程\n\n\n\n\n\n\n\n\n我们之前学习的mvc模式就是这种【Servlet + JSP + Java Bean】 模式，早期的 MVC 模型如下图所示：\n\n首先用户的请求会到达 Servlet，然后根据请求调用相应的 JavaBean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式：\n\nM 代表 模型（Model）模型是什么呢？ 完成具体的业务，进行数据的查询。\n\nV 代表 视图（View）视图是什么呢？ 就是用来做展示的，比如我们学过的JSP技术，用来展示模型中的数据。\n\nC 代表 控制器（controller)\n控制器是什么？ 控制器的作用就是搜集页面传来的原始数据，或者调用模型获得数据交给视图层处理，Servlet 扮演的就是这样的角色。\n\n\n\n\n\n\n\n\n\n\n\nSpring MVC 的架构\nSpring MVC 给出了自己的mvc方案：\n\n传统的模型层被拆分为了业务层（Service）和数据访问层（DAO,Data Access Object）。同时，在 Service层下可以通过 Spring 的声明式事务操作数据访问层。\nspring的mvc有以下特点：\n\n结构松散，几乎可以在 Spring MVC 中使用各类视图，不仅仅是jsp。\n松耦合，各个模块分离\n与 Spring 无缝集成\n\n\n\n\n\n\n\n\n\n\n现在使用springmvc的公司越来越多，已经成为了霸主地位，基本上取代了早年的struts2，但是我们不能否仍依然有一些公司在使用老的框架，但是触类旁通，希望有大家可以去自行了解。\n二、直接上代码1、创建基础web工程\n\n\n\n\n\n\n\n\n创建工程\n\n\n\n\n\n\n\n\n\n\n完善一个webapp工程所必备的目录：\n\n\n\n\n\n\n\n\n\n\n添加一个最小的必须依赖\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;groupId>com.ydlclass&lt;/groupId>\n    &lt;artifactId>spring-mvc-stduy&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n\n    &lt;properties>\n        &lt;maven.compiler.source>11&lt;/maven.compiler.source>\n        &lt;maven.compiler.target>11&lt;/maven.compiler.target>\n    &lt;/properties>\n\n    &lt;dependencies>\n        &lt;!--servlet api-->\n        &lt;dependency>\n            &lt;groupId>javax.servlet&lt;/groupId>\n            &lt;artifactId>javax.servlet-api&lt;/artifactId>\n            &lt;version>4.0.1&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n                &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n                &lt;version>3.1&lt;/version>\n                &lt;configuration>\n                    &lt;target>$&#123;maven.compiler.target&#125;&lt;/target>\n                    &lt;source>$&#123;maven.compiler.source&#125;&lt;/source>\n                    &lt;encoding>utf-8&lt;/encoding>\n                &lt;/configuration>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n&lt;/project>\n\n\n\n\n\n\n\n\n\n\n构建web项目:\n\n\n\n\n\n\n\n\n\n\nweb.xml模板：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n&lt;/web-app>\n\n\n\n\n\n\n\n\n\n\n配置tomcat，推荐使用tomcat9：\n\n\n\n\n\n\n\n\n\n\n部署项目\n\n\n\n\n\n\n\n\n\n\n启动tomcat\n\n\n\n\n\n\n\n\n\n\n写一个setvlet进行测试\n@WebServlet(\"/test\")\npublic class TestServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;\n        try &#123;\n            resp.getWriter().println(\"hello servlet!!\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n在浏览器中进行测试，web项目构建成功：\n\n2、搭建springmvc环境（1）首先完整的pom&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;groupId>com.ydlclass&lt;/groupId>\n    &lt;artifactId>spring-mvc-stduy&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n\n    &lt;properties>\n        &lt;maven.compiler.source>11&lt;/maven.compiler.source>\n        &lt;maven.compiler.target>11&lt;/maven.compiler.target>\n    &lt;/properties>\n\n    &lt;dependencies>\n        &lt;!--servlet api-->\n        &lt;dependency>\n            &lt;groupId>javax.servlet&lt;/groupId>\n            &lt;artifactId>javax.servlet-api&lt;/artifactId>\n            &lt;version>4.0.1&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n        &lt;!--springmvc的依赖，会自动传递spring的其他依赖 -->\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-webmvc&lt;/artifactId>\n            &lt;version>5.2.18.RELEASE&lt;/version>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;!--编译插件-->\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n                &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n                &lt;version>3.1&lt;/version>\n                &lt;configuration>\n                    &lt;target>$&#123;maven.compiler.target&#125;&lt;/target>\n                    &lt;source>$&#123;maven.compiler.source&#125;&lt;/source>\n                    &lt;encoding>utf-8&lt;/encoding>\n                &lt;/configuration>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n&lt;/project>\n\n（2）配置web.xml\n\n\n\n\n\n\n\n\n注册一个叫DispatcherServlet的servlet，这玩意是spring给我们提供的，我们先复制，后边会细讲：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    &lt;!--配置一个ContextLoaderListener，他会在servlet容器启动时帮我们初始化spring容器-->\n    &lt;listener>\n        &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class>\n    &lt;/listener>\n\n    &lt;!--指定启动spring容器的配置文件-->\n    &lt;context-param>\n        &lt;param-name>contextConfigLocation&lt;/param-name>\n        &lt;param-value>/WEB-INF/app-context.xml&lt;/param-value>\n    &lt;/context-param>\n\n    &lt;!--注册DispatcherServlet，这是springmvc的核心-->\n    &lt;servlet>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n        &lt;init-param>\n            &lt;param-name>contextConfigLocation&lt;/param-name>\n            &lt;param-value>WEB-INF/app-context.xml&lt;/param-value>\n        &lt;/init-param>\n        &lt;!--加载时先启动-->\n        &lt;load-on-startup>1&lt;/load-on-startup>\n    &lt;/servlet>\n    &lt;!--/ 匹配所有的请求；（不包括.jsp）-->\n    &lt;!--/* 匹配所有的请求；（包括.jsp）-->\n    &lt;servlet-mapping>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;url-pattern>/&lt;/url-pattern>\n    &lt;/servlet-mapping>\n&lt;/web-app>\n\n（3）编写配置文件\n\n\n\n\n\n\n\n\n名称：app-context.xml  (其实就是个spring和springmvc共享的配置文件) ，我们可以建立在&#x2F;WEB-INF&#x2F;目录下：\n小知识：在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问，必须通过请求转发。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;!-- 处理映射器 -->\n    &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n    &lt;!-- 处理器适配器 -->\n    &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n    &lt;!-- 视图解析器 -->\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n        &lt;!--前缀-->\n        &lt;property name=\"prefix\" value=\"/WEB-INF/page/\"/>\n        &lt;!--后缀-->\n        &lt;property name=\"suffix\" value=\".jsp\"/>\n    &lt;/bean>\n&lt;/beans>\n\n\n\n（4）编写Controller\n\n\n\n\n\n\n\n\n注意：这个实现了Controller接口的类需要返回一个ModelAndView，这个对象封装了视图和模型；\npublic class FirstController implements Controller &#123;\n\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        // ModelAndView 封装了模型和视图\n        ModelAndView mv = new ModelAndView();\n        // 模型里封装数据\n        mv.addObject(\"hellomvc\",\"Hello springMVC!\");\n        // 封装跳转的视图名字\n        mv.setViewName(\"hellomvc\");\n        // 不是有个视图解析器吗？\n        // 这玩意可以自动给你加个前缀后缀，可以将hellomvc拼装成/jsp/hellomvc.jsp\n        return mv;\n    &#125;\n&#125;\n\n（5）注入容器\n\n\n\n\n\n\n\n\n将这个实现了controller接口的bean注入到容器中，注意此时的id就成了你要访问的url了\n&lt;bean id=\"/hellomvc\" class=\"cn.itnanls.controller.FirstController\"/>\n\n\n\n\n\n\n\n\n\n\n我们可以给项目换一个简单的名字：\n\n（6）创建jsp页面\n\n\n\n\n\n\n\n\n使用el表达式获取模型中的数据\n&lt;body>\n    $&#123;hellomvc&#125;\n&lt;/body>\n\n\n\n（7）配置Tomcat，并启动测试\n3、使用注解来一波\n\n\n\n\n\n\n\n\n记住一点，只要用注解就得去扫包，让专业的负责解析的类来进行解析：\n（1）配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      \n       xmlns:context=\"http://www.springframework.org/schema/context\"      \n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"      \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans       \n       http://www.springframework.org/schema/beans/spring-beans.xsd       \n       http://www.springframework.org/schema/context       \n       https://www.springframework.org/schema/context/spring-context.xsd       \n       http://www.springframework.org/schema/mvc       \n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n    &lt;!-- 自动扫包 -->\n    &lt;context:component-scan base-package=\"com.ydlclass\"/>\n    &lt;!-- 让Spring MVC不处理静态资源，负责静态资源也会走我们的前端控制器、试图解析器 -->\n    &lt;mvc:default-servlet-handler />\n    &lt;!--  让springmvc自带的注解生效  -->\n    &lt;mvc:annotation-driven />\n    \n     &lt;!-- 处理映射器 -->\n    &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n    &lt;!-- 处理器适配器 -->\n    &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n    &lt;!-- 视图解析器 -->\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"         id=\"internalResourceViewResolver\">\n        &lt;!-- 前缀 -->\n        &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" />\n        &lt;!-- 后缀 -->\n        &lt;property name=\"suffix\" value=\".jsp\" />\n    &lt;/bean>\n&lt;/beans>\n\n（2）编写controller@Controller\npublic class AnnotationController &#123;\n\n    @RequestMapping(\"/hello\")\n    public ModelAndView testAnnotation()&#123;\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"hello\",\"hello annotationMvc\");\n        modelAndView.setViewName(\"hello\");\n        return modelAndView;\n    &#125;\n\n&#125;\n\n（3）启动tomcat测试\n三、初识springmvc1、组件说明\n\n\n\n\n\n\n\n\nDispatcherServlet：中央控制器，前端控制器\n用户请求到达前端控制器（dispatcherServlet），他是整个流程控制的中心，由它负责调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。\n这玩意可以理解成一个【咨询处】，你去某个地方办事，先去咨询处问问我们应该先干什么，等第一件事做完了，可以接着去咨询处咨询，你的下一步工作应该是什么。\n\n\n\n\n\n\n\n\n\nhandler：处理器\nHandler也叫后端控制器，在DispatcherServlet的控制下Handler对【具体的用户请求】进行处理，由于Handler涉及到【具体的用户业务请求】，所以一般情况需要程序员【根据业务需求开发Handler】。这玩意就是你写的controller，别把他想成啥高级玩意，你也能写个处理器。\n\n\n\n\n\n\n\n\n\nView：视图\n一般情况下，需要通过【页面标签或页面模版技术】将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。目前我们接触过得视图技术就是jsp，当然还有Freemarker，Thymeleaf等。\n\n\n\n\n\n\n\n\n\nHandlerMapping：处理器映射器\nHandlerMapping负责根据【用户请求url】找到【Handler】即处理器，springmvc提供了不同的【处理器映射器】实现，如配置文件方式，实现接口方式，注解方式等。\n\n\n\n\n\n\n\n\n\nHandlAdapter：处理器适配器\nHandlerAdapter负责调用具体的处理器，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。我们写的controller中的方法，将来就是会由处理器适配器调用。\n\n\n\n\n\n\n\n\n\nViewResolver：视图解析器\nView Resolver负责将处理结果生成View视图，View Resolver首先根据【逻辑视图名】解析成【物理视图名】即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。\n2、执行流程\n\n\n\n\n\n\n\n\nSpringmvc的是围绕DispatcherServlet进行设计的：\n\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\nSpring MVC框架像许多其他MVC框架一样, 以【请求为驱动】 , 围绕一个【核心Servlet】进行请求分派及提供其他功能，DispatcherServlet仅仅是一个的Servlet（它继承自HttpServlet）。\n\n\n\n\n\n\n\n\n\n\n分发的流程大致如下：\n\n\n\n\n\n\n\n\n\n\n我们甚至可以大致看一下源码：\n众所周知，servlet中的核心方法是【service方法】，当请求一个servlet时会主动调用service方法，而在DispatcherServlet的service方法中，其核心时调用了一个doDispatch的方法，如下：\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry &#123;\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry &#123;\n                // 判断请求中有没有文件\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// 获得一个过滤器链，这就是处理器适配器的工作\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) &#123;\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\n\t\t\t\t// 确定当前请求的处理程序适配器   \n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// 省略一些\n\t\t\t\t...\n\n                // 处理器链调用所有拦截器的前置处理程序，如有不满足的直接返回：\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\n\t\t\t\t// 此处由处理器适配器调用我们写的controller。\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n                // 处理器链调用所有拦截器的后置处理程序，如有不满足的直接返回：\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t&#125;\n\t\t\tcatch (Exception ex) &#123;\n\t\t\t\tdispatchException = ex;\n\t\t\t&#125;\n\t\t\tcatch (Throwable err) &#123;\n\t\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t\t&#125;\n            // 处理最终结果，视图解析器处理mv，还要做统一的异常处理\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t&#125;\n\t...\n\t&#125;\n\n\n\n\n\n\n\n\n\n\n为了理解拦截器，虽然没有学习，但是我们可以看一下这个接口：\npublic interface HandlerInterceptor &#123;\n    //处理器执行之前\n    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        return true;\n    &#125;\n\t//处理器执行之后\n    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;\n    &#125;\n\t//完成之后\n    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n其实这个处理过程简单一点回答总结如下：\n\n通过url匹配一个过滤器链，其中包含多个过滤器和一个处理器\n第一步调用拦截器的preHandle方法\n第二步执行handler方法\n第三部调用拦截器的postHandle方法\n将结果给视图解析器进行处理\n处理完成后调用afterCompletion\n\n3、三个上下文在我们的web项目中存在至少三个上下文，分别是【servlet上下文】，【spring上下文】以及【springmvc上下文】，具体如下：\n\n（1）ServletContext\n对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是我们的ServletContext，其为后面的spring IoC容器提供一个宿主环境。\n\n（2）spring上下文\n在web.xml的配置中，我们需要提供一个监听器【ContextLoaderListener】。在web容器启动时，会触发【容器初始化】事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用。\n在这个方法中，spring会初始化一个【上下文】，这个上下文被称为【根上下文】，即【WebApplicationContext】，这是一个接口类，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的【context-param】配置指定，默认配置文件为【&#x2F;WEB-INF&#x2F;applicationContext.xml】。\n在这个IoC容器初始化完毕后，spring以【WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE】为属性Key，将其存储到ServletContext中，便于将来获取；\n\n\n相关配置：\n&lt;listener>\n    &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class>\n&lt;/listener>\n&lt;context-param>\n    &lt;param-name>contextConfigLocation&lt;/param-name>\n    &lt;param-value>/WEB-INF/app-context.xml&lt;/param-value>\n&lt;/context-param>\n\n\n\n（3）springmvc上下文\ncontextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，通常只配置一个，以最常见的DispatcherServlet为例，这个servlet实际上是一个【标准的前端控制器】，用以转发、匹配、处理每个servlet请求。\nDispatcherServlet在初始化的时候会建立自己的IoC上下文，用以持有【spring mvc相关的bean】。在建立DispatcherServlet自己的IoC上下文时，会利用【WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE】先从ServletContext中获取之前的【根上下文】作为自己上下文的【parent上下文】。有了这个parent上下文之后，再初始化自己持有的上下文，这个上下文本质上也是XmlWebApplicationContext，默认读取的配置文件是【&#x2F;WEB-INF&#x2F;springmvc-servlet.xml】，当然我们也可以使用init-param标签的【contextConfigLocation属性】进行配置。\nDispatcherServlet初始化自己上下文的工作在其【initStrategies】方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是xmlWebApplicationContext。初始化完毕后，spring以【”org.springframework.web.servlet.FrameworkServlet.CONTEXT”+Servlet名称】为Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet还可以共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。\n\n注：springMVC容器只负责创建Controller对象，不会创建service和dao，并且他是一个子容器。而spring的容器只负责Service和dao对象，是一个父容器。子容器可以看见父容器的对象，而父容器看不见子容器的对象，这样各司其职。\n我们可以通过debug，使用ServletContext servletContext = req.getServletContext()查方法看ServletContext，如下：\n\n四、核心技术篇1、视图和模型拆分视图和模型相伴相生，但是springmvc给我们提供了更好的，更优雅的解决方案：\n\nModel会在调用handler时通过参数的形式传入\n\nView可以简化为字符串形式返回\n\n\n这样的解决方案才是企业开发中最常用的：\n@RequestMapping(\"/test1\")\npublic String testAnnotation(Model model)&#123;\n    model.addAttribute(\"hello\",\"hello annotationMvc as string\");\n    return \"annotation\";\n&#125;\n\n2、重定向和转发在返回的字符串中，默认使用视图解析器进行视图跳转：\nspringmvc给我们提供了更好的解决【重定向和转发】的方案：\n\n\n\n\n\n\n\n\n\n返回视图字符串加前缀redirect就可以进行重定向：\nredirect:&#x2F;redirectController&#x2F;redirectTest\nredirect:https:&#x2F;&#x2F;www.baidu.com\n\n\n\n\n\n\n\n\n\n\n返回视图字符串加前缀forward就可以进行请求转发，而不走视图解析器：\n&#x2F;&#x2F; 会将请求转发至&#x2F;a&#x2F;b\nforward:&#x2F;a&#x2F;b\n\n\n\n3、RequestMapping和衍生注解在刚才的小练习中，我们看到了这个注解【@RequestMapping】\n\n这个注解很关键，他不仅仅是一个方法级的注解，还是一个类级注解。\n如果放在类上，相当于给每个方法默认都加上一个前缀url。\n\n@Controller\n@RequestMapping(\"/user/\")\npublic class AnnotationController &#123;\n\n    @RequestMapping(\"register\")\n    public String register(Model model)&#123;\n        ......\n        return \"register\";\n    &#125;\n\n    @RequestMapping(\"login\")\n    public String login()&#123;\n        ......\n        return \"register\";\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n好处\n\n一个类一般处理一类业务，可以统一加上前缀，好区分\n简化书写复杂度\n\n\n\n\n\n\n\n\n\n\nRequestMapping注解有六个属性，如下\n1、value， method；\n\nvalue： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\n\nmethod： 指定请求的method类型， GET、POST、PUT、DELETE等；\n\n\n2、consumes，produces；\n\nconsumes：指定处理中的请求的内容类型（Content-Type），例如application&#x2F;json；\n\nproduces：指定返回响应的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n\n\n@GetMapping(value &#x3D; &quot;&#123;id&#125;&quot;,produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;utf-8&quot;&#125;)\n\n3、params，headers；\n\nparams： 指定request中必须包含某些参数值处理器才会继续执行。\nheaders： 指定request中必须包含某些指定的header值处理器才会继续执行。\n\n@RequestMapping(value = \"add\",method = RequestMethod.POST,\n                consumes = \"application/json\",produces = \"text/plain\",\n                headers = \"name\",params = &#123;\"age\",\"times\"&#125;\n               )\n@ResponseBody\npublic String add(Model model)&#123;\n    model.addAttribute(\"user\",\"add user\");\n    return \"user\";\n&#125;\n\n\n\n@RequestMapping还有几个衍生注解，用来处理特定方法的请求：\n@GetMapping(\"getOne\")\npublic String getOne()&#123;\n    return \"user\";\n&#125;\n\n@PostMapping(\"insert\")\npublic String insert()&#123;\n    return \"user\";\n&#125;\n\n@PutMapping(\"update\")\npublic String update()&#123;\n    return \"user\";\n&#125;\n\n@DeleteMapping(\"delete\")\npublic String delete()&#123;\n    return \"user\";\n&#125;\n\n源码中能看带GetMapping注解中有@RequestMapping作为元注解修饰：\n@RequestMapping(\n    method = &#123;RequestMethod.GET&#125;\n)\npublic @interface GetMapping &#123;\n\n\n\n4、URI 模式匹配@RequestMapping可以支持【URL模式匹配】，为此，spring提供了两种选择（两个类）：\n\nPathPattern —PathPattern是 Web 应用程序的推荐解决方案，也是 Spring WebFlux 中的唯一选择，比较新。\nAntPathMatcher — 使用【字符串模式与字符串路径】匹配。这是Spring提供的原始解决方案，用于选择类路径、文件系统和其他位置上的资源。\n\n小知识：二者目前都存在于Spring技术栈内，做着相同的事。虽说现在还鲜有同学了解到PathPattern，我认为淘汰掉AntPathMatcher只是时间问题（特指web环境哈），毕竟后浪总归有上岸的一天。但不可否认，二者将在较长时间内共处，那么它俩到底有何区别呢？\n\n出现时间，AntPathMatcher是一个早在2003年（Spring的第一个版本）就已存在的路径匹配器，而PathPattern是Spring 5新增的，旨在用于替换掉较为“古老”的AntPathMatcher。\n\n功能差异，PathPattern去掉了Ant字样，但保持了很好的向下兼容性：除了不支持将**写在path中间之外，其它的匹配规则从行为上均保持和AntPathMatcher一致，并且还新增了强大的{*pathVariable}的支持，他能匹配最后的多个路劲，并获取路径的值。\n\n性能差异，Spring官方说PathPattern的性能优于AntPathMatcher。\n\n\n\n\n\n\n\n\n\n\n\n以下是一些模式匹配的示例：\n\n&quot;/resources/ima?e.png&quot; - 匹配路径段中的一个字符\n&quot;/resources/*.png&quot; - 匹配路径段中的零个或多个字符\n&quot;/resources/**&quot; - 匹配多个路径段\n&quot;/projects/&#123;project&#125;/versions&quot; - 匹配路径段并将其【捕获为变量】\n&quot;/projects/&#123;project:[a-z]+&#125;/versions&quot; - 使用正则表达式匹配并【捕获变量】\n\n捕获的 URI 变量可以使用@PathVariable注解，示例例如：\n@GetMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;\")\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n    // ...\n&#125;\n\n您还可以在类和方法级别声明 URI 变量，如以下示例所示：\n@Controller\n@RequestMapping(\"/owners/&#123;ownerId&#125;\")\npublic class OwnerController &#123;\n\n    @GetMapping(\"/pets/&#123;petId&#125;\")\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n        // ...\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n有时候会遇到一个url可以匹配到多个路由的情况，这个时候就是由Spring的AntPatternComparator完成优先级处理，大致规律如下：\n比如：有两个匹配规则一个是 &#x2F;a&#x2F;**，一个是 &#x2F;a&#x2F;b&#x2F;**，还有一个是&#x2F;a&#x2F;b&#x2F;*，如果访问的url是&#x2F;a&#x2F;b&#x2F;c，其实这三个路由都能匹配到，在匹配优先级中，有限级如下：\n\n\n\n匹配方式\n优先级\n\n\n\n全路径匹配，例如：配置路由&#x2F;a&#x2F;b&#x2F;c\n第一优先级\n\n\n带有{}路径的匹配，例如：&#x2F;a&#x2F;{b}&#x2F;c\n第二优先级\n\n\n正则匹配，例如：&#x2F;a&#x2F;{regex:\\d{3}}&#x2F;c\n第三优先级\n\n\n带有*路径的匹配，例如：&#x2F;a&#x2F;b&#x2F;*\n第四优先级\n\n\n带有**路径的匹配，例如：&#x2F;a&#x2F;b&#x2F;**\n第五优先级\n\n\n仅仅是双通配符：&#x2F;**\n最低优先级\n\n\n注意：\n\n当有多个*和多个‘{}’时，命中单个路径多的，优先越高。\n多*’的优先级高于‘**’，会优先匹配带有*\n\n\n\n\n\n\n\n\n\n\n我们还可以从一个类中看出，当一个url匹配了多个处理器时，优先级是如何考虑的，这个类是AntPathMatcher的一个内部类：\nprotected static class AntPatternComparator implements Comparator&lt;String> &#123;\n\n    @Override\n    public int compare(String pattern1, String pattern2) &#123;\n        PatternInfo info1 = new PatternInfo(pattern1);\n        PatternInfo info2 = new PatternInfo(pattern2);\n\t\t.....\n\n        boolean pattern1EqualsPath = pattern1.equals(this.path);\n        boolean pattern2EqualsPath = pattern2.equals(this.path);\n        // 完全相等，是无法比较的\n        if (pattern1EqualsPath &amp;&amp; pattern2EqualsPath) &#123;\n            return 0;\n        &#125;\n        // pattern1和urlequals,返回负数 1胜出\n        else if (pattern1EqualsPath) &#123;\n            return -1;\n        &#125;\n        // pattern2和urlequals,返回正数，2胜出\n        else if (pattern2EqualsPath) &#123;\n            return 1;\n        &#125;\n\n        // 都是前缀匹配，长的优先   /a/b/**  /a/**\n        if (info1.isPrefixPattern() &amp;&amp; info2.isPrefixPattern()) &#123;\n            return info2.getLength() - info1.getLength();\n        &#125;\n        // 非前缀匹配的优先级高\n        else if (info1.isPrefixPattern() &amp;&amp; info2.getDoubleWildcards() == 0) &#123;\n            return 1;\n        &#125;\n        else if (info2.isPrefixPattern() &amp;&amp; info1.getDoubleWildcards() == 0) &#123;\n            return -1;\n        &#125;\n\n        // 匹配数越少，优先级越高\n        if (info1.getTotalCount() != info2.getTotalCount()) &#123;\n            return info1.getTotalCount() - info2.getTotalCount();\n        &#125;\n\n        // 路径越短越好\n        if (info1.getLength() != info2.getLength()) &#123;\n            return info2.getLength() - info1.getLength();\n        &#125;\n\n        // 单通配符个数，数量越少优先级越高\n        if (info1.getSingleWildcards() &lt; info2.getSingleWildcards()) &#123;\n            return -1;\n        &#125;\n        else if (info2.getSingleWildcards() &lt; info1.getSingleWildcards()) &#123;\n            return 1;\n        &#125;\n        // url参数越少越优先\n        if (info1.getUriVars() &lt; info2.getUriVars()) &#123;\n            return -1;\n        &#125;\n        else if (info2.getUriVars() &lt; info1.getUriVars()) &#123;\n            return 1;\n        &#125;\n\n        return 0;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n源码中我们看到的信息如下：\n1、完全匹配者，优先级最高\n2、都是前缀匹配（&#x2F;a&#x2F;**）,  匹配路由越长，优先级越高\n3、前缀匹配优先级，比非前缀的低\n4、需要匹配的数量越少，优先级越高，this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\n5、路劲越短优先级越高\n6、*越少优先级越高\n7、{}越少优先级越高\n5、牛逼的传参\n\n\n\n\n\n\n\n\n在学习servlet时，我们是这样获取请求参数的：\n@PostMapping(\"insert\")\npublic String insert(HttpServletRequest req)&#123;\n    String username = req.getParameter(\"username\");\n    String password = req.getParameter(\"password\");\n    // 其他操作\n    return \"success\";\n&#125;\n\n\n\n\n\n\n\n\n\n\n有了springmvc之后，我们以后再也不需要使用getParamter一个一个获取参数了：\n@Controller\n@RequestMapping(\"/user/\")\npublic class LoginController &#123;\n\n    @RequestMapping(\"login\")\n    public String login(String username,String password)&#123;\n        System.out.println(username);\n        System.out.println(password);\n        return \"login\";\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n那么问题又来了，如果一个表单几十个参数怎么获取啊？更牛的来了方式他来了：\n需要提前定义一个User对象：\npublic class User &#123;\n    \n    private String username;\n    private String password;\n    private int age;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n直接在参数中申明user对象\n@Controller\n@RequestMapping(\"/user/\")\npublic class LoginController &#123;\n\n    @RequestMapping(\"register\")\n    public String register(User user)&#123;\n        System.out.println(user);\n        return \"register\";\n    &#125;\n\n    @RequestMapping(\"login\")\n    public String login(String username,String password)&#123;\n        System.out.println(username);\n        System.out.println(password);\n        return \"login\";\n    &#125;\n&#125;\n\n\n\n（1）@RequestParam您可以使用@RequestParam注解将【请求参数】（即查询参数或表单数据）绑定到控制器中的方法参数。\n@Controller\n@RequestMapping(\"/pets\")\npublic class EditPetForm &#123;\n\n    @GetMapping\n    public String setupForm(@RequestParam(\"petId\") int petId, Model model) &#123; \n        Pet pet = this.clinic.loadPet(petId);\n        model.addAttribute(\"pet\", pet);\n        return \"petForm\";\n    &#125;\n&#125;\n\n默认情况下，使用此注解的方法参数是必需的，但我们可以通过将@RequestParam注解的【required标志设置】为 false来指定方法参数是可选的。如果目标方法参数类型不是String，则应用会自动进行类型转换，这个后边会讲。\n请注意，使用@RequestParam是可选的。默认情况下，任何属于简单值类型且未被任何其他参数解析器解析的参数都被视为使用【@RequestParam】。\n（2）@RequestHeader您可以使用@RequestHeader注解将请求的首部信息绑定到控制器中的方法参数中：\n假如我们的请求header如下：\nHost localhost:8080 \nAccept text/html,application/xhtml+xml,application/xml;q=0.9 \nAccept-Language fr,en-gb;q=0.7,en;q=0.3 \nAccept-Encoding gzip,deflate \nAccept-Charset ISO -8859-1,utf-8;q=0.7,*;q=0.7 \nKeep-Alive 300\n\n以下示例获取Accept-Encoding和Keep-Alive标头的值：\n@GetMapping(\"/demo\")\npublic void handle(\n        @RequestHeader(\"Accept-Encoding\") String encoding, \n        @RequestHeader(\"Keep-Alive\") long keepAlive) &#123; \n    //...\n&#125;\n\n小知识：当@RequestHeader注解上的使用Map&lt;String, String&gt;， MultiValueMap&lt;String, String&gt;或HttpHeaders参数，则map会被填充有所有header的值。当然，我们依然可以使用requied的属性来执行该参数不是必须的。\n（3）@CookieValue我们可以使用@CookieValue注解将请求中的 cookie 的值绑定到控制器中的方法参数。\n假设我们的请求中带有如下cookie：\nJSESSIONID&#x3D;415A4AC178C59DACE0B2C9CA727CDD84\n\n以下示例显示了如何获取 cookie 值：\n@GetMapping(\"/demo\")\npublic void handle(@CookieValue(\"JSESSIONID\") String cookie) &#123; \n    //...\n&#125;\n\n\n\n（4）@ModelAttribute您可以使用@ModelAttribute注解在方法参数上来访问【模型中的属性】，或者在不存在的情况下对其进行实例化。模型的属性会覆盖来自 HTTP Servlet 请求参数的值，其名称与字段名称匹配，这称为数据绑定，它使您不必【处理解析】和【转换单个查询参数】和表单字段。以下示例显示了如何执行此操作：\n@RequestMapping(\"/register\")\npublic String register(@ModelAttribute(\"user\") UserForm user) &#123;\n    ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n还有一个例子\n@ModelAttribute 和 @RequestMapping 注解同时应用在方法上时，有以下作用：\n\n方法的【返回值】会存入到 Model 对象中，key为 ModelAttribute 的 value 属性值。\n方法的返回值不再是方法的访问路径，访问路径会变为 @RequestMapping 的 value 值，例如：@RequestMapping(value &#x3D; “&#x2F;index”) 跳转的页面是 index.jsp 页面。\n\n@Controller\npublic class ModelAttributeController &#123;\n    // @ModelAttribute和@RequestMapping同时放在方法上\n    @RequestMapping(value = \"/index\")\n    @ModelAttribute(\"name\")\n    public String model(@RequestParam(required = false) String name) &#123;\n        return name;\n    &#125;\n&#125;\n\n（5）@SessionAttribute如果您需要访问全局管理的预先存在的会话属性，并且可能存在或可能不存在，您可以@SessionAttribute在方法参数上使用注解，如下所示示例显示：\n@RequestMapping(\"/\")\npublic String handle(@SessionAttribute User user) &#123; \n    // ...\n&#125;\n\n\n\n（6）@RequestAttribute和@SessionAttribute一样，您可以使用@RequestAttribute注解来访问先前创建的存在与请求中的属性（例如，由 ServletFilter 或HandlerInterceptor）创建或在请求转发中添加的数据：\n@GetMapping(\"/\")\npublic String handle(@RequestAttribute Client client) &#123; \n    // ...\n&#125;\n\n\n\n（7）@SessionAttributes @SessionAttributes注解应用到Controller上面，可以将Model中的属性同步到session当中：\n@Controller\n@RequestMapping(\"/Demo.do\")\n@SessionAttributes(value=&#123;\"attr1\",\"attr2\"&#125;)\npublic class Demo &#123;\n    \n    @RequestMapping(params=\"method=index\")\n    public ModelAndView index() &#123;\n        ModelAndView mav = new ModelAndView(\"index.jsp\");\n        mav.addObject(\"attr1\", \"attr1Value\");\n        mav.addObject(\"attr2\", \"attr2Value\");\n        return mav;\n    &#125;\n    \n    @RequestMapping(params=\"method=index2\")\n    public ModelAndView index2(@ModelAttribute(\"attr1\")String attr1, @ModelAttribute(\"attr2\")String attr2) &#123;\n        ModelAndView mav = new ModelAndView(\"success.jsp\");\n        return mav;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n附加一个注解使用的案例：\n@RequestMapping(\"insertUser\")\n    public String insertUser(\n            @RequestParam(value = \"age\",required = false) Integer age,\n            @RequestHeader(value = \"Content-Type\",required = false) String contentType,\n            @RequestHeader(required = false) String name,\n            @CookieValue(value = \"company\",required = false) String company,\n            @SessionAttribute(value = \"username\",required = false) String onlineUser,\n            @RequestAttribute(required = false) Integer count,\n            @ModelAttribute(\"date\") Date date,\n            @SessionAttribute(value = \"date\",required = false) Date sessionDate\n    ) &#123;\n        System.out.println(\"sessionDate = \" + sessionDate);\n        System.out.println(\"date = \" + date);\n        System.out.println(\"count = \" + count);\n        System.out.println(\"onlineUser = \" + onlineUser);\n        System.out.println(\"age = \" + age);\n        System.out.println(\"contentType = \" + contentType);\n        System.out.println(\"name = \" + name);\n        System.out.println(\"company = \" + company);\n        return \"user\";\n    &#125;\n\n\n\n\n\n（8）数组的传递在类似批量删除的场景中，我们可能需要传递一个id数组，此时我们仅仅需要将方法的参数指定为数组即可：\n@GetMapping(\"/array\")\npublic String testArray(@RequestParam(\"array\") String[] array) throws Exception &#123;\n    System.out.println(Arrays.toString(array));\n    return \"array\";\n&#125;\n\n我们可以发送如下请求，可以是多个名称相同的key，也可以是一个key，但是值以逗号分割的参数：\nhttp://localhost:8080/app/hellomvc?array=1,2,3,4\n\n或者\nhttp://localhost:8080/app/hellomvc?array=1&amp;array=3\n\n结果都是没有问题的：\n\n（9）复杂参数的传递当然我们在进行参数接收的时候，其中可能包含很复杂的参数，一个请求中可能包含很多项内容，比如以下表单：\n当然我们要注意表单中的name（参数中key）的写法：\n&lt;form action=\"user/queryParam\" method=\"post\">\n    排序字段：&lt;br>\n    &lt;input type=\"text\" name=\"sortField\">\n    &lt;hr>\n    数组：&lt;br>\n    &lt;input type=\"text\" name=\"ids[0]\"> &lt;br>\n    &lt;input type=\"text\" name=\"ids[1]\">\n    &lt;hr>\n    user对象：&lt;br>\n    &lt;input type=\"text\" name=\"user.username\" placeholder=\"姓名\">&lt;br>\n    &lt;input type=\"text\" name=\"user.password\" placeholder=\"密码\">\n    &lt;hr>\n    list集合&lt;br>\n    第一个元素：&lt;br>\n    &lt;input type=\"text\" name=\"userList[0].username\" placeholder=\"姓名\">&lt;br>\n    &lt;input type=\"text\" name=\"userList[0].password\" placeholder=\"密码\">&lt;br>\n    第二个元素： &lt;br>\n    &lt;input type=\"text\" name=\"userList[1].username\" placeholder=\"姓名\">&lt;br>\n    &lt;input type=\"text\" name=\"userList[1].password\" placeholder=\"密码\">\n    &lt;hr>\n    map集合&lt;br>\n    第一个元素：&lt;br>\n    &lt;input type=\"text\" name=\"userMap['user1'].username\" placeholder=\"姓名\">&lt;br>\n    &lt;input type=\"text\" name=\"userMap['user1'].password\" placeholder=\"密码\">&lt;br>\n    第二个元素：&lt;br>\n    &lt;input type=\"text\" name=\"userMap['user2'].username\" placeholder=\"姓名\">&lt;br>\n    &lt;input type=\"text\" name=\"userMap['user2'].password\" placeholder=\"密码\">&lt;br>\n    &lt;input type=\"submit\" value=\"提交\">\n&lt;/form>\n\n然后我们需要搞一个实体类用来接收这个表单的参数：\n@Data\npublic class QueryVo &#123;\n    private String sortField;\n    private User user;\n    private Long[] ids;\n    private List&lt;User> userList;\n    private Map&lt;String, User> userMap;\n&#125;\n\n编写接口进行测试，我们发现表单的数据已经尽数传递了进来：\n@PostMapping(\"queryParam\")\npublic String queryParam(QueryVo queryVo) &#123;\n    System.out.println(queryVo);\n    return \"user\";\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n拓展知识：\n\nVO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\nDTO（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。\nDO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\nPO（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。\n\n下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置：\n\n大致流程如下：\n\n用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO；\n展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层；\n服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务；\n服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作；\n数据传输顺序：VO &#x3D;&#x3D;&#x3D;&gt; DTO &#x3D;&#x3D;&#x3D;&gt; DO &#x3D;&#x3D;&#x3D;&gt; PO\n\n相对来说越是靠近显示层的概念越不稳定，复用度越低。分层的目的，就是复用和相对稳定性。\n小知识：一般的简单工程中，并不会进行这样的设计，我们可能有一个User类就可以了，并不需要什么VO、DO啥的。但是，随着项目工程的复杂化，简单的对象已经没有办法在各个层的使用，项目越是复杂，就需要越是复杂的设计方案，这样才能满足高扩展性和维护性。\n6、设定字符集\n\n\n\n\n\n\n\n\nspringmvc内置了一个统一的字符集处理过滤器，我们只要在web.xml中配置即可：\n&lt;filter>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class>\n    &lt;init-param>\n        &lt;param-name>encoding&lt;/param-name>\n        &lt;param-value>utf-8&lt;/param-value>\n    &lt;/init-param>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n&lt;/filter-mapping>\n\n\n\n\n\n\n\n\n\n\n看看他的核心源码，是不是和我们之前自己写的很像呢？\n@Override\nprotected void doFilterInternal(\n    HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n    throws ServletException, IOException &#123;\n\n    String encoding = getEncoding();\n    if (encoding != null) &#123;\n        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) &#123;\n            request.setCharacterEncoding(encoding);\n        &#125;\n        if (isForceResponseEncoding()) &#123;\n            response.setCharacterEncoding(encoding);\n        &#125;\n    &#125;\n    filterChain.doFilter(request, response);\n&#125;\n\n\n\n7、返回json数据（序列化）\n\n\n\n\n\n\n\n\n我们经常需要使用ajax请求后台获取数据，而不需要访问任何的页面，这种场景在前后分离的项目当中尤其重要：\n这种做法其实很简单，大致步骤如下：\n\n将我们的对象转化为json字符串。\n\n将返回的内容直接写入响应体，不走视图解析器。\n\n然后将Content-Type设置为application/json即可。\n\n\n为了实现这个目的，我们可以引入fastjson：\n&lt;dependency>\n   &lt;groupId>com.alibaba&lt;/groupId>\n   &lt;artifactId>fastjson&lt;/artifactId>\n   &lt;version>1.2.68&lt;/version>\n&lt;/dependency>\n\n// produces指定了响应的Content-Type\n@RequestMapping(value = \"getUsers\",produces = &#123;\"application/json;charset=utf-8\"&#125;)\n@ResponseBody  // 将返回的结果直接写入响应体，不走视图解析器\npublic String getUsers()&#123;\n    List&lt;User> users =  new ArrayList&lt;User>()&#123;&#123;\n        add(new User(\"Tom\",\"2222\"));\n        add(new User(\"jerry\",\"333\"));\n    &#125;&#125;;\n    return JSONArray.toJSONString(users);\n&#125;\n\n测试：成功！\n注意：@ResponseBody能将返回的结果直接放在响应体中，不走视图解析器。\n\n浏览器中添加插件json viewer可以有如上显示：\n\n\n\n\n\n\n\n\n\n\n当然springmvc也考虑到了，每次这样写也其实挺麻烦，我们还可以向容器注入一个专门处理消息转换的bean：\n这个转化器的作用就是：当不走视图解析器时，如果发现【返回值是一个对象】，就会自动将返回值转化为json字符序列：\n&lt;mvc:annotation-driven >\n        &lt;mvc:message-converters>\n            &lt;bean id=\"fastjson\" class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">\n                &lt;property name=\"supportedMediaTypes\">\n                    &lt;list>\n                        &lt;!-- 这里顺序不能反，一定先写text/html,不然ie下会出现下载提示 -->\n    \t\t\t\t&lt;value>text/html;charset=UTF-8&lt;/value>\n\t\t\t\t\t&lt;value>application/json;charset=UTF-8&lt;/value>\n                    &lt;/list>\n                &lt;/property>\n            &lt;/bean>\n        &lt;/mvc:message-converters>\n&lt;/mvc:annotation-driven>\n\n以后我们的controller就可以写成下边的样子了：\n@RequestMapping(value = \"getUsersList\")\n@ResponseBody\npublic List&lt;User> getUsersList()&#123;\n    return   new ArrayList&lt;User>()&#123;&#123;\n        add(new User(\"邸智伟\",\"2222\"));\n        add(new User(\"刘展鹏\",\"333\"));\n    &#125;&#125;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n当然我们还可以使用一个更加流行的组件jackson来处理，他的工作和fastjson一致，首先需要引入以下依赖：\n&lt;!--jackson-->\n&lt;dependency>\n    &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n    &lt;artifactId>jackson-core&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n    &lt;artifactId>jackson-annotations&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n    &lt;artifactId>jackson-databind&lt;/artifactId>\n&lt;/dependency>\n\n我们还可以对序列化的过程进行额外的一些配置：\npublic class CustomObjectMapper extends ObjectMapper &#123;\n\n    public CustomObjectMapper() &#123;\n        super();\n        //去掉默认的时间戳格式\n        configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n        //设置为东八区\n        setTimeZone(TimeZone.getTimeZone(\"GMT+8\"));\n        //设置日期转换yyyy-MM-dd HH:mm:ss\n        setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n        // 设置输入:禁止把POJO中值为null的字段映射到json字符串中\n        configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);\n        // 空值不序列化\n        setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        // 反序列化时，属性不存在的兼容处理\n        getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n        // 序列化枚举是以toString()来输出，默认false，即默认以name()来输出\n        configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);\n    &#125;\n&#125;\n\n编写配置文件：\n&lt;mvc:annotation-driven>\n\n    &lt;mvc:message-converters>\n        &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n            &lt;!-- 自定义Jackson的objectMapper -->\n            &lt;property name=\"objectMapper\" ref=\"customObjectMapper\" />\n            &lt;property name=\"supportedMediaTypes\">\n                &lt;list>\n                    &lt;value>text/plain;charset=UTF-8&lt;/value>\n                    &lt;value>application/json;charset=UTF-8&lt;/value>\n                &lt;/list>\n            &lt;/property>\n        &lt;/bean>\n    &lt;/mvc:message-converters>\n\n&lt;/mvc:annotation-driven>\n&lt;!--注入我们写的对jackson的配置的bean-->\n&lt;bean name=\"customObjectMapper\" class=\"com.ydlclass.CustomObjectMapper\"/>\n\n测试成功：\n8、获取请求中的json数据在前端发送的数据中可能会如如下情况，Contetn-Type是application&#x2F;json，请求体中是json格式数据：\n\n@RequestBody注解可以【直接获取请求体的数据】。\n如果我们配置了消息转化器，消息转化器会将请求体中的json数据反序列化成目标对象，如下所示：\n@PostMapping(\"insertUser\")\npublic String insertUser(@RequestBody User user) &#123;\n    System.out.println(user);\n    return \"user\";\n&#125;\n\n当然，我们可以吧消息转化器注解掉，直接使用一个String来接收请求体的内容：\n9、数据转化假如有如下场景，前端传递过来一个日期字符串，但是后端需要使用Date类型进行接收，这时就需要一个类型转化器进行转化。\n自定义的类型转化器只支持从requestParam获取的参数进行转化，我们可以定义如下，其实学习spring时我们已经接触过这个Converter接口：\npublic class StringToDateConverter implements Converter&lt;String, Date> &#123;\n    @Override\n    public Date convert(String source) &#123;\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy_MM_dd hh,mm,ss\");\n        try &#123;\n            return simpleDateFormat.parse(source);\n        &#125; catch (ParseException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n然后，我们需要在配置文件中进行配置：\n&lt;!-- 开启mvc的注解 -->\n&lt;mvc:annotation-driven conversion-service=\"conversionService\" />\n\n&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n    &lt;property name=\"converters\">\n        &lt;set>\n            &lt;bean id=\"stringToDateConverter\" class=\"cn.itnanls.convertors.StringToDateConverter\"/>\n        &lt;/set>\n    &lt;/property>\n&lt;/bean>\n\n\n\n\n\n\n\n\n\n\n\n\n\n对于时间类型的处理，springmvc给我们提供了一个比较完善的解决方案，使用注解@DateTimeFormat，同时配合jackson提供的@JsonFormat注解几乎可以满足我们的所有需求。\n@DateTimeFormat：当从requestParam中获取string参数并需要转化为Date类型时，会根据此注解的参数pattern的格式进行转化。\n@JsonFormat：当从请求体中获取json字符序列，需要反序列化为对象时，时间类型会按照这个注解的属性内容进行处理。\n这两个注解需要加在实体类的对应字段上即可：\n// 对象和json互相转化的过程当中按照此转化方式转哈\n@JsonFormat(\n            pattern = \"yyyy年MM月dd日\",\n            timezone = \"GMT-8\"\n    )\n// 从requestParam中获取参数并且转化\n@DateTimeFormat(pattern = \"yyyy年MM月dd日\")\nprivate Date birthday;\n\n\n\n\n\n\n\n\n\n\n处理的过程大致如下：\n\n10、数据校验\nJSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它包含在 JavaEE 6.0 中。\nJSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。\n\n\n\n\nConstraint\n详细信息\n\n\n\n@Null\n被注解的元素必须为 null\n\n\n@NotNull\n被注解的元素必须不为 null\n\n\n@AssertTrue\n被注解的元素必须为 true\n\n\n@AssertFalse\n被注解的元素必须为 false\n\n\n@Min(value)\n被注解的元素必须是一个数字，其值必须大于等于指定的最小值\n\n\n@Max(value)\n被注解的元素必须是一个数字，其值必须小于等于指定的最大值\n\n\n@DecimalMin(value)\n被注解的元素必须是一个数字，其值必须大于等于指定的最小值\n\n\n@DecimalMax(value)\n被注解的元素必须是一个数字，其值必须小于等于指定的最大值\n\n\n@Size(max, min)\n被注解的元素的大小必须在指定的范围内\n\n\n@Digits (integer, fraction)\n被注解的元素必须是一个数字，其值必须在可接受的范围内\n\n\n@Past\n被注解的元素必须是一个过去的日期\n\n\n@Future\n被注解的元素必须是一个将来的日期\n\n\n@Pattern(value)\n被注解的元素必须符合指定的正则表达式\n\n\n\n\n\n\n\n\n\n\n\nHibernate Validator 扩展注解\nHibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解\nHibernate Validator 附加的 constraint\n\n\n\nConstraint\n详细信息\n\n\n\n@Email\n被注解的元素必须是电子邮箱地址\n\n\n@Length\n被注解的字符串的大小必须在指定的范围内\n\n\n@NotEmpty\n被注解的字符串的必须非空\n\n\n@Range\n被注解的元素必须在合适的范围内\n\n\n\n\n\n\n\n\n\n\n\nSpring MVC 数据校验\nSpring MVC 可以对表单参数进行校验，并将结果保存到对应的【BindingResult】或 【Errors 】对象中。\n\n\n\n\n\n\n\n\n\n要实现数据校验，需要引入已下依赖\n&lt;dependency>\n    &lt;groupId>javax.validation&lt;/groupId>\n    &lt;artifactId>validation-api&lt;/artifactId>\n    &lt;version>2.0.1.Final&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.hibernate&lt;/groupId>\n    &lt;artifactId>hibernate-validator&lt;/artifactId>\n    &lt;version>6.0.9.Final&lt;/version>\n&lt;/dependency>\n\n\n\n\n\n\n\n\n\n\n\n\n并在实体类加上特定注解\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserVO &#123;\n\n    @NotNull(message = \"用户名不能为空\")\n    private String username;\n\n    @NotNull(message = \"用户名不能为空\")\n    private String password;\n\n    @Min(value = 0, message = \"年龄不能小于&#123;value&#125;\")\n    @Max(value = 120,message = \"年龄不能大于&#123;value&#125;\")\n    private int age;\n\n    @JsonFormat(\n            pattern = \"yyyy-MM-dd\",\n            timezone = \"GMT-8\"\n    )\n    @DateTimeFormat(pattern = \"yyyy-MM-dd\")\n    @Past(message = \"生日不能大于今天\")\n    private Date birthday;\n\n    @Pattern(regexp = \"^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]&#123;8&#125;$\", message = \"手机号码不正确\")\n    private String phone;\n\n    @Email\n    private String email;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n在配置文件中配置如下内容，增加hibernate校验：\n&lt;bean id=\"localValidator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\">\n    &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/>\n&lt;/bean>\n&lt;!--注册注解驱动-->\n&lt;mvc:annotation-driven validator=\"localValidator\"/>\n\n\n\n\n\n\n\n\n\n\n\n\ncontroller使用@Validated标识验证的对象，紧跟着的BindingResult获取错误信息\n@PostMapping(\"insert\")\npublic String insert(@Validated UserVO user, BindingResult br) &#123;\n    List&lt;ObjectError> allErrors = br.getAllErrors();\n    Iterator&lt;ObjectError> iterator = allErrors.iterator();\n    // 打印以下错误结果\n    while (iterator.hasNext())&#123;\n        ObjectError error = iterator.next();\n        log.error(\"user数据校验错误:&#123;&#125;\",error.getDefaultMessage());\n    &#125;\n\n    if(allErrors.size() > 0)&#123;\n        return \"error\";\n    &#125;\n\n    System.out.println(user);\n    return \"user\";\n&#125;\n\n\n\n\n\n\n\n\n\n\n测试：\n\n永远不要相信用户的输入，我们开发的系统凡是涉及到用户输入的地方，都要进行校验，这里的校验分为前台校验和后台校验，前台校验通常由javascript来完成，后台校验主要由java来负责，这里我们可以通过spring mvc+hibernate validator完成。\n11、视图解析器详解我们默认的视图解析器是如下的配置，它主要是处理jsp页面的映射渲染：\n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"  id=\"internalResourceViewResolver\">\n    &lt;!-- 前缀 -->\n    &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" />\n    &lt;!-- 后缀 -->\n    &lt;property name=\"suffix\" value=\".jsp\" />\n&lt;/bean>\n\n如果我们想添加新的视图解析器，则需要给旧的新增一个order属性，或者直接删除原有的视图解析器：\n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\">\n    &lt;!-- 前缀 -->\n    &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" />\n    &lt;!-- 后缀 -->\n    &lt;property name=\"suffix\" value=\".jsp\" />\n    &lt;property name=\"order\" value=\"10\"/>\n&lt;/bean>\n\n\n这里的order表示视图解析的【优先级】，数字越小优先级越大（即：0为优先级最高，所以优先进行处理视图），InternalResourceViewResolver在项目中的优先级一般要设置为最低，也就是order要最大。不然它会影响其他视图解析器。\n\n当处理器返回逻辑视图时（也就是return “string”），要经过视图解析器链，如果前面的解析器能处理，就不会继续往下传播。如果不能处理就要沿着解析器链继续寻找，直到找到合适的视图解析器。\n\n\n如下图所示：\n\n然后，我们可以配置一个新的Tymeleaf视图解析器，order设置的低一些，这样两个视图解析器都可以生效：\n&lt;!--thymeleaf的视图解析器-->\n&lt;bean id=\"templateResolver\"\n      class=\"org.thymeleaf.spring4.templateresolver.SpringResourceTemplateResolver\">\n    &lt;property name=\"prefix\" value=\"/WEB-INF/templates/\" />\n    &lt;property name=\"suffix\" value=\".html\" />\n    &lt;property name=\"templateMode\" value=\"HTML\" />\n    &lt;property name=\"cacheable\" value=\"true\" />\n&lt;/bean>\n&lt;!--thymeleaf的模板引擎配置-->\n&lt;bean id=\"templateEngine\"\n      class=\"org.thymeleaf.spring4.SpringTemplateEngine\">\n    &lt;property name=\"templateResolver\" ref=\"templateResolver\" />\n    &lt;property name=\"enableSpringELCompiler\" value=\"true\" />\n&lt;/bean>\n&lt;bean id=\"viewResolver\" class=\"org.thymeleaf.spring4.view.ThymeleafViewResolver\">\n    &lt;property name=\"order\" value=\"1\"/>\n    &lt;property name=\"characterEncoding\" value=\"UTF-8\"/>\n    &lt;property name=\"templateEngine\" ref=\"templateEngine\"/>\n&lt;/bean>\n\n\n\n\n\n\n\n\n\n\n添加两个相关依赖\n&lt;dependency>\n    &lt;groupId>org.thymeleaf&lt;/groupId>\n    &lt;artifactId>thymeleaf&lt;/artifactId>\n    &lt;version>3.0.14.RELEASE&lt;/version>\n&lt;/dependency>\n&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf-spring4 -->\n&lt;dependency>\n    &lt;groupId>org.thymeleaf&lt;/groupId>\n    &lt;artifactId>thymeleaf-spring4&lt;/artifactId>\n    &lt;version>3.0.14.RELEASE&lt;/version>\n&lt;/dependency>\n\n\n\n\n\n\n\n\n\n\n模板中需要添加对应的命名空间\n&lt;html xmlns:th=\"http://www.thymeleaf.org\" >\n\nthymeleaf官网：Thymeleaf\nthymeleaf语法详解：\n12、全局异常捕获（1）HandlerExceptionResolver在Java中，对于异常的处理一般有两种方式：\n\n一种是当前方法捕获处理（try-catch），这种处理方式会造成业务代码和异常处理代码的耦合。\n另一种是自己不处理，而是抛给调用者处理（throws），调用者再抛给它的调用者，也就是一直向上抛，指导传递给浏览器。\n\n\n被异常填充的页面是长这个样子的：\n\n在这种方法的基础上，衍生出了SpringMVC的异常处理机制。系统的dao、service、controller都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：  \n小知识：service层尽量不要处理异常，如果自己捕获并处理了，异常就不生效了。特别是不要生吞异常。\n\nSpring MVC的Controller出现异常的默认处理是响应一个500状态码，再把错误信息显示在页面上，如果用户看到这样的页面，一定会觉得你这个网站太LOW了。\n要解决Controller的异常问题，当然也不能在每个处理请求的方法中加上异常处理，那样太繁琐了。\n通过源码我们得知，需要写一个HandlerExceptionResolver，并实现其方法：\npublic class GlobalExceptionResolver implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request,\n                                         HttpServletResponse response, Object handler, Exception ex) &#123;\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"error\", ex.getMessage());\n        modelAndView.setViewName(\"error\");\n        return modelAndView;\n    &#125;\n&#125;\n\n、\n&lt;bean id=\"globalExecptionResovler\" class=\"com.lagou.exception.GlobalExecptionResovler\">&lt;/bean>\n\n\n\n@Component\npublic class GlobalExecptionResovler implements HandlerExceptionResolver &#123;&#125;\n\n\n\n小知识：当然在web中我们也能对异常进行统一处理：\n&lt;!--处理500异常-->\n&lt;error-page>\n    &lt;error-code>500&lt;/error-code>\n    &lt;location>/500.jsp&lt;/location>\n&lt;/error-page>\n&lt;!--处理404异常-->\n&lt;error-page>\n    &lt;error-code>404&lt;/error-code>\n    &lt;location>/404.jsp&lt;/location>\n&lt;/error-page>\n\n\n\n（2）@ControllerAdvice该注解同样能实现异常的全局统一处理，而且实现起来更加简单优雅，当然使用这个注解有一下三个功能：\n\n处理全局异常\n预设全局数据\n请求参数预处理\n\n我们主要学习其中的全局异常处理，@ControllerAdvice 配合 @ExceptionHandler 实现全局异常处理：\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionResolverController  &#123;\n\n    @ExceptionHandler(ArithmeticException.class)\n    public String processArithmeticException(ArithmeticException ex)&#123;\n        log.error(\"发生了数学类的异常：\",ex);\n        return \"error\";\n    &#125;\n\n    @ExceptionHandler(BusinessException.class)\n    public String processBusinessException(BusinessException ex)&#123;\n        log.error(\"发生了业务相关的异常：\",ex);\n        return \"error\";\n    &#125;\n\n    @ExceptionHandler(Exception.class)\n    public String processException(Exception ex)&#123;\n        log.error(\"发生了其他的异常：\",ex);\n        return \"error\";\n    &#125;\n&#125;\n\n\n\n\n\n\n13、处理资源当我们使用了springmvc后，所有的请求都会交给springmvc进行管理，当然也包括静态资源，比如/static/js/index.js，这样的请求如果走了中央处理器，必然会抛出异常，因为没有与之对应的controller，这样我们可以使用一下配置进行处理：\n&lt;mvc:resources mapping=\"/js/**\" location=\"/static/js/\"/>\n&lt;mvc:resources mapping=\"/css/**\" location=\"/static/css/\"/>\n&lt;mvc:resources mapping=\"/img/**\" location=\"/static/img/\"/>\n\n经过这样的配置后，我们直接配置了请求url和路径的映射关系，就不会再走我们的前端控制器了。\n14、拦截器\nSpringMVC提供的拦截器类似于JavaWeb中的过滤器，只不过SpringMVC拦截器只拦截被前端控制器拦截的请求，而过滤器拦截从前端发送的【任意】请求。\n熟练掌握SpringMVC拦截器对于我们开发非常有帮助，在没使用权限框架(shiro，spring security)之前，一般使用拦截器进行认证和授权操作。\nSpringMVC拦截器有许多应用场景，比如：登录认证拦截器，字符过滤拦截器，日志操作拦截器等等。\n\n\n（1）自定义拦截器\n\n\n\n\n\n\n\n\nSpringMVC拦截器的实现一般有两种方式\n\n自定义的Interceptor类要实现了Spring的HandlerInterceptor接口。\n继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter。\n\npublic class LoginInterceptor implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;\n        return true;\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;&#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;&#125;\n&#125;\n\n（2）拦截器拦截流程\n（3）拦截器规则我们可以配置多个拦截器，每个拦截器中都有三个方法。下面将总结多个拦截器中的方法执行规律。\n\npreHandle：Controller方法处理请求前执行，根据拦截器定义的顺序，正向执行。\npostHandle：Controller方法处理请求后执行，根据拦截器定义的顺序，逆向执行。需要所有的preHandle方法都返回true时才会调用。\nafterCompletion：View视图渲染后处理方法：根据拦截器定义的顺序，逆向执行。preHandle返回true也会调用。\n\n（4）登录拦截器接下来编写一个登录拦截器，这个拦截器可以实现认证操作。就是当我们还没有登录的时候，如果发送请求访问我们系统资源时，拦截器不放行，请求失败。只有登录成功后，拦截器放行，请求成功。登录拦截器只要在preHandle()方法中编写认证逻辑即可，因为是在请求执行前拦截。代码实现如下：\n/**\n *  登录拦截器\n */\npublic class LoginInterceptor implements HandlerInterceptor &#123;\n    \n    /**\n        在执行Controller方法前拦截，判断用户是否已经登录，\n        登录了就放行，还没登录就重定向到登录页面\n    */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;\n        HttpSession session = request.getSession();\n        User user = session.getAttribute(\"user\");\n        if (user == null)&#123;\n            //还没登录，重定向到登录页面\n            response.sendRedirect(\"/toLogin\");\n        &#125;else &#123;\n            //已经登录，放行\n            return true;\n        &#125;\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;&#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;&#125;\n&#125;\n\n编写完SpringMVC拦截器，我们还需要在springmvc.xml配置文件中，配置我们编写的拦截器，配置代码如下：\n\n配置需要拦截的路径\n配置不需要拦截的路径\n配置我们自定义的拦截器类\n\n&lt;mvc:interceptors>\n    &lt;mvc:interceptor>\n        &lt;!--\n            mvc:mapping：拦截的路径\n            /**：是指所有文件夹及其子孙文件夹\n            /*：是指所有文件夹，但不包含子孙文件夹\n            /：Web项目的根目录\n        -->\n        &lt;mvc:mapping path=\"/**\"/>\n        &lt;!--\n                mvc:exclude-mapping：不拦截的路径,不拦截登录路径\n                /toLogin：跳转到登录页面\n                /login：登录操作\n            -->\n        &lt;mvc:exclude-mapping path=\"/toLogin\"/>\n        &lt;mvc:exclude-mapping path=\"/login\"/>\n        &lt;!--class属性就是我们自定义的拦截器-->\n        &lt;bean id=\"loginInterceptor\" class=\"com.ydlclass.interceptor.LoginInterceptor\"/>\n    &lt;/mvc:interceptor>\n&lt;/mvc:interceptors>\n\n\n\n15、全局配置类springmvc有一个可用作用于做全局配置的接口，这个接口是WebMvcConfigurer，在这个接口中有很多默认方法，每一个默认方法都可以进行一项全局配置，这些配置可以和我们配置文件的配置一一对应：这些配置在全局的xml中也可以进行配置：\n\n\n\n\n\n\n\n\n\n列举几个xml的配置\n&lt;!--处理静态资源-->\n&lt;mvc:resources mapping=\"/js/**\" location=\"/static/js/\"/>\n&lt;mvc:resources mapping=\"/css/**\" location=\"/static/css/\"/>\n&lt;mvc:resources mapping=\"/./image/**\" location=\"/static/./image/\"/>\n\n&lt;!--配置页面跳转-->\n&lt;mvc:view-controller path=\"/toGoods\" view-name=\"goods\"/>\n&lt;mvc:view-controller path=\"/toUpload\" view-name=\"upload\"/>\n&lt;mvc:view-controller path=\"/websocket\" view-name=\"websocket\"/>\n\n&lt;mvc:cors>\n    &lt;mvc:mapping path=\"/goods/**\" allowed-methods=\"*\"/>\n&lt;/mvc:cors>\n\n\n\n\n\n\n\n\n\n\n列举几个常用的WebMvcConfigurer的配置\n@Configuration\n@EnableWebMvc\npublic class MvcConfiguration implements WebMvcConfigurer &#123;\n    \n    // 拦截器进行配置\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(\"/**\")\n                .excludePathPatterns(List.of(\"/toLogin\",\"/login\"))\n                .order(1);\n    &#125;\n\n    // 资源的配置\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(\"/js/**\").addResourceLocations(\"/static/js/\");\n        registry.addResourceHandler(\"/css/**\").addResourceLocations(\"/static/css/\");\n    &#125;\n\n    // 跨域的全局配置\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n        registry.addMapping(\"/api/**\")\n                .allowedOrigins(\"*\")\n                .allowedMethods(\"GET\",\"POST\",\"PUT\",\"DELETE\")\n                .maxAge(3600);\n    &#125;\n\n    // 页面跳转的配置\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(\"/index\").setViewName(\"index\");\n    &#125;\n    \n&#125;\n\n\n\n五、跨域更多更详细的跨域的问题可以看我的另一个视频：https://www.bilibili.com/video/BV1nU4y1W7Rf，这个视频最后学完springboot以后看。\n1、同源策略同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。\n2、什么是跨域当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同时，就会产生跨域。\n\n举一个例子：从127.0.0.1:5000访问的页面中，有Javascript使用ajax访问127.0.0.1:8888的接口就会产生跨域；\n\n\n\n当前页面url\n被请求页面url\n是否跨域\n原因\n\n\n\nhttp://www.ydlclass.com/\nhttp://www.ydlclass.com/index.html\n不跨域\n同源（协议、域名、端口号相同）\n\n\nhttp://www.ydlclass.com/\nhttps://www.ydlclass.com/index.html\n跨域\n协议不同（http&#x2F;https）\n\n\nhttp://www.ydlclass.com/\nhttp://www.baidu.com/\n跨域\n主域名不同（test&#x2F;baidu）\n\n\nhttp://www.ydlclass.com/\nhttp://blog.ydlclass.com/\n跨域\n子域名不同（www&#x2F;blog）\n\n\nhttp://www.ydlclass.com:8080/\nhttp://www.ydlclass.com:7001/\n跨域\n端口号不同（8080&#x2F;7001）\n\n\n\n\n\n\n\n\n\n\n\n非同源限制\n\n无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。\n\n无法接触非同源网页的 DOM\n\n无法向非同源地址发送 AJAX 请求\n\n\n3、两种请求全称是”跨域资源共享”(Cross-origin resource sharing)；\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求：\n（1) 请求方法是以下三种方法之一：\n\nHEAD\n\nGET\n\nPOST\n\n\n（2）HTTP的头信息不超出以下几种字段：\n\nAccept\n\nAccept-Language\n\nContent-Language\n\nLast-Event-ID\n\nContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n\n这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。\n凡是不同时满足上面两个条件，就属于非简单请求。\n浏览器对这两种请求的处理，是不一样的。\n（1）简单请求\n\n\n\n\n\n\n\n\n基本流程\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。\n GET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.ydlclass.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\n如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n Access-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text/html; charset=utf-8\n\n上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。\n（1）Access-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n（2）Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\n（3）Access-Control-Expose-Headers\n该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。\n（4）withCredentials 属性\n上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。\nAccess-Control-Allow-Credentials: true\n\n另一方面，开发者必须在AJAX请求中打开withCredentials属性。\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。\nxhr.withCredentials = false;\n\n需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。\n（2）非简单请求\n\n\n\n\n\n\n\n\n预检请求\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。OPTIONS\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n下面是一段浏览器的JavaScript脚本。\nvar url = 'http://api.ydlclass.com/cors';\nvar xhr = new XMLHttpRequest();\nxhr.open('PUT', url, true);\nxhr.setRequestHeader('X-Custom-Header', 'value');\nxhr.send();\n\n上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。\n浏览器发现，这是一个非简单请求，就【自动】发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.ydlclass.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，”预检”请求的头信息包括两个特殊字段。\n（1）Access-Control-Request-Method\n该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\n（2）Access-Control-Request-Headers\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\n\n\n\n\n\n\n\n\n\n预检请求的响应\n服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n HTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\nAccess-Control-Allow-Origin: *\n\n如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\nXMLHttpRequest cannot load http://api.ydlclass.com.\nOrigin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n\n服务器回应的其他CORS相关字段如下。\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 1728000\n\n（1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n4、解决方案首先想到的就是使用过滤器进行统一的处理，当然在单个的servlet或者controller中也可以单独处理，基本的逻辑就是在响应的首部信息中加入需要的首部信息字段，解决方案如下：\npublic class CORSFilter implements Filter&#123;\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n    &#125;\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With\");\n        filterChain.doFilter(servletRequest, servletResponse);\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n对api为前缀的请求都进行处理：\n&lt;!-- CORS Filter -->\n&lt;filter>\n    &lt;filter-name>CORSFilter&lt;/filter-name>\n    &lt;filter-class>com.ydlclass.filter.CORSFilter&lt;/filter-class>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>CORSFilter&lt;/filter-name>\n    &lt;url-pattern>/api/*&lt;/url-pattern>\n&lt;/filter-mapping>\n\n到这里，就可以简单的实现 CORS 跨域请求了，上面的过滤器将会为所有请求的响应加上Access-Control-Allow-*首部，换言之就是允许来自任意源的请求来访问该服务器上的资源。而在实际开发中可以根据需要开放跨域请求权限以及控制响应头部等等。\n\n\n\n\n\n\n\n\n\nspringmvc给我们提供了更加简单的解决方案\n\n在Controller 上使用 @CrossOrigin 注解就可以实现跨域，这个注解是一个类级别也是方法级别的注解：\n\n@CrossOrigin(maxAge = 3600)\n@RestController \n@RequestMapping(\"goods\")\npublic class GoodsController&#123;\n&#125;\n\n如果同时在 Controller 和方法上都有使用@CrossOrigin 注解，那么在具体某个方法上的 CORS 属性将是两个注解属性合并的结果，如果属性的设置发生冲突，那么Controller 上的主机属性将被覆盖。\n我们也可以使用配置类进行全局的配置：\n@Configuration\n@EnableWebMvc\npublic class WebConfig extends WebMvcConfigurerAdapter &#123;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"*\")\n            .allowedMethods(\"PUT\", \"DELETE\")\n            .allowedHeaders(\"header1\", \"header2\", \"header3\")\n            .exposedHeaders(\"header1\", \"header2\")\n            .allowCredentials(false).maxAge(3600);\n    &#125;\n&#125;\n\n基于 XML 配置文件与上等效：\n&lt;mvc:cors>\n  &lt;mvc:mapping path=\"/api/**\"\n        allowed-origins=\"*\"\n        allowed-methods=\"GET, PUT\"\n        allowed-headers=\"header1, header2, header3\"\n        exposed-headers=\"header1, header2\" allow-credentials=\"false\"\n        max-age=\"123\" />\n\n    &lt;mvc:mapping path=\"/resources/**\"\n        allowed-origins=\"http://domain1.com\" />\n\n&lt;/mvc:cors>\n\n\n\n六、restful自从Roy Fielding博士在2000年他的博士论文中提出REST（Representational State Transfer）风格的软件架构模式后，REST就基本上成为Web API的标准了。\n\n\n\n\n\n\n\n\n\nrestful是一种风格，可以遵循，也可以不遵循，但是现在他已经变成主流。\n1、Rest架构的主要原则\n网络上的所有事物都被抽象为资源。\n每个资源都有一个唯一的资源标识符。\n同一个资源具有多种表现形式他可能是xml，也可能是json等。\n对资源的各种操作不会改变资源标识符。\n所有的操作都是无状态的。\n符合REST原则的架构方式即可称为RESTful。\n\n2、什么是RestfulRestful web service是一种常见的rest的应用,是遵守了rest风格的web服务，rest式的web服务是一种ROA(The Resource-Oriented Architecture)(面向资源的架构).\n在restful风格中，我们将互联网的资源抽象成资源，将获取资源的方式定义为方法，从此请求再也不止get和post了：\n\n\n\n客户端请求\n原来风格URL地址\nRESTful风格URL地址\n\n\n\n查询所有用户\n&#x2F;user&#x2F;findAll\nGET      &#x2F;user\n\n\n查询编号为1的用户\n&#x2F;user&#x2F;findById?id&#x3D;1\nGET      &#x2F;user&#x2F;1\n\n\n新增一个用户\n&#x2F;user&#x2F;save\nPOST     &#x2F;user\n\n\n修改编号为1的用户\n&#x2F;user&#x2F;update\nPUT      &#x2F;user&#x2F;1\n\n\n删除编号为1的用户\n&#x2F;user&#x2F;delete?id&#x3D;1\nDELETE &#x2F;user&#x2F;1\n\n\n\n\n\n\n\n\n\n\n\nSpring MVC 对 RESTful应用提供了以下支持\n\n利用@RequestMapping 指定要处理请求的URI模板和HTTP请求的动作类型\n利用@PathVariable讲URI请求模板中的变量映射到处理方法参数上\n利用Ajax,在客户端发出PUT、DELETE动作的请求\n\n3、数据过滤我们想获取所有用户，使用如下url即可/user。但是真是场景下，我们可能需要需要一些条件进行过滤：\n例如：我们需要查询名字叫张三的前10条数据，使用以下场景即可：\n/user?name=jerry&amp;pageSize=10&amp;page=1\n\n第一：查询的url不变，变的是条件，我们只需要同伙url获取对应的参数就能实现复杂的多条件查询。\n4、RequestMapping中指定请求方法@RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.GET)\n@RequestMapping(value = \"/add\", method = RequestMethod.POST)\n@RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.DELETE)   \n@RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.PUT)\n\n当然还有更好用的\n@GetMapping(\"/user/&#123;id&#125;\")\n@PostMapping(\"/user\")\n@DeleteMapping(\"/user/&#123;id&#125;\")\n@PutMapping(\"/user/&#123;id&#125;\")\n\n\n\n\n\n4、ajax还能这么玩可以采用Ajax方式发送PUT和DELETE请求\n\n\n\n\n\n\n\n\n\n我们可以使用当下比较流行的axios组件测试\n&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\">&lt;/script>\n&lt;script>\n    const instance = axios.create(&#123;\n        baseURL: 'http://127.0.0.1:8088/app/'\n    &#125;);\n    // 为给定 ID 的 user 创建请求\n    instance.get('goods')\n        .then(function (response) &#123;\n        console.log(response);\n    &#125;).catch(function (error) &#123;\n        console.log(error);\n    &#125;);\n\n    instance.get('goods/1')\n        .then(function (response) &#123;\n        console.log(response);\n    &#125;)\n        .catch(function (error) &#123;\n        console.log(error);\n    &#125;);\n\n    instance.post('goods', &#123;\n        name: '洗发露',\n        price: 25454\n    &#125;).then(function (response) &#123;\n        console.log(response);\n    &#125;).catch(function (error) &#123;\n        console.log(error);\n    &#125;);\n\n    instance.put('goods', &#123;\n        name: '洗发露',\n        price: 25454\n    &#125;).then(function (response) &#123;\n        console.log(response);\n    &#125;).catch(function (error) &#123;\n        console.log(error);\n    &#125;);\n\n    instance.delete('goods/1')\n        .then(function (response) &#123;\n        console.log(response);\n    &#125;).catch(function (error) &#123;\n        console.log(error);\n    &#125;);\n\n&lt;/script> \n\n\n\n\n\n\n\n\n\n\n\n\n当然，使用jquery同样可以发送如下请求\n$.ajax( &#123;\n    type : \"GET\",\n    url : \"http://localhost:8080/springmvc/user/rest/1\",\n    dataType : \"json\",\n    success : function(data) &#123;\n        console.log(\"get请求！---------------------\")\n        console.log(data)\n    &#125;\n&#125;);\n\n$.ajax( &#123;\n    type : \"DELETE\",\n    url : \"http://localhost:8080/springmvc/user/rest/1\",\n    dataType : \"json\",\n    success : function(data) &#123;\n        console.log(\"delete请求！---------------------\")\n        console.log(data)\n    &#125;\n&#125;);\n\n$.ajax( &#123;\n    type : \"put\",\n    url : \"http://localhost:8080/springmvc/user/rest/1\",\n    dataType : \"json\",\n    data: &#123;id:12,username:\"楠哥\",password:\"123\"&#125;,\n    success : function(data) &#123;\n        console.log(\"get请求！---------------------\")\n        console.log(data)\n    &#125;\n&#125;);\n\n$.ajax( &#123;\n    type : \"post\",\n    url : \"http://localhost:8080/springmvc/user/rest\",\n    dataType : \"json\",\n    data: &#123;id:12,username:\"楠哥\",password:\"123\"&#125;,\n    success : function(data) &#123;\n        console.log(\"get请求！---------------------\")\n        console.log(data)\n    &#125;\n&#125;);\n\n\n\n\n\n七、文件上传和下载一、文件上传【MultipartResolver】用于处理文件上传。当收到请求时，DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中【是否包含文件】。如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller。\n我们可以看到DispatcherServlet的核心方法中第一句就是如下的代码：\n\n注：MultipartResolver 默认不开启，需要手动开启。\n文件上传对前端表单有如下要求：为了能上传文件，必须将表单的【method设置为POST】，并将enctype设置为【multipart&#x2F;form-data】。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器。\n这里，我们对表单中的 enctype 属性做个详细的说明：\n\napplication&#x2F;x-www-form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。\n\nmultipart&#x2F;form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。\n\n\n&lt;form action=\"\" enctype=\"multipart/form-data\" method=\"post\">\n   &lt;input type=\"file\" name=\"file\"/>\n   &lt;input type=\"submit\">\n&lt;/form>\n\n一旦设置了enctype为multipart&#x2F;form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。\n\n\n\n\n\n\n\n\n\n在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet&#x2F;JSP程序员上传文件的最佳选择。\n1、我们同样需要导入这个jar包【commons-fileupload】，Maven会自动帮我们导入他的依赖包【commons-io】；\n&lt;!--文件上传-->\n&lt;dependency>\n   &lt;groupId>commons-fileupload&lt;/groupId>\n   &lt;artifactId>commons-fileupload&lt;/artifactId>\n   &lt;version>1.3.3&lt;/version>\n&lt;/dependency>\n\n2、配置bean：multipartResolver\n【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】\n&lt;!--文件上传配置-->\n&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n   &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\n   &lt;property name=\"defaultEncoding\" value=\"utf-8\"/>\n   &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） -->\n   &lt;property name=\"maxUploadSize\" value=\"10485760\"/>\n   &lt;property name=\"maxInMemorySize\" value=\"40960\"/>\n&lt;/bean>\n\nCommonsMultipartFile 的常用方法：\n\nString getOriginalFilename()：获取上传文件的原名\nInputStream getInputStream()：获取文件流\nvoid transferTo(File dest)：将上传文件保存到一个目录文件中\n\n 我们去实际测试一下\n3、编写前端页面\n&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n &lt;input type=\"file\" name=\"file\"/>\n &lt;input type=\"submit\" value=\"upload\">\n&lt;/form>\n\n4、Controller\n@PostMapping(\"/upload\")\n@ResponseBody\npublic R upload(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws Exception&#123;\n    //获取文件名 : file.getOriginalFilename();\n    String uploadFileName = file.getOriginalFilename();\n    System.out.println(\"上传文件名 : \"+uploadFileName);\n\n    //上传路径保存设置\n    String path = \"D:/upload\";\n    //如果路径不存在，创建一个\n    File realPath = new File(path);\n    if (!realPath.exists())&#123;\n        realPath.mkdir();\n    &#125;\n    System.out.println(\"上传文件保存地址：\"+realPath);\n    //就问香不香，就和你写读流一样\n    file.transferTo(new File(path+\"/\"+uploadFileName));\n\n    return R.success();\n&#125;\n\n5、测试上传文件，OK！\n小知识：我们在文件上传可以考虑以下几点：\n1、文件的原始信息，或者叫文件的元数据是不是可以存在数据库，具体应该怎么做？\n2、文件的上传目录能不能写在配置文件当中，这个应该怎么做？\n3、文件上传到服务器后可不可以安装一定的规则分目录存储，比如日期？\n4、思考怎么使用阿里云的oss进行图片存储？\n二、文件下载\n第一种可以直接向response的输出流中写入对应的文件流\n\n第二种可以使用 ResponseEntity&lt;byte[]&gt;来向前端返回文件\n\n\n1、传统方式@GetMapping(\"/download1\")\n@ResponseBody\npublic R download1(HttpServletResponse response)&#123;\n    FileInputStream fileInputStream = null;\n    ServletOutputStream outputStream = null;\n    try &#123;\n        // 这个文件名是前端传给你的要下载的图片的id\n        // 然后根据id去数据库查询出对应的文件的相关信息，包括url，文件名等\n        String  fileName = \"楠老师.jpg\";\n\n        //1、设置response 响应头，处理中文名字乱码问题\n        response.reset(); //设置页面不缓存,清空buffer\n        response.setCharacterEncoding(\"UTF-8\"); //字符编码\n        response.setContentType(\"multipart/form-data\"); //二进制传输数据\n        //设置响应头，就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名。\n        //Content-Disposition属性有两种类型：inline 和 attachment \n        //inline ：将文件内容直接显示在页面 \n        //attachment：弹出对话框让用户下载具体例子：\n        response.setHeader(\"Content-Disposition\",\n                           \"attachment;fileName=\"+ URLEncoder.encode(fileName, \"UTF-8\"));\n\n\t\t// 通过url获取文件\n        File file = new File(\"D:/upload/\"+fileName);\n        fileInputStream = new FileInputStream(file);\n        outputStream = response.getOutputStream();\n\n        byte[] buffer = new byte[1024];\n        int len;\n        while ((len = fileInputStream.read(buffer)) != -1)&#123;\n            outputStream.write(buffer,0,len);\n            outputStream.flush();\n        &#125;\n\n        return R.success();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n        return R.fail();\n    &#125;finally &#123;\n        if( fileInputStream != null )&#123;\n            try &#123;\n                fileInputStream.close();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if( outputStream != null )&#123;\n            try &#123;\n                outputStream.close();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n2、使用ResponseEntity@GetMapping(\"/download2\")\npublic ResponseEntity&lt;byte[]> download2()&#123;\n    try &#123;\n        String fileName = \"楠老师.jpg\";\n        byte[] bytes = FileUtils.readFileToByteArray(new File(\"D:/upload/\"+fileName));\n        HttpHeaders headers=new HttpHeaders();\n        // Content-Disposition就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名。\n        headers.set(\"Content-Disposition\",\"attachment;filename=\"+ URLEncoder.encode(fileName, \"UTF-8\"));\n        headers.set(\"charsetEncoding\",\"utf-8\");\n        headers.set(\"content-type\",\"multipart/form-data\");\n        ResponseEntity&lt;byte[]> entity=new ResponseEntity&lt;>(bytes,headers, HttpStatus.OK);\n        return entity;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n        return null;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n八、WebSocket1、WebSocket 简介WebSocket 协议提供了一种标准化方式，可通过单个 TCP 连接在客户端和服务器之间建立全双工、双向通信通道。它是与 HTTP 不同的 TCP 协议，但旨在通过 HTTP 工作，使用端口 80 和 443。\nWebSocket 交互以 HTTP 请求开始，HTTP请求中包含Upgrade: websocket  时，会切换到 WebSocket 协议。以下示例显示了这样的交互：\nGET /spring-websocket-portfolio/portfolio HTTP/1.1\nHost: localhost:8080\nUpgrade: websocket \nConnection: Upgrade \nSec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==\nSec-WebSocket-Protocol: v10.stomp, v11.stomp\nSec-WebSocket-Version: 13\nOrigin: http://localhost:8080\n\n成功握手后，HTTP 升级请求底层的 TCP 套接字保持打开状态，客户端和服务器都可以继续发送和接收消息。\n（1）HTTP 与 WebSocket尽管 WebSocket 被设计为与 HTTP 兼容并从 HTTP 请求开始，但这两种协议会产生不同的架构和应用程序编程模型。\n在 HTTP 和 REST 中，一个应用程序被建模为多个 URL。为了与应用程序交互，客户端访问这些 URL，请求-响应样式。服务器根据 HTTP URL、方法和请求头将请求路由到适当的处理程序。而在 WebSocket中，通常只有一个 URL 用于初始连接。随后，所有应用程序消息都在同一个 TCP 连接上流动。\n\n\n\n\n\n\n\n\n\n我们现在有一个需要，就是页面用实时显示当前的库存信息：\n短轮询:\n最简单的一种方式，就是你用JS写个死循环（setInterval），不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。\n这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。\n长轮询：\n长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。\n而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。　\n这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。\n但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。\n（2）何时使用 WebSocketWebSockets 可以使网页具有动态性和交互性。但是，在许多情况下，Ajax 和 HTTP 长轮询的组合可以提供简单有效的解决方案。\n例如，新闻、邮件和社交提要需要动态更新，但每隔几分钟更新一次可能也完全没问题。另一方面，协作、游戏和金融应用程序需要更接近实时。\n延迟本身并不是决定因素。如果消息量相对较低（例如监控网络故障），HTTP轮询可以提供有效的解决方案。低延迟、高频率和高容量的组合是使用 WebSocket 的最佳案例。\n2、实战案例Spring Framework 提供了一个 WebSocket API，您可以使用它来编写处理 WebSocket 消息的客户端和服务器端应用程序。\n（1）引入依赖\n&lt;dependency>\n    &lt;groupId>org.springframework&lt;/groupId>\n    &lt;artifactId>spring-websocket&lt;/artifactId>\n    &lt;version>5.2.18.RELEASE&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework&lt;/groupId>\n    &lt;artifactId>spring-messaging&lt;/artifactId>\n    &lt;version>5.2.18.RELEASE&lt;/version>\n&lt;/dependency>  \n\n\n\n（2）创建 WebSocket 服务器需要实现WebSocketHandler接口或者直接扩展TextWebSocketHandler或BinaryWebSocketHandler这两个类，使用起来相对简单一点。以下示例使用TextWebSocketHandler：\npublic class MessageHandler extends TextWebSocketHandler &#123;\n\n    Logger log = LoggerFactory.getLogger(MessageHandler.class);\n\n    //用来保存连接进来session\n    private List&lt;WebSocketSession> sessions = new CopyOnWriteArrayList&lt;>();\n\n    /**\n     * 关闭连接进入这个方法处理，将session从 list中删除\n     */\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;\n        sessions.remove(session);\n        log.info(\"&#123;&#125; 连接已经关闭，现从list中删除 ,状态信息&#123;&#125;\", session, status);\n    &#125;\n\n    /**\n     * 三次握手成功，进入这个方法处理，将session 加入list 中\n     */\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;\n        sessions.add(session);\n        log.info(\"用户&#123;&#125;连接成功.... \",session);\n    &#125;\n\n    /**\n     * 处理客户发送的信息，将客户发送的信息转给其他用户\n     */\n    @Override\n    public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?> message) throws Exception &#123;\n        log.info(\"收到来自客户端的信息: &#123;&#125;\",message.getPayload());\n        session.sendMessage(new TextMessage(\"当前时间：\"+\n                LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\")) +\",收到来自客户端的信息!\"));\n        for(WebSocketSession wss : sessions)\n            if(!wss.getId().equals(session.getId()))&#123;\n                wss.sendMessage(message);\n            &#125;\n    &#125;\n&#125;\n\n（3）有专用的 WebSocket Java 配置和 XML 命名空间支持，用于将前面的 WebSocket 处理程序映射到特定的 URL，如以下示例所示：\n@Configuration\n@EnableWebSocket\npublic class WebSocketConfig implements WebSocketConfigurer&#123;\n    \n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;\n        registry.addHandler(new MessageHandler(), \"/message\")\n        .addInterceptors(new HttpSessionHandshakeInterceptor())\n        .setAllowedOrigins(\"*\"); //允许跨域访问\n    &#125;\n&#125;\n\n以下示例显示了与前面示例等效的 XML 配置：\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/websocket\n        https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\n\n    &lt;websocket:handlers>\n        &lt;websocket:mapping path=\"/message\" handler=\"myHandler\"/>\n        &lt;websocket:handshake-interceptors>\n            &lt;bean class=\"org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor\"/>\n        &lt;/websocket:handshake-interceptors>\n    &lt;/websocket:handlers>\n\n    &lt;bean id=\"myHandler\" class=\"com.ydlclass.MessageHandler\"/>\n\n&lt;/beans>\n\n（4）使用原生js，用来访问websocket：\n&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n&lt;html>\n&lt;head>\n  &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n  &lt;title>websocket调试页面&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;div style=\"float: left; padding: 20px\">\n  &lt;strong>location:&lt;/strong> &lt;br />\n  &lt;input type=\"text\" id=\"serverUrl\" size=\"35\" value=\"\" /> &lt;br />\n  &lt;button onclick=\"connect()\">connect&lt;/button>\n  &lt;button onclick=\"wsclose()\">disConnect&lt;/button>\n  &lt;br /> &lt;strong>message:&lt;/strong> &lt;br /> &lt;input id=\"txtMsg\" type=\"text\" size=\"50\" />\n  &lt;br />\n  &lt;button onclick=\"sendEvent()\">发送&lt;/button>\n&lt;/div>\n\n&lt;div style=\"float: left; margin-left: 20px; padding-left: 20px; width: 350px; border-left: solid 1px #cccccc;\"> &lt;strong>消息记录&lt;/strong>\n  &lt;div style=\"border: solid 1px #999999;border-top-color: #CCCCCC;border-left-color: #CCCCCC; padding: 5px;width: 100%;height: 172px;overflow-y: scroll;\" id=\"echo-log\">&lt;/div>\n  &lt;button onclick=\"clearLog()\" style=\"position: relative; top: 3px;\">清除消息&lt;/button>\n&lt;/div>\n\n&lt;/div>\n&lt;/body>\n&lt;!-- 下面是h5原生websocket js写法 -->\n&lt;script type=\"text/javascript\">\n  let output ;\n  let websocket;\n  function connect()&#123; //初始化连接\n    output = document.getElementById(\"echo-log\")\n    let inputNode = document.getElementById(\"serverUrl\");\n    let wsUri = inputNode.value;\n    try&#123;\n      websocket = new WebSocket(wsUri);\n    &#125;catch(ex)&#123;\n      console.log(ex)\n      alert(\"对不起websocket连接异常\")\n    &#125;\n\n    connecting();\n    window.addEventListener(\"load\", connecting, false);\n  &#125;\n\n\n  function connecting()\n  &#123;\n    websocket.onopen = function(evt) &#123; onOpen(evt) &#125;;\n    websocket.onclose = function(evt) &#123; onClose(evt) &#125;;\n    websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;;\n    websocket.onerror = function(evt) &#123; onError(evt) &#125;;\n  &#125;\n\n  function sendEvent()&#123;\n    let msg = document.getElementById(\"txtMsg\").value\n    doSend(msg);\n  &#125;\n\n  //连接上事件\n  function onOpen(evt)\n  &#123;\n    writeToScreen(\"CONNECTED\");\n    doSend(\"WebSocket 已经连接成功！\");\n  &#125;\n\n  //关闭事件\n  function onClose(evt)\n  &#123;\n    writeToScreen(\"连接已经断开！\");\n  &#125;\n\n  //后端推送事件\n  function onMessage(evt)\n  &#123;\n    writeToScreen('&lt;span style=\"color: blue;\">服务器: ' + evt.data+'&lt;/span>');\n  &#125;\n\n  function onError(evt)\n  &#123;\n    writeToScreen('&lt;span style=\"color: red;\">异常信息:&lt;/span> ' + evt.data);\n  &#125;\n\n  function doSend(message)\n  &#123;\n    writeToScreen(\"客户端A: \" + message);\n    websocket.send(message);\n  &#125;\n\n  //清除div的内容\n  function clearLog()&#123;\n    output.innerHTML = \"\";\n  &#125;\n\n  //浏览器主动断开连接\n  function wsclose()&#123;\n    websocket.close();\n  &#125;\n\n  function writeToScreen(message)\n  &#123;\n    let pre = document.createElement(\"p\");\n    pre.innerHTML = message;\n    output.appendChild(pre);\n  &#125;\n&lt;/script>\n&lt;/html>\n\n\n\nws:127.0.0.1:8088&#x2F;app&#x2F;message\n\n我们可以看到在websocket的请求中有这样的首部信息：\n\n而且我们多次发送消息，并没有新的请求产生：\n\n小知识：我们经常看到有很多地方使用sockjs完成websocket的建立，原因是一些浏览器中缺少对WebSocket的支持。SockJS是一个浏览器JavaScript库，它提供了一个连贯的、跨浏览器的Javascript API，它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域通信通道。\n九、整合数据库，ssm结束\n\n\n\n\n\n\n\n\n其实就是spring整合mybatis，咱们尽量使用注解完成工作\n1、完整的依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>ssm-study&lt;/artifactId>\n        &lt;groupId>org.example&lt;/groupId>\n        &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;artifactId>spring-mvc-study&lt;/artifactId>\n    &lt;packaging>war&lt;/packaging>\n\n    &lt;dependencies>\n        &lt;!-- 测试相关 -->\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n            &lt;version>4.12&lt;/version>\n        &lt;/dependency>\n        &lt;!-- springmvc -->\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-webmvc&lt;/artifactId>\n            &lt;version>5.2.6.RELEASE&lt;/version>\n        &lt;/dependency>\n        &lt;!-- servlet -->\n        &lt;dependency>\n            &lt;groupId>javax.servlet&lt;/groupId>\n            &lt;artifactId>javax.servlet-api&lt;/artifactId>\n            &lt;version>4.0.0&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>javax.servlet.jsp&lt;/groupId>\n            &lt;artifactId>jsp-api&lt;/artifactId>\n            &lt;version>2.2&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n\n        &lt;!--文件上传-->\n        &lt;dependency>\n            &lt;groupId>commons-fileupload&lt;/groupId>\n            &lt;artifactId>commons-fileupload&lt;/artifactId>\n            &lt;version>1.4&lt;/version>\n        &lt;/dependency>\n        &lt;!-- jackson -->\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-core&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-annotations&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-databind&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- mybatis 相关 -->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis&lt;/artifactId>\n            &lt;version>3.5.2&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 数据库连接驱动 相关 -->\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;version>5.1.47&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- 提供了对JDBC操作的完整封装 -->\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-jdbc&lt;/artifactId>\n            &lt;version>5.1.10.RELEASE&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 织入 相关 -->\n        &lt;dependency>\n            &lt;groupId>org.aspectj&lt;/groupId>\n            &lt;artifactId>aspectjweaver&lt;/artifactId>\n            &lt;version>1.9.4&lt;/version>\n        &lt;/dependency>\n        &lt;!-- spring，mybatis整合包 -->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis-spring&lt;/artifactId>\n            &lt;version>2.0.2&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 集成德鲁伊使用 -->\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.18&lt;/version>\n        &lt;/dependency>\n\t\t&lt;!-- 日志 -->\n        &lt;dependency>\n            &lt;groupId>ch.qos.logback&lt;/groupId>\n            &lt;artifactId>logback-classic&lt;/artifactId>\n            &lt;version>1.2.3&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.12&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.slf4j&lt;/groupId>\n            &lt;artifactId>slf4j-api&lt;/artifactId>\n            &lt;version>1.7.30&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>ch.qos.logback&lt;/groupId>\n            &lt;artifactId>logback-classic&lt;/artifactId>\n            &lt;version>1.2.3&lt;/version>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n                &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n                &lt;version>3.1&lt;/version>\n                &lt;configuration>\n                    &lt;source>1.8&lt;/source> &lt;!-- 源代码使用的JDK版本 -->\n                    &lt;target>1.8&lt;/target> &lt;!-- 需要生成的目标class文件的编译版本 -->\n                    &lt;encoding>utf-8&lt;/encoding>&lt;!-- 字符集编码 -->\n                &lt;/configuration>\n            &lt;/plugin>\n        &lt;/plugins>\n        &lt;resources>\n            &lt;resource>\n                &lt;directory>src/main/java&lt;/directory>\n                &lt;includes>\n                    &lt;include>**/*.properties&lt;/include>\n                    &lt;include>**/*.xml&lt;/include>\n                &lt;/includes>\n                &lt;filtering>false&lt;/filtering>\n            &lt;/resource>\n            &lt;resource>\n                &lt;directory>src/main/resources&lt;/directory>\n                &lt;includes>\n                    &lt;include>**/*.properties&lt;/include>\n                    &lt;include>**/*.xml&lt;/include>\n                &lt;/includes>\n                &lt;filtering>false&lt;/filtering>\n            &lt;/resource>\n        &lt;/resources>\n    &lt;/build>\n\n&lt;/project>\n\n\n\n2、mybatis的配置文件mybatis-config.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n\n&lt;/configuration>\n\n\n\n3、springmvc配置文件springmvc-servlet.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n    &lt;!-- 自动扫包 -->\n    &lt;context:component-scan base-package=\"cn.itnanls\"/>\n    &lt;!-- 让Spring MVC不处理静态资源 -->\n    &lt;mvc:default-servlet-handler />\n    &lt;!--  让springmvc自带的注解生效  -->\n    &lt;mvc:annotation-driven >\n\n\n    &lt;/mvc:annotation-driven>\n    \n    &lt;bean id=\"fastjson\" class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">\n        &lt;property name=\"supportedMediaTypes\">\n            &lt;list>\n                &lt;value>text/html;charset=UTF-8&lt;/value>\n                &lt;value>application/json;charset=UTF-8&lt;/value>\n            &lt;/list>\n        &lt;/property>\n    &lt;/bean>\n\n    &lt;!--文件上传配置-->\n    &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\n        &lt;property name=\"defaultEncoding\" value=\"utf-8\"/>\n        &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） -->\n        &lt;property name=\"maxUploadSize\" value=\"10485760\"/>\n        &lt;property name=\"maxInMemorySize\" value=\"40960\"/>\n    &lt;/bean>\n\n    &lt;!-- 视图解析器 -->\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"         id=\"internalResourceViewResolver\">\n        &lt;!-- 前缀 -->\n        &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" />\n        &lt;!-- 后缀 -->\n        &lt;property name=\"suffix\" value=\".jsp\" />\n    &lt;/bean>\n&lt;/beans>\n\n4、数据源配置driver=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai\nusername=root\npassword=root\n\n\n\n5、spring配置文件\n\n\n\n\n\n\n\n\napplication.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    &lt;!-- 加载外部的数据库信息 classpath:不叫会报错具体原因下边解释-->\n    &lt;context:property-placeholder location=\"classpath:db.properties\"/>\n    &lt;!-- 加入springmvc的配置 -->\n    &lt;import resource=\"classpath:springmvc-servlet.xml\"/>\n\n    &lt;!-- Mapper 扫描器 -->\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        &lt;!-- 扫描 cn.wmyskxz.mapper 包下的组件 -->\n        &lt;property name=\"basePackage\" value=\"cn.itnanls.dao\"/>\n    &lt;/bean>\n\n    &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的-->\n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/>\n        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n    &lt;/bean>\n\n    &lt;!--配置SqlSessionFactory-->\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n        &lt;!--关联Mybatis-->\n        &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/*.xml\"/>\n    &lt;/bean>\n\n    &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory-->\n    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        &lt;!--利用构造器注入-->\n        &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    &lt;/bean>\n\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\" />\n    &lt;/bean>\n\n\n    &lt;!--配置事务通知-->\n    &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        &lt;tx:attributes>\n            &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性-->\n            &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"search*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        &lt;/tx:attributes>\n    &lt;/tx:advice>\n    &lt;!--配置aop织入事务-->\n    &lt;aop:config>\n        &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.ydlclass.service.impl.*.*(..))\"/>\n        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/>\n    &lt;/aop:config>\n\n&lt;/beans>\n\n6、web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    &lt;!--注册DispatcherServlet，这是springmvc的核心，就是个servlet-->\n    &lt;servlet>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n        &lt;init-param>\n            &lt;param-name>contextConfigLocation&lt;/param-name>\n            &lt;param-value>classpath:application.xml&lt;/param-value>\n        &lt;/init-param>\n        &lt;!--加载时先启动-->\n        &lt;load-on-startup>1&lt;/load-on-startup>\n    &lt;/servlet>\n    &lt;!--/ 匹配所有的请求；（不包括.jsp）-->\n    &lt;!--/* 匹配所有的请求；（包括.jsp）-->\n    &lt;servlet-mapping>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;url-pattern>/&lt;/url-pattern>\n    &lt;/servlet-mapping>\n    \n&lt;/web-app>\n\n\n\nMaven项目，application-context.xml、db.properties文件均放置在src&#x2F;main&#x2F;resources目录下，Tomcat部署项目，src&#x2F;main&#x2F;resources目录下的配置文件默认位置为：{项目名}&#x2F;WEB-INF&#x2F;classes，而Spring却在项目根目录下寻找，肯定找不到，因此，配置时指定classpath目录下寻找即可。\n解决方案如下：\n　　&lt;context:property-placeholder location=&quot;**classpath:db.properties**&quot; /&gt;\n配置文件完\n7、编写entity实体类/**\n * @author IT楠老师\n * @date 2020/5/19\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable&#123;\n\n    private int id;\n    private String username;\n    private String password;\n&#125;\n\n\n\n8、UserDao接口编写/**\n * @author IT楠老师\n * @date 2020/5/19\n */\n@Mapper\npublic interface UserMapper &#123;\n    /**\n     * 根据id查找用户\n     * @param id\n     * @return\n     */\n    User findUserById(int id);\n\n    /**\n     * 获取所有的用户\n     * @return\n     */\n    List&lt;User> findAllUsers();\n&#125;\n\n9、Mapper映射文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"cn.itnanls.dao.UserMapper\">\n    &lt;select id=\"findUserById\" resultType=\"cn.itnanls.entity.User\">\n      select id,username,password from user where id = #&#123;id&#125;\n    &lt;/select>\n\n    &lt;select id=\"findAllUsers\" resultType=\"cn.itnanls.entity.User\">\n      select id,username,password from user\n    &lt;/select>\n&lt;/mapper>\n\n10、编写service/**\n * @author IT楠老师\n * @date 2020/5/19\n */\npublic interface IUserService &#123;\n    /**\n     * 获取一个用户的信息\n     * @param id\n     * @return\n     */\n    User getUserInfo(int id);\n\n    /**\n     * 获取所有用户信息\n     * @return\n     */\n    List&lt;User> getAllUsers();\n&#125;\n\n/**\n * @author IT楠老师\n * @date 2020/5/19\n */\n@Service\npublic class UserServiceImpl implements IUserService &#123;\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    public User getUserInfo(int id) &#123;\n        return userMapper.findUserById(id);\n    &#125;\n\n    @Override\n    public List&lt;User> getAllUsers() &#123;\n        return userMapper.findAllUsers();\n    &#125;\n&#125;\n\n\n\n11、编写controller/**\n * @author IT楠老师\n * @date 2020/5/19\n */\n@Controller\n@RequestMapping(\"/user/\")\npublic class UserController &#123;\n\n    @Resource\n    IUserService userService;\n\n    @GetMapping(\"&#123;id&#125;\")\n    @ResponseBody\n    public User getUserInfo(@PathVariable int id)&#123;\n        return userService.getUserInfo(id);\n    &#125;\n\n    @GetMapping(\"/all\")\n    @ResponseBody\n    public List&lt;User> getUserInfo()&#123;\n        return userService.getAllUsers();\n    &#125;\n\n&#125;\n\n12、测试13、集成一个德鲁伊（1）更换数据源&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的-->\n&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\">\n    &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/>\n    &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n    &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n    &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n\n    &lt;property name = \"filters\" value = \"$&#123;filters&#125;\" />\n    &lt;!-- 最大并发连接数 -->\n    &lt;property name = \"maxActive\" value = \"$&#123;maxActive&#125;\" />\n    &lt;!-- 初始化连接数量 -->\n    &lt;property name = \"initialSize\" value = \"$&#123;initialSize&#125;\" />\n    &lt;!-- 配置获取连接等待超时的时间 -->\n    &lt;property name = \"maxWait\" value = \"$&#123;maxWait&#125;\" />\n    &lt;!-- 最小空闲连接数 -->\n    &lt;property name = \"minIdle\" value = \"$&#123;minIdle&#125;\" />\n    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->\n    &lt;property name = \"timeBetweenEvictionRunsMillis\" value =\"$&#123;timeBetweenEvictionRunsMillis&#125;\" />\n    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->\n    &lt;property name = \"minEvictableIdleTimeMillis\" value =\"$&#123;minEvictableIdleTimeMillis&#125;\" />\n    &lt;!--        &lt;property name = \"validationQuery\" value = \"$&#123;validationQuery&#125;\" />     -->\n    &lt;property name = \"testWhileIdle\" value = \"$&#123;testWhileIdle&#125;\" />\n    &lt;property name = \"testOnBorrow\" value = \"$&#123;testOnBorrow&#125;\" />\n    &lt;property name = \"testOnReturn\" value = \"$&#123;testOnReturn&#125;\" />\n    &lt;property name = \"maxOpenPreparedStatements\" value =\"$&#123;maxOpenPreparedStatements&#125;\" />\n    &lt;!-- 打开 removeAbandoned 功能 -->\n    &lt;property name = \"removeAbandoned\" value = \"$&#123;removeAbandoned&#125;\" />\n    &lt;!-- 1800 秒，也就是 30 分钟 -->\n    &lt;property name = \"removeAbandonedTimeout\" value =\"$&#123;removeAbandonedTimeout&#125;\" />\n    &lt;!-- 关闭 abanded 连接时输出错误日志 -->\n    &lt;property name = \"logAbandoned\" value = \"$&#123;logAbandoned&#125;\" />\n&lt;/bean>\n\n（2）增加db.properties内容jdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=root\n\nfilters=wall,stat\nmaxActive=20\ninitialSize=3\nmaxWait=5000\nminIdle=3\nmaxIdle=15\ntimeBetweenEvictionRunsMillis=60000\nminEvictableIdleTimeMillis=300000\nvalidationQuery=SELECT 'x'\ntestWhileIdle=true\ntestOnBorrow=false\ntestOnReturn=false\nmaxOpenPreparedStatements=20\nremoveAbandoned=true\nremoveAbandonedTimeout=1800\nlogAbandoned=true\n\n\n\n（3）开启web监控\n\n\n\n\n\n\n\n\n在web.xml中启动web服务\n&lt;!-- 连接池 启用 Web 监控统计功能    start-->\n&lt;filter>\n    &lt;filter-name>DruidWebStatFilter&lt;/filter-name>\n    &lt;filter-class>com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class>\n    &lt;init-param>\n        &lt;param-name>exclusions&lt;/param-name>\n        &lt;param-value>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value>\n    &lt;/init-param>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>DruidWebStatFilter&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n&lt;/filter-mapping>\n&lt;servlet>\n    &lt;servlet-name>DruidStatView &lt;/servlet-name>\n    &lt;servlet-class>com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class>\n    &lt;init-param>\n        &lt;!-- 用户名 -->\n        &lt;param-name>loginUsername&lt;/param-name>\n        &lt;param-value>itnanls&lt;/param-value>\n    &lt;/init-param>\n    &lt;init-param>\n        &lt;!-- 密码 -->\n        &lt;param-name>loginPassword&lt;/param-name>\n        &lt;param-value>123&lt;/param-value>\n    &lt;/init-param>\n&lt;/servlet>\n&lt;servlet-mapping>\n    &lt;servlet-name>DruidStatView&lt;/servlet-name>\n    &lt;url-pattern>/druid/*&lt;/url-pattern>\n&lt;/servlet-mapping>\n\n\n\n（4）测试，成功。14、集成日志框架（1）引入依赖&lt;dependency>\n  &lt;groupId>ch.qos.logback&lt;/groupId>\n  &lt;artifactId>logback-classic&lt;/artifactId>\n  &lt;version>1.2.3&lt;/version>\n&lt;/dependency>\n\n（2）新建配置文件在类路径下（src&#x2F;main&#x2F;resources）新建一个logback.xml文件这里贴出一个模板，下面会有解释\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n    &lt;!-- 定义参数常量 -->\n    &lt;!-- 日志级别 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR -->\n    &lt;!-- logger.trace(\"msg\") logger.debug... -->\n    &lt;property name=\"log.level\" value=\"debug\" />\n    &lt;property name=\"log.maxHistory\" value=\"30\" />\n    &lt;property name=\"log.filePath\" value=\"D:/log\" />\n    &lt;property name=\"log.pattern\"\n              value=\"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\" />\n    &lt;!-- 控制台输出设置 -->\n    &lt;appender name=\"consoleAppender\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n    &lt;!-- DEBUG级别文件记录 -->\n    &lt;appender name=\"debugAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;!-- 文件路径 -->\n        &lt;file>$&#123;log.filePath&#125;/debug.log&lt;/file>\n        &lt;!-- 滚动日志文件类型，就是每天都会有一个日志文件 -->\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;!-- 文件名称 -->\n            &lt;fileNamePattern>$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz\n            &lt;/fileNamePattern>\n            &lt;!-- 文件最大保存历史数量 -->\n            &lt;maxHistory>$&#123;log.maxHistory&#125;&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n        &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            &lt;level>DEBUG&lt;/level>\n            &lt;onMatch>ACCEPT&lt;/onMatch>\n            &lt;onMismatch>DENY&lt;/onMismatch>\n        &lt;/filter>\n    &lt;/appender>\n    &lt;!-- INFO -->\n    &lt;appender name=\"infoAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;!-- 文件路径 -->\n        &lt;file>$&#123;log.filePath&#125;/info.log&lt;/file>\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;!-- 文件名称 -->\n            &lt;fileNamePattern>$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log.gz\n            &lt;/fileNamePattern>\n            &lt;!-- 文件最大保存历史数量 -->\n            &lt;maxHistory>$&#123;log.maxHistory&#125;&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n        &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            &lt;level>INFO&lt;/level>\n            &lt;onMatch>ACCEPT&lt;/onMatch>\n            &lt;onMismatch>DENY&lt;/onMismatch>\n        &lt;/filter>\n    &lt;/appender>\n\n    &lt;!-- com.ydlclass开头的日志对应形式 -->\n    &lt;logger name=\"com.ydlclass\" level=\"$&#123;log.level&#125;\" additivity=\"true\">\n        &lt;appender-ref ref=\"debugAppender\"/>\n        &lt;appender-ref ref=\"infoAppender\"/>\n    &lt;/logger>\n    \n    &lt;!-- &lt;root> 是必选节点，用来指定最基础的日志输出级别，只有一个level属性 -->\n    &lt;root level=\"info\">\n        &lt;appender-ref ref=\"consoleAppender\"/>\n    &lt;/root>\n\n    &lt;!-- 捕捉sql开头的日志 -->\n    &lt;appender name=\"MyBatis\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;file>$&#123;log.filePath&#125;/sql_log/mybatis-sql.log&lt;/file>\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;FileNamePattern>$&#123;log.filePath&#125;/sql_log/mybatis-sql.log.%d&#123;yyyy-MM-dd&#125;&lt;/FileNamePattern>\n            &lt;maxHistory>30&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            &lt;pattern>%thread|%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;|%level|%logger&#123;36&#125;|%m%n&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n\n    &lt;logger name=\"sql\" level=\"DEBUG\">\n        &lt;appender-ref ref=\"MyBatis\"/>\n    &lt;/logger>\n\n&lt;/configuration>\n\n\n\nmybatis配置文件\n&lt;settings>\n\t&lt;setting name=\"logPrefix\" value=\"sql.\"/>\n&lt;/settings>\n\n\n\n（3）使用\n\n\n\n\n\n\n\n\n注意引入的包必须是org.slf4j.Logger和org.slf4j.LoggerFactory\n必须定义一个log变量才能打log，参数就填本类的class，这样打印日志才能准确定位啊\nprivate final Logger log = LoggerFactory.getLogger(UserController.class);\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class UserController &#123;\n\n    //定义一个log\n    private final Logger log = LoggerFactory.getLogger(UserController.class);\n\n\t....\n\tpublic void ....\n&#125;\n\n\n//在方法中合理使用log，使用哪个级别看这个日志的重要性\n@GetMapping(value = \"&#123;id&#125;\")\n@ResponseBody\npublic User getUserInfo(@PathVariable Integer id)&#123;\n    log.info(\"info\");\n    log.trace(\"trace\");\n    log.debug(\"debug\");\n    log.warn(\"warn\");\n    log.error(\"error\");\n\n    return userService.getUserInfo(id);\n&#125;\n\n\n\n（4）使用lombok在类上加注解：\n@Slf4j\npublic class UserController &#123;&#125;\n\n会在编译的时候自动加上\nprivate final Logger log = LoggerFactory.getLogger(UserController.class);\n\n所以这句话就不用写了。\n结束\n九、全部的配置文件：1、pom文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>ssm-study&lt;/artifactId>\n        &lt;groupId>org.example&lt;/groupId>\n        &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;artifactId>spring-mvc-study&lt;/artifactId>\n    &lt;packaging>war&lt;/packaging>\n\n    &lt;dependencies>\n        &lt;!-- 测试相关 -->\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n            &lt;version>4.12&lt;/version>\n        &lt;/dependency>\n        &lt;!-- springmvc -->\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-webmvc&lt;/artifactId>\n            &lt;version>5.2.6.RELEASE&lt;/version>\n        &lt;/dependency>\n        &lt;!-- servlet -->\n        &lt;dependency>\n            &lt;groupId>javax.servlet&lt;/groupId>\n            &lt;artifactId>javax.servlet-api&lt;/artifactId>\n            &lt;version>4.0.0&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>javax.servlet.jsp&lt;/groupId>\n            &lt;artifactId>jsp-api&lt;/artifactId>\n            &lt;version>2.2&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n\n        &lt;!--文件上传-->\n        &lt;dependency>\n            &lt;groupId>commons-fileupload&lt;/groupId>\n            &lt;artifactId>commons-fileupload&lt;/artifactId>\n            &lt;version>1.4&lt;/version>\n        &lt;/dependency>\n        &lt;!-- jackson -->\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-core&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-annotations&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n            &lt;artifactId>jackson-databind&lt;/artifactId>\n            &lt;version>2.11.2&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- mybatis 相关 -->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis&lt;/artifactId>\n            &lt;version>3.5.2&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 数据库连接驱动 相关 -->\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;version>5.1.47&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- 提供了对JDBC操作的完整封装 -->\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-jdbc&lt;/artifactId>\n            &lt;version>5.1.10.RELEASE&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 织入 相关 -->\n        &lt;dependency>\n            &lt;groupId>org.aspectj&lt;/groupId>\n            &lt;artifactId>aspectjweaver&lt;/artifactId>\n            &lt;version>1.9.4&lt;/version>\n        &lt;/dependency>\n        &lt;!-- spring，mybatis整合包 -->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis-spring&lt;/artifactId>\n            &lt;version>2.0.2&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 集成德鲁伊使用 -->\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.18&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>ch.qos.logback&lt;/groupId>\n            &lt;artifactId>logback-classic&lt;/artifactId>\n            &lt;version>1.2.3&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.12&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.18&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.slf4j&lt;/groupId>\n            &lt;artifactId>slf4j-api&lt;/artifactId>\n            &lt;version>1.7.30&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>ch.qos.logback&lt;/groupId>\n            &lt;artifactId>logback-classic&lt;/artifactId>\n            &lt;version>1.2.3&lt;/version>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n                &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n                &lt;version>3.1&lt;/version>\n                &lt;configuration>\n                    &lt;source>1.8&lt;/source> &lt;!-- 源代码使用的JDK版本 -->\n                    &lt;target>1.8&lt;/target> &lt;!-- 需要生成的目标class文件的编译版本 -->\n                    &lt;encoding>utf-8&lt;/encoding>&lt;!-- 字符集编码 -->\n                &lt;/configuration>\n            &lt;/plugin>\n        &lt;/plugins>\n        &lt;resources>\n            &lt;resource>\n                &lt;directory>src/main/java&lt;/directory>\n                &lt;includes>\n                    &lt;include>**/*.properties&lt;/include>\n                    &lt;include>**/*.xml&lt;/include>\n                &lt;/includes>\n                &lt;filtering>false&lt;/filtering>\n            &lt;/resource>\n            &lt;resource>\n                &lt;directory>src/main/resources&lt;/directory>\n                &lt;includes>\n                    &lt;include>**/*.properties&lt;/include>\n                    &lt;include>**/*.xml&lt;/include>\n                &lt;/includes>\n                &lt;filtering>false&lt;/filtering>\n            &lt;/resource>\n        &lt;/resources>\n    &lt;/build>\n\n&lt;/project>\n\n2、mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;settings>\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n        &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n        &lt;!-- 下划线转驼峰式 -->\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n        &lt;setting name=\"logPrefix\" value=\"sql.\"/>\n    &lt;/settings>\n    \n    &lt;typeAliases>\n        &lt;package name=\"cn.itnanls.entity\"/>\n    &lt;/typeAliases>\n    \n&lt;/configuration>\n\n3、springmvc-servlet.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    &lt;!-- 让Spring MVC不处理静态资源 -->\n    &lt;mvc:default-servlet-handler />\n    &lt;!--  让springmvc自带的注解生效  -->\n    &lt;mvc:annotation-driven >\n        &lt;mvc:message-converters>\n            &lt;bean id=\"fastjson\" class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">\n                &lt;property name=\"supportedMediaTypes\">\n                    &lt;list>\n                        &lt;value>text/html;charset=UTF-8&lt;/value>\n                        &lt;value>application/json;charset=UTF-8&lt;/value>\n                    &lt;/list>\n                &lt;/property>\n            &lt;/bean>\n        &lt;/mvc:message-converters>\n    &lt;/mvc:annotation-driven>\n\n\n    &lt;!--文件上传配置-->\n    &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\n        &lt;property name=\"defaultEncoding\" value=\"utf-8\"/>\n        &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） -->\n        &lt;property name=\"maxUploadSize\" value=\"10485760\"/>\n        &lt;property name=\"maxInMemorySize\" value=\"40960\"/>\n    &lt;/bean>\n\n    &lt;!-- 处理映射器 -->\n    &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n    &lt;!-- 处理器适配器 -->\n    &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView-->\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n        &lt;!--前缀-->\n        &lt;property name=\"prefix\" value=\"/WEB-INF/page/\"/>\n        &lt;!--后缀-->\n        &lt;property name=\"suffix\" value=\".jsp\"/>\n    &lt;/bean>\n&lt;/beans>\n\n4、db.propertiesjdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=root\n\nfilters=wall,stat\nmaxActive=20\ninitialSize=3\nmaxWait=5000\nminIdle=3\nmaxIdle=15\ntimeBetweenEvictionRunsMillis=60000\nminEvictableIdleTimeMillis=300000\nvalidationQuery=SELECT 'x'\ntestWhileIdle=true\ntestOnBorrow=false\ntestOnReturn=false\nmaxOpenPreparedStatements=20\nremoveAbandoned=true\nremoveAbandonedTimeout=1800\nlogAbandoned=true\n\n\n\n5、application.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    &lt;!-- 加载外部的数据库信息 classpath:不叫会报错具体原因下边解释-->\n    &lt;context:property-placeholder location=\"classpath:db.properties\"/>\n    &lt;!-- 加入springmvc的配置 -->\n    &lt;import resource=\"classpath:springmvc-servlet.xml\"/>\n\n    &lt;context:component-scan base-package=\"cn.itnanls\"/>\n\n    &lt;!-- Mapper 扫描器 -->\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        &lt;!-- 扫描 cn.wmyskxz.mapper 包下的组件 -->\n        &lt;property name=\"basePackage\" value=\"cn.itnanls.dao\"/>\n    &lt;/bean>\n\n    &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的-->\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/>\n        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n\n        &lt;property name = \"filters\" value = \"$&#123;filters&#125;\" />\n        &lt;!-- 最大并发连接数 -->\n        &lt;property name = \"maxActive\" value = \"$&#123;maxActive&#125;\" />\n        &lt;!-- 初始化连接数量 -->\n        &lt;property name = \"initialSize\" value = \"$&#123;initialSize&#125;\" />\n        &lt;!-- 配置获取连接等待超时的时间 -->\n        &lt;property name = \"maxWait\" value = \"$&#123;maxWait&#125;\" />\n        &lt;!-- 最小空闲连接数 -->\n        &lt;property name = \"minIdle\" value = \"$&#123;minIdle&#125;\" />\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->\n        &lt;property name = \"timeBetweenEvictionRunsMillis\" value =\"$&#123;timeBetweenEvictionRunsMillis&#125;\" />\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->\n        &lt;property name = \"minEvictableIdleTimeMillis\" value =\"$&#123;minEvictableIdleTimeMillis&#125;\" />\n        &lt;!--        &lt;property name = \"validationQuery\" value = \"$&#123;validationQuery&#125;\" />     -->\n        &lt;property name = \"testWhileIdle\" value = \"$&#123;testWhileIdle&#125;\" />\n        &lt;property name = \"testOnBorrow\" value = \"$&#123;testOnBorrow&#125;\" />\n        &lt;property name = \"testOnReturn\" value = \"$&#123;testOnReturn&#125;\" />\n        &lt;property name = \"maxOpenPreparedStatements\" value =\"$&#123;maxOpenPreparedStatements&#125;\" />\n        &lt;!-- 打开 removeAbandoned 功能 -->\n        &lt;property name = \"removeAbandoned\" value = \"$&#123;removeAbandoned&#125;\" />\n        &lt;!-- 1800 秒，也就是 30 分钟 -->\n        &lt;property name = \"removeAbandonedTimeout\" value =\"$&#123;removeAbandonedTimeout&#125;\" />\n        &lt;!-- 关闭 abanded 连接时输出错误日志 -->\n        &lt;property name = \"logAbandoned\" value = \"$&#123;logAbandoned&#125;\" />\n    &lt;/bean>\n\n    &lt;!--配置SqlSessionFactory-->\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n        &lt;!--关联Mybatis-->\n        &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/*.xml\"/>\n    &lt;/bean>\n\n    &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory-->\n    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        &lt;!--利用构造器注入-->\n        &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    &lt;/bean>\n\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\" />\n    &lt;/bean>\n\n\n    &lt;!--配置事务通知-->\n    &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        &lt;tx:attributes>\n            &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性-->\n            &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"search*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n            &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        &lt;/tx:attributes>\n    &lt;/tx:advice>\n    &lt;!--配置aop织入事务-->\n    &lt;aop:config>\n        &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* cn.itnanls.service.impl.*.*(..))\"/>\n        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/>\n    &lt;/aop:config>\n\n&lt;/beans>\n\n6、logback.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n    &lt;!-- 定义参数常量 -->\n    &lt;!-- 日志级别 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR -->\n    &lt;!-- logger.trace(\"msg\") logger.debug... -->\n    &lt;property name=\"log.level\" value=\"debug\" />\n    &lt;property name=\"log.maxHistory\" value=\"30\" />\n    &lt;property name=\"log.filePath\" value=\"D:/log\" />\n    &lt;property name=\"log.pattern\"\n              value=\"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\" />\n    &lt;!-- 控制台输出设置 -->\n    &lt;appender name=\"consoleAppender\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n    &lt;!-- DEBUG级别文件记录 -->\n    &lt;appender name=\"debugAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;!-- 文件路径 -->\n        &lt;file>$&#123;log.filePath&#125;/debug.log&lt;/file>\n        &lt;!-- 滚动日志文件类型，就是每天都会有一个日志文件 -->\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;!-- 文件名称 -->\n            &lt;fileNamePattern>$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz\n            &lt;/fileNamePattern>\n            &lt;!-- 文件最大保存历史数量 -->\n            &lt;maxHistory>$&#123;log.maxHistory&#125;&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n        &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            &lt;level>DEBUG&lt;/level>\n            &lt;onMatch>ACCEPT&lt;/onMatch>\n            &lt;onMismatch>DENY&lt;/onMismatch>\n        &lt;/filter>\n    &lt;/appender>\n    &lt;!-- INFO -->\n    &lt;appender name=\"infoAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;!-- 文件路径 -->\n        &lt;file>$&#123;log.filePath&#125;/info.log&lt;/file>\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;!-- 文件名称 -->\n            &lt;fileNamePattern>$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log.gz\n            &lt;/fileNamePattern>\n            &lt;!-- 文件最大保存历史数量 -->\n            &lt;maxHistory>$&#123;log.maxHistory&#125;&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder>\n            &lt;pattern>$&#123;log.pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n        &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            &lt;level>INFO&lt;/level>\n            &lt;onMatch>ACCEPT&lt;/onMatch>\n            &lt;onMismatch>DENY&lt;/onMismatch>\n        &lt;/filter>\n    &lt;/appender>\n\n    &lt;!-- com.ydlclass开头的日志对应形式 -->\n    &lt;logger name=\"com.ydlclass\" level=\"$&#123;log.level&#125;\" additivity=\"true\">\n        &lt;appender-ref ref=\"debugAppender\"/>\n        &lt;appender-ref ref=\"infoAppender\"/>\n    &lt;/logger>\n\n    &lt;!-- &lt;root> 是必选节点，用来指定最基础的日志输出级别，只有一个level属性 -->\n    &lt;root level=\"info\">\n        &lt;appender-ref ref=\"consoleAppender\"/>\n    &lt;/root>\n\n    &lt;!-- 捕捉sql开头的日志 -->\n    &lt;appender name=\"MyBatis\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        &lt;file>$&#123;log.filePath&#125;/sql_log/mybatis-sql.log&lt;/file>\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            &lt;FileNamePattern>$&#123;log.filePath&#125;/sql_log/mybatis-sql.log.%d&#123;yyyy-MM-dd&#125;&lt;/FileNamePattern>\n            &lt;maxHistory>30&lt;/maxHistory>\n        &lt;/rollingPolicy>\n        &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            &lt;pattern>%thread|%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;|%level|%logger&#123;36&#125;|%m%n&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n\n    &lt;logger name=\"sql\" level=\"DEBUG\">\n        &lt;appender-ref ref=\"MyBatis\"/>\n    &lt;/logger>\n\n&lt;/configuration>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"SpringMVC","date":"2022-10-14T02:15:00.000Z","categories_index":"java,框架,spring,web","tags_index":"java,框架,spring,web","author_index":"Leixng"},{"id":"946249c65165e1a3d66f50e0cb6e89e7","title":"Spring","content":"Spring教程\n\n\n\n\n\n\n\n\nB站：IT楠老师    微信号： itnanls    网站：www.ydlclass.com\n第一章 概述创始人：Rod Johnson，Java和J2EE开发领域的专家，Spring框架的创始人，同时也是SpringSource的联合创始人。\n\n一、Why Spring?（为什么使用spring）​\t\tSpring使Java编程对每个人来说更快、更容易、更安全。 Spring对速度、简单性和生产率的关注使它成为世界上最流行的Java框架。 spring给整个行业带来等了春天，为我们软件的开发带来了极大的便利。\n1、Spring is everywhere​\t\tSpring框架的足够灵活受到世界各地开发人员的信任。 无论是流媒体电视、在线购物、还是无数其他创新的解决方案，Spring每天都为数百万终端用户提供愉快的体验。 Spring也有来自所有科技巨头的贡献，包括阿里巴巴、亚马逊、谷歌、微软等。  \n2、Spring is flexible​\t\tSpring灵活而全面的扩展能力和第三方库让开发人员可以构建几乎任何可以想象到的应用程序。 Spring框架的【控制反转(IoC)】和【依赖注入(DI)】特性为一系列广泛的特性和功能提供了基础。 无论您是在为web构建安全的、响应式的、基于云的微服务，还是为企业构建复杂的流数据流，Spring都有工具可以提供帮助。  \n3、Spring is productive​\t\tSpring Boot（这是我们以后要学习的框架）改变了您处理Java编程任务的方式，从根本上简化了您的体验。 Spring Boot结合了应用程序上下文和自动配置的嵌入式web服务器等必要条件，使microservice开发变得轻而易举。 为了更快，您可以将Spring Boot与Spring Cloud丰富的支持库、服务器、模式和模板组合在一起，以创纪录的时间将整个基于微服务的架构安全地部署到云中。  \n4、Spring is fast​\t\t我们的工程师非常关心性能。 在Spring中，默认情况下，您会注意到快速启动、快速关闭和优化执行。 Spring项目也越来越多地支持reactive(nonblocking)编程模型，以获得更高的效率。 开发人员的生产力是Spring的超级力量。 Spring Boot帮助开发人员轻松地构建应用程序，而且比其他竞争方式要轻松得多。\n5、Spring is secure​\t\tSpring在处理安全问题方面十分可靠。 Spring代码的贡献者与安全专业人员一起修补和测试任何报告的漏洞。 第三方依赖关系也被密切监控，并定期发布更新，以帮助您的数据和应用程序尽可能安全。 此外，Spring Security使您更容易集成行业标准的安全方案，并交付可靠的默认安全解决方案。\n6、Spring is supportive​\t\tSpring社区是一个庞大的、全球性的、多样化的社区，涵盖了所有年龄和能力的人，从完全的初学者到经验丰富的专业人士。 无论你处在人生的哪个阶段，你都能找到帮助你进入下一个阶段的支持和资源。\n二、Spring 的特性\nCore technologies: dependency injection， events， resources， i18n， validation， data binding， type conversion， SpEL， AOP.\n​\t\t核心技术：包括依赖注入、事件模型、资源处理、国际化、数据绑定和验证、类型转化、spring表达式、面向切面编程。核心技术是一切的关键，后边衍生的多个特性都是依托于核心技术。\n\nTesting: mock objects， TestContext framework， Spring MVC Test， WebTestClient.\n\nData Access: transactions， DAO support， JDBC， ORM， Marshalling XML.\n\nSpring MVC and Spring WebFlux web frameworks.\n\nIntegration: remoting， JMS， JCA， JMX， email， tasks， scheduling， cache.\n\nLanguages: Kotlin， Groovy， dynamic languages.\n\n\n第二章 IOC 容器我们在学习本章知识之前首先需要了解一些常见的名词：\n\n\n\n\n\n\n\n\n\n容器：\n可以管理对象的生命周期、对象与对象之间的依赖关系。\n\n\n\n\n\n\n\n\n\nPOJO\n​\t\tPOJO（Plain Old Java Object）这种叫法是Martin Fowler、Rebecca Parsons和Josh MacKenzie在2000年的一次演讲的时候提出来的。按照Martin Fowler的解释是“Plain Old Java Object”，从字面上翻译为“纯洁老式的Java对象”，但大家都使用“简单java对象”来称呼它。POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。不允许有业务方法，也不能携带connection之类的方法，实际就是普通JavaBeans。\n\n\n\n\n\n\n\n\n\nJavaBean \n​\t\tJavaBean是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定：\n1、所有属性为private。\n2、这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。\n3、这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。\n4、这个类应是可序列化的。实现serializable接口。\n因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。\n\n\n\n\n\n\n\n\n\nPOJO与Java Bean的区别\n\n\n\nPOJO\nJAVABean\n\n\n\n除了Java语言强加的限制外，它没有其他特殊限制。\n这是一个特殊的POJO，它有一些限制。\n\n\n它没有对成员提供太多控制。\n它提供对成员的完全控制。\n\n\n它可以实现Serializable接口。\n它应该实现可序列化的接口。\n\n\n可以通过字段名称访问字段。\n字段只能由getter和setter访问。\n\n\n字段可以具有任何可见性。\n字段只有私人可见性。\n\n\n可能&#x2F;可能没有no-arg构造函数。\n它必须具有无参数构造函数。\n\n\n当您不想限制成员并让用户完全访问您的实体时使用它\n当您要向用户提供您的实体，但仅向实体的一部分提供服务时，将使用它。\n\n\n​        POJO类和Bean均用于定义Java对象，以提高其可读性和可重用性。POJO没有其他限制，而bean是具有某些限制的特殊POJO。\n\n\n\n\n\n\n\n\n\nSpringBean\n​\t\tSpringBean是受Spring管理的对象，所有能受Spring容器管理的对象都可以成为SpringBean。Spring中的bean，是通过配置文件、javaconfig等的设置，由Spring自动实例化，用完后自动销毁的对象。\n\n\n\n\n\n\n\n\n\nSpringBean和JavaBean的区别：\n1、用处不同：传统javabean更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean。\n2、写法不同：传统javabean作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法。\n3、生命周期不同：传统javabean作为值对象传递，不接受任何容器管理其生命周期；spring中的bean有spring管理其生命周期行为。\n\n\n\n\n\n\n\n\n\nEntity Bean\n​\t\tEntity Bean是域模型对象，用于实现O&#x2F;R映射，负责将数据库中的表记录映射为内存中的Entity对象，事实上，创建一个Entity Bean对象相当于新建一条记录，删除一个 Entity Bean会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。 \n一、概述\n\n\n\n\n\n\n\n\n编写spring代码，我们需要创建一个maven工程，并加入以下依赖：\n&lt;!-- Spring的核心组件 -->\n&lt;dependency>\n    &lt;groupId>org.springframework&lt;/groupId>\n    &lt;artifactId>spring-core&lt;/artifactId>\n    &lt;version>5.2.18.RELEASE&lt;/version>\n&lt;/dependency>\n&lt;!-- SpringIoC(依赖注入)的基础实现 -->\n&lt;dependency>\n    &lt;groupId>org.springframework&lt;/groupId>\n    &lt;artifactId>spring-beans&lt;/artifactId>\n    &lt;version>5.2.18.RELEASE&lt;/version>\n&lt;/dependency>\n&lt;!--Spring提供在基础IoC功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等 -->\n&lt;dependency>\n    &lt;groupId>org.springframework&lt;/groupId>\n    &lt;artifactId>spring-context&lt;/artifactId>\n    &lt;version>5.2.18.RELEASE&lt;/version>\n&lt;/dependency>\n\n\n\n\n\n\n\n\n\n\n\n\n本章介绍了Spring框架实现控制反转(IoC)的原理， IoC也称为依赖注入(DI)。 \n​\t\torg.springframework.beans和org.springframework.context包是Spring框架的IoC容器的基础。 \n​\t\tBeanFactory接口提供了一种高级的配置机制，能够管理任何类型的对象。 ApplicationContext是BeanFactory的子接口。 它对BeanFactory进行了补充:  \n\n更容易与Spring的AOP特性集成 。\n消息资源处理(用于国际化)  ，解析消息的能力，支持国际化。继承自MessageSource接口。\n事件发布，向注册侦听器发布事件的能力。继承自ApplicationEventPublisher接口。\n应用程序层特定的上下文，如WebApplicationContext用于web应用程序。  \n以通用方式加载文件资源的能力，继承自org.springframe .core.io.ResourceLoader接口。\n\n\n\n\n\n\n\n\n\n\nbeanFactory和ApplicationContext接口展示如下：\npublic interface BeanFactory &#123;&#125;\n\npublic interface ApplicationContext extends EnvironmentCapable， ListableBeanFactory， HierarchicalBeanFactory， MessageSource， ApplicationEventPublisher， ResourcePatternResolver &#123;&#125;\n\n\n\n​\t\t简而言之，BeanFactory提供了容器的基本功能，而ApplicationContext添加了更多特定于企业的功能。 ApplicationContext是BeanFactory的一个完整超集，仅在本章描述Spring的IoC容器时使用。 \n​\t\t在Spring中，由Spring IoC容器【管理】的构成【应用程序主干的对象】称为【bean】。 bean是由Spring IoC容器实例化、组装和管理的对象。 否则，bean只是应用程序中的众多对象之一。 bean及其之间的依赖关系反映在容器使用的【配置元数据】中。  \n​\t\t【applicationcontext】接口表示Spring IoC容器，并负责实例化、配置和组装bean。 容器通过读取配置元数据获得关于要实例化、配置和组装哪些对象的指令。 配置元数据以XML、Java注解或Java代码表示。 它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。   \n​\t\tSpring提供了ApplicationContext接口的几个实现。 \n​\t\t在独立应用程序中，创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例是很常见的。 虽然XML一直是定义配置元数据的传统格式，但您可以通过提供少量的XML配置以声明方式支持这些额外的元数据格式，指示容器使用Java注解或代码作为元数据格式。  \n二、配置元数据​\t\t构建【Spring IoC容器】可以通过构建配置元数据的方式。 这个【配置元数据】说的是：作为应用程序开发人员，您要告诉Spring容器如何去【实例化、配置和组装】应用程序中的对象。  【元数据】传统上以简单而直观的XML格式提供，本章的大部分内容都使用这种格式来传达Spring IoC容器的关键概念和特性。  \n下面的示例展示了基于xml的配置元数据的基本结构:  \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"...\" class=\"...\">  \n        &lt;!-- collaborators and configuration for this bean go here -->\n    &lt;/bean>\n\n    &lt;bean id=\"...\" class=\"...\">\n        &lt;!-- collaborators and configuration for this bean go here -->\n    &lt;/bean>\n\n    &lt;!-- more bean definitions go here -->\n\n&lt;/beans>\n\n\n‘ id ‘属性是标识单个beanDifination的字符串。  \n\n‘ class ‘属性定义bean的类型，并使用完全限定的类名。\n\n\n三、实例化一个容器​\t\tApplicationContext 的构造函数可以是【xml文件的位置路径】的字符串，它允许容器从各种外部资源（如本地文件系统、Java的 ‘ CLASSPATH ‘等）加载配置元数据。  \nApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\"， \"daos.xml\");\n\n下面的示例显示了服务层对象（services.xml）的配置文件:  \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;!-- services -->\n\n    &lt;bean id=\"petStore\" class=\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\">\n        &lt;property name=\"accountDao\" ref=\"accountDao\"/>\n        &lt;property name=\"itemDao\" ref=\"itemDao\"/>\n        &lt;!-- additional collaborators and configuration for this bean go here -->\n    &lt;/bean>\n\n    &lt;!-- more bean definitions for services go here -->\n\n&lt;/beans>\n\n下面的例子展示了数据访问对象（dao .xml ）配置文件:  \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"accountDao\"\n        class=\"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\">\n        &lt;!-- additional collaborators and configuration for this bean go here -->\n    &lt;/bean>\n\n    &lt;bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\">\n        &lt;!-- additional collaborators and configuration for this bean go here -->\n    &lt;/bean>\n\n    &lt;!-- more bean definitions for data access objects go here -->\n\n&lt;/beans>\n\n\n\n四、使用容器​\t\t【ApplicationContext】是一个高级工厂的接口，它维护了一个bean的注册列表，保存了容器产生的所有bean对象。 通过使用方法T getBean(String name， Class&lt;T&gt; requiredType) ，您可以检索bean的实例。  \n​\t\t【ApplicationContext】允许你读取和访问bean，如下面的示例所示:  \n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\"， \"daos.xml\");\n\n// retrieve configured instance，这里使用bean的标识符活class对象检索bean的事例。\nPetStoreService service = context.getBean(\"petStore\"， PetStoreService.class);\n\n// use configured instance\nList&lt;String> userList = service.getUsernameList();\n\n\n\n五、Bean的概述​\t\tSpring IoC容器管理一个或多个bean。 这些bean是使用您提供给容器的配置元数据创建的（例如，以XML&lt;bean/&gt;定义的形式）。  \n在容器本身中，这些定义好的【bean的元数据（描述bean的数据）】被表示为【BeanDefinition】对象，其中包含但不限于以下元数据：  \n\n全限定类名：通常是被定义的bean的实际【实现类】。  \nBean的行为配置元素：它声明Bean在容器中应该存在哪些行为（作用范围、生命周期回调等等）。  \nbean所需的其他bean的引用（成员变量）：这些引用也称为【协作者】或【依赖项】。\n\n接下来我们对其一一进行讲解：\n1、bean的命名​\t\t每个bean都有【一个或多个】标识符。 这些标识符在承载bean的容器（ioc容器）中必须是唯一的。 bean通常只有一个标识符。 但是，如果需要多个，则可以考虑使用别名。  \n​\t\t在【基于xml】的配置元数据中，可以使用’ id ‘属性、’ name ‘属性或两者同时使用，来指定bean的标识符。 ‘ id ‘属性允许您指定一个id，通常，这些名称是字母数字（’myBean’， ‘someService’等），但它们也可以包含特殊字符。 如果想为bean引入其他别名（一个或者多个都可以），还可以在’ name ‘属性中指定它们，由逗号(‘，’)、分号(‘;’)或空格分隔。\n​\t\t您甚至不需要为bean提供’ name ‘或’ id ‘。 如果您没有显式地提供’ name ‘或’ id ‘，容器将为该bean生成唯一的名称。 但是，如果您想通过名称引用该bean，则必须通过使用’ ref ‘元素来提供名称。 xml中默认的名字是【权限定名称#数字】。\n【bean命名约定】 \n​\t\t在命名bean时，bean名称以小写字母开头，并从那里开始采用驼峰式大小写。 这类名称的例子包括’ accountManager ‘、’ accountService ‘、’ userDao ‘、’ loginController ‘等等。  \n​\t\t 一致地命名bean可以使您的配置更容易阅读和理解。\n2、bean的别名​\t\t在bean的定义中，您可以为bean提供多个名称，方法是使用’ id ‘属性指定的最多一个名称和’ name ‘属性中任意数量的其他名称的组合。 这些名称可以是相同bean的等效别名，在某些情况下很有用，例如允许应用程序中的每个组件使用特定于该组件本身的bean名称来引用公共依赖项。 举一个简单的例子，一个人在家叫【狗蛋】，在公司叫【小刘】。\n​\t\t然而，在实际定义bean的地方指定所有别名并不一定能满足所有需求，有时需要为别处定义的bean（比如引入的jar包）引入别名。 这种情况在大型系统中很常见，其中配置在每个子系统之间被分割，每个子系统都有自己的一组对象定义。 在基于xml的配置元数据中，可以使用&lt;alias/&gt;元素来实现这一点。 下面的例子展示了如何做到这一点:  \n&lt;alias name=\"fromName\" alias=\"toName\"/>\n\n在这种情况下，一个名为【fromName】的bean被定义了一个新的别名【toName】。  \n​\t\t例如，子系统A的配置元数据可以以【subsystemA-dataSource】的名称引用数据源。 子系统B的配置元数据可以以【subsystemB-dataSource 】的名称引用数据源。 当编写使用这两个子系统的主应用程序时，主应用程序以【myApp-dataSource】的名称引用数据源。 要使这三个名称都指向同一个对象，您可以向配置元数据添加以下别名定义:  \n&lt;alias name=\"myApp-dataSource\" alias=\"subsystemA-dataSource\"/>\n&lt;alias name=\"myApp-dataSource\" alias=\"subsystemB-dataSource\"/>\n\n​\t\t现在，每个组件和主应用程序都可以通过唯一的名称来引用dataSource，并且保证不会与任何其他定义（有效地创建了一个名称空间）发生冲突，但它们引用的是相同的bean。  \n3、实例化bean​\t\tbeanDifination本质上是描述了一个bean是如何被创建的。 当被请求时，容器会查看指定bean的定义，并使用由该beanDifination封装的配置元数据来创建（或获取）实际对象。  \n​\t\t如果使用基于xml配置的元数据，则要在&lt;bean/&gt;元素的【class】属性中指定实例化的对象的类型。 这个’ class ‘属性（在内部是’ BeanDefinition ‘实例上的’ class ‘属性，一个bean的配置加载到内存会形成一个BeanDefinition事例）通常是强制性的。 你可以通过以下两种方式使用Class属性:  \n\n在容器中，如果是通过【反射调用其构造函数】直接创建bean，则要指定bean的类型，这有点类似于使用“new”操作符的Java代码。  \n这个类同样可以是用于创建对象的“静态”工厂方法的实际类，在这种情况下，容器调用该类上的【静态工厂方法来创建bean】。 调用静态工厂方法返回的对象类型可能是同一个类，也可能完全是另一个类，这要看你的工厂方法的具体实现。\n\n（1）使用构造函数实例化​\t\t当您通过构造函数方法创建bean时，所有普通类都可以被Spring使用并与Spring兼容。 也就是说，正在开发的类不需要实现任何特定的接口，也不需要以特定的方式编码。 只需指定bean类就足够了。 但是，这种情况下您可能需要一个默认（无参）构造函数。  \n\n\n\n\n\n\n\n\n\n使用基于xml的配置元数据，您可以使用如下方法，指定您的bean类:  \n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/>\n&lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>\n\n\n\n（2）使用静态工厂方法实例化​\t\t在使用【静态工厂方法】创建的bean时，使用【class】属性指定包含【一个静态工厂方法】的类，并使用名为【factory-method】的属性指定工厂方法本身的名称。 我们应该能够调用这个方法并返回一个对象事例。  \n\n\n\n\n\n\n\n\n\n下面的beanDifination指定通过调用工厂方法创建bean： \n 在这个例子中，createInstance()方法必须是一个静态方法，下面的示例演示如何指定工厂方法:  \n&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/>\n\n\n\n\n\n\n\n\n\n\n下面的示例显示了一个具有静态工厂方法的类：  \npublic class ClientService &#123;\n    private static ClientService clientService = new ClientService();\n    private ClientService() &#123;&#125;\n\n    public static ClientService createInstance() &#123;\n        return clientService;\n    &#125;\n&#125;\n\n（3）使用实例工厂方法实例化​\t\t该方法类似于通过（静态工厂方法）实例化所需的bean，容器同样可以使用【实例工厂方法】调用【非静态方法】创建一个新的bean。 要使用这种机制，请将【class】属性保留为空，并在【factory-bean】属性中指定当前容器中包含要调用的实例方法的bean的名称。 使用“factory-method”属性设置工厂方法本身的名称。 \n\n\n\n\n\n\n\n\n\n下面的示例演示如何配置这样的bean:  \n&lt;!-- the factory bean， which contains a method called createInstance() -->\n&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    &lt;!-- inject any dependencies required by this locator bean -->\n&lt;/bean>\n\n&lt;!-- the bean to be created via the factory bean -->\n&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/>\n\n\n\n\n\n\n\n\n\n\n下面的例子显示了相应的类:  \npublic class DefaultServiceLocator &#123;\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    public ClientService createClientServiceInstance() &#123;\n        return clientService;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n一个工厂类也可以包含多个工厂方法，如下例所示:  \n&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    &lt;!-- inject any dependencies required by this locator bean -->\n&lt;/bean>\n\n&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/>\n\n&lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/>\n\n下面的例子显示了相应的类:  \npublic class DefaultServiceLocator &#123;\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() &#123;\n        return clientService;\n    &#125;\n\n    public AccountService createAccountServiceInstance() &#123;\n        return accountService;\n    &#125;\n&#125;  \n\n注：其实我们这样明白一点，静态工厂方法可以直接调用，事例工厂方法需要容器先构建好事例再进行调用。\n六、依赖注入 Dependency Injection​\t\t依赖注入（DI）是一个【过程】（目前可以理解为给成员变量赋值的过程），在此过程中，对象仅通过【构造函数参数】、【工厂方法参数】等来确定它们的依赖项。 然后容器在创建bean时注入这些依赖项。 从根本上说，这个过程与bean本身相反(因此得名“控制反转”)。  \n​\t\t使用依赖注入的代码更清晰，并且在向对象提供依赖时【解耦更有效】。 \nDI主要有以下两种方式:\n\nConstructor-based依赖注入，基于构造器的依赖注入，本质上是使用构造器给成员变量赋值。\nSetter-based依赖注入，基于setter方法的依赖注入，本质上是使用set方法给成员变量赋值。\n\n1、基于构造函数的依赖注入\n\n\n\n\n\n\n\n\n基于构造器的依赖注入是通过容器调用带有许多参数的构造器来实现的，每个参数表示一个依赖项：\npublic class SimpleMovieLister &#123;\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n&#125;\n\n注意，这个类没有什么特别之处。 它是一个POJO，不依赖于容器特定的接口、基类或注解。  \n\n\n\n\n\n\n\n\n\n1、使用参数的顺序实现\n​        如果beanDifination的构造函数参数中不存在【潜在的歧义】，那么在beanDifination中定义【构造函数参数的顺序】就是在实例化bean时将这些参数提供给适当构造函数的顺序，我们可以看一下下边这个类:  \npackage x.y;\n\npublic class ThingOne &#123;\n\n    public ThingOne(ThingTwo thingTwo,ThingThree thingThree) &#123;\n        // ...\n    &#125;\n&#125;\n\n​       假设【ThingTwo】和【ThingThree】类没有继承关系，就不存在潜在的歧义。 因此，下面的配置工作正常，并且您不需要在&lt;constructor-arg/&gt; 元素中显式指定【构造函数参数索引或类型】。  \n&lt;beans>\n    &lt;bean id=\"beanOne\" class=\"x.y.ThingOne\">\n        &lt;!-- 直接写就可以 -->\n        &lt;constructor-arg ref=\"beanTwo\"/>\n        &lt;constructor-arg ref=\"beanThree\"/>\n    &lt;/bean>\n\n    &lt;bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n    &lt;bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n&lt;/beans>\n\n\n\n\n\n\n\n\n\n\n\n\n2、构造函数参数类型匹配  \n​        当引用另一个bean时，类型是已知的，可以进行匹配（如上例所示）。 当使用简单类型时，例如&lt;value&gt;true&lt;/value&gt; ， Spring无法确定值的类型，因此在没有帮助的情况下无法按类型匹配。 考虑以下官网提供的类: \npackage examples;\n\npublic class ExampleBean &#123;\n\n    // Number of years to calculate the Ultimate Answer\n    private final int years;\n\n    // The Answer to Life， the Universe， and Everything\n    private final String ultimateAnswer;\n\n    public ExampleBean(int years,String ultimateAnswer) &#123;\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    &#125;\n&#125;\n\n\n\n​        在前面的场景中，如果你通过使用【type】属性显式指定构造函数参数的类型，容器可以使用与简单类型匹配的类型，如下面的示例所示:  \n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    &lt;constructor-arg type=\"int\" value=\"7500000\"/>\n    &lt;constructor-arg type=\"java.lang.String\" value=\"42\"/>\n&lt;/bean>\n\n\n\n\n\n\n\n\n\n\n\n\n3、按照构造函数参数的下标匹配 \n你可以使用【index】属性显式指定构造函数参数的索引，如下例所示:  \n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    &lt;constructor-arg index=\"0\" value=\"7500000\"/>\n    &lt;constructor-arg index=\"1\" value=\"42\"/>\n&lt;/bean>\n\n除了解决多个简单值的歧义之外，指定索引还解决构造函数具有相同类型的两个参数的歧义。  \n\n\n\n\n\n\n\n\n\n4、按照构造函数参数的名字匹配  \n还可以使用构造函数参数名来消除值的歧义，如下面的示例所示:  \n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    &lt;constructor-arg name=\"years\" value=\"7500000\"/>\n    &lt;constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n&lt;/bean>\n\n2、基于setter的注入​\t\t基于setter的DI是通过容器在【调用无参数构造函数】或【无参数“静态”工厂方法】实例化bean后调用bean上的setter方法来实现的。  \n​\t\t下面的示例显示了一个只能通过使用纯setter注入进行依赖注入的类。 这个类是传统的Java。 它是一个POJO，不依赖于容器特定的接口、基类或注解。  \npublic class SimpleMovieLister &#123;\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n&#125;\n\n​\t\t\n​      【ApplicationContext】支持它管理的bean的【基于构造函数】和【基于setter】的依赖注入。 在已经通过构造函数方法注入了一些依赖项之后，它还支持基于setter的DI。也就意味着先通过有参构造构建对象，再通过setter方法进行特殊值的赋值。\n\n\n\n\n\n\n\n\n\n下面的元数据配置示例为【基于setter】的DI方式：\n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    &lt;!-- setter injection using the nested ref element -->\n    &lt;property name=\"beanOne\">\n        &lt;ref bean=\"anotherExampleBean\"/>\n    &lt;/property>\n\n    &lt;!-- setter injection using the neater ref attribute -->\n    &lt;property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    &lt;property name=\"integerProperty\" value=\"1\"/>\n&lt;/bean>\n\n&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n\n\n\n\n\n\n\n\n\n\n下面的示例显示了相应的【ExampleBean】类:  \npublic class ExampleBean &#123;\n\n    private AnotherBean beanOne;\n\n    private YetAnotherBean beanTwo;\n\n    private int i;\n\n    public void setBeanOne(AnotherBean beanOne) &#123;\n        this.beanOne = beanOne;\n    &#125;\n\n    public void setBeanTwo(YetAnotherBean beanTwo) &#123;\n        this.beanTwo = beanTwo;\n    &#125;\n\n    public void setIntegerProperty(int i) &#123;\n        this.i = i;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n其他情况\n​        现在考虑这个例子的一个变体，在这里，Spring不是使用构造函数，而是被告知调用一个【static】工厂方法来返回对象的一个实例:  \n&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\" factory-method=\"createInstance\">\n    &lt;constructor-arg ref=\"anotherExampleBean\"/>\n    &lt;constructor-arg ref=\"yetAnotherBean\"/>\n    &lt;constructor-arg value=\"1\"/>\n&lt;/bean>\n\n&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n\n下面的示例显示了相应的’ ExampleBean ‘类:\npublic class ExampleBean &#123;\n\n    // a private constructor\n    private ExampleBean(...) &#123;\n        ...\n    &#125;\n\n    // a static factory method; the arguments to this method can be\n    // considered the dependencies of the bean that is returned，\n    // regardless of how those arguments are actually used.\n    public static ExampleBean createInstance (\n        AnotherBean anotherBean， YetAnotherBean yetAnotherBean， int i) &#123;\n\n        ExampleBean eb = new ExampleBean (...);\n        // some other operations...\n        return eb;\n    &#125;\n&#125;\n\n​\t\t【static】工厂方法的参数是由&lt;constructor-arg/&gt; 元素提供的，就像实际使用了构造函数一样。spring会根据元数据构造工厂对象，再由工厂对象创建实例，创建的实例交由spring容器管理。\n3、基于构造函数还是基于setter的依赖注入?​\t\t由于您可以混合使用基于构造函数和基于setter的DI，一般情况下，我们对于【强制性依赖项】使用构造函数，对于【可选依赖项】使用setter方法注入，这是一个很好的经验法则。 注意，在setter方法上使用【@Required】注解可以使属性成为必需依赖项。  \n​\t\tSpring团队通常提倡构造函数注入，因为它允许你将应用程序组件实现为不可变的对象，并确保所需的依赖项不是”空“的。 而且，构造函数注入的组件总是以完全初始化的状态返回给客户端(调用)代码。   \n​\t\tSetter注入主要应该只用于可选依赖项，这些依赖项可以在类中分配合理的默认值。 setter注入的一个好处是，setter方法使该类的对象能够在稍后进行重新配置或重新注入。 \n​\t\t有时，在处理您没有源代码的第三方类时，您可以自行选择。 例如，如果第三方类不公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。   \n4、依赖关系和配置细节​\t\t从上边的课程我们知道，可以将【bean属性】和【构造函数参数】定义为对【其他合作者bean(合作者)的引用】。 Spring基于xml配置的元数据应该为其&lt;property/&gt; 和&lt;constructor-arg/&gt;元素中支持多样的元素类型。  \n（1）直接值(原语、字符串等)​\t\t&lt;property/&gt; 元素的【value】属性将【属性或构造函数参数】指定为人类可读的字符串表示形式。 Spring的【类型转化器】用于将这些值从’ String ‘转换为属性或参数的实际类型（比如数字类型，甚至是对象）。 \n下面的示例显示了正在设置的各种值:  \n&lt;bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n    &lt;!-- results in a setDriverClassName(String) call -->\n    &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/>\n    &lt;property name=\"username\" value=\"root\"/>\n    &lt;property name=\"password\" value=\"misterkaoli\"/>\n&lt;/bean>\n\n（2）idref元素​      【idref 】元素只是将容器中另一个bean的【id 字符串值-不是引用】传递给·&lt;constructor-arg/&gt; 或&lt;property/&gt; 元素的一种防错误方法。 下面的例子展示了如何使用它:  \n&lt;bean id=\"theTargetBean\" class=\"...\"/>\n\n&lt;bean id=\"theClientBean\" class=\"...\">\n    &lt;property name=\"targetName\">\n        &lt;idref bean=\"theTargetBean\"/>\n    &lt;/property>\n&lt;/bean>\n\n前面的beanDifination代码段(在运行时)与下面的代码段完全相同:  \n&lt;bean id=\"theTargetBean\" class=\"...\" />\n\n&lt;bean id=\"client\" class=\"...\">\n    &lt;property name=\"targetName\" value=\"theTargetBean\"/>\n&lt;/bean>\n\n​\t\t第一种形式比第二种形式更可取，因为使用’ idref ‘标记可以让容器在部署时【验证所引用的已命名bean是否实际存在】。 在第二个变体中，没有对传递给”theClientBean”的【targetName】属性的值执行验证。 只有在实际实例化【theClientBean】时才会发现拼写错误（很可能导致致命的结果）。 如果“客户端”bean是一【prototype bean马上要讲到】，那么这个错误和由此产生的异常可能只有在容器部署很久之后才会被发现。  \n（3）对其他bean的引用(Collaborators合作者)​\t\t【ref】元素是&lt;constructor-arg/&gt; 或&lt;property/&gt; 定义元素中的最后一个元素。 在这里，您将bean的指定属性的值设置为容器管理的另一个bean（合作者bean）的引用。 被引用的bean是要设置其属性的bean的依赖项，并且在设置属性之前根据需要初始化它。\n​\t\t通过&lt;ref/&gt; 标记的【bean属性】指定目标bean是最常用的一种形式，它允许创建同一容器中的任何bean的引用，而不管它是否在同一XML文件中。 【bean属性】的值可以与目标bean的【id】属性相同，也可以与目标bean的【name】属性中的一个值相同。 下面的例子展示了如何使用【ref】元素:  \n&lt;bean id=\"accountService\" class=\"com.something.SimpleAccountService\">\n    &lt;!-- insert dependencies as required here -->\n&lt;/bean>\n\n&lt;bean id=\"accountService\" &lt;!-- bean name is the same as the parent bean -->\n    class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    &lt;property name=\"target\">\n        &lt;ref bean=\"accountService\"/> &lt;!-- notice how we refer to the parent bean -->\n    &lt;/property>\n    &lt;!-- insert other configuration and dependencies as required here -->\n&lt;/bean>\n\n\n\n（4）内部bean\n\n\n\n\n\n\n\n\n在&lt;property/&gt; 或&lt;constructor-arg/&gt; 元素内部的’&lt;bean/&gt; 元素定义了一个内部bean，如下面的例子所示:  \n&lt;bean id=\"outer\" class=\"...\">\n    &lt;!-- instead of using a reference to a target bean， simply define the target bean inline -->\n    &lt;property name=\"target\">\n        &lt;bean class=\"com.example.Person\"> &lt;!-- this is the inner bean -->\n            &lt;property name=\"name\" value=\"Fiona Apple\"/>\n            &lt;property name=\"age\" value=\"25\"/>\n        &lt;/bean>\n    &lt;/property>\n&lt;/bean>\n\n​        内部bean总是匿名的，并且总是与外部bean一起创建的。 不可能独立地访问内部bean，也不可能将它们注入到外围bean之外的协作bean中。  \n​     \n（5）集合​\t\t &lt;list/&gt;， &lt;set/&gt;， &lt;map/&gt;， 和 &lt;props/&gt; 元素分别设置 Java Collection 类型 List， Set， Map，和 Properties的属性和参数。 下面的例子展示了如何使用它们: \n&lt;bean id=\"moreComplexObject\" class=\"example.ComplexObject\">\n    &lt;!-- results in a setAdminEmails(java.util.Properties) call -->\n    &lt;property name=\"adminEmails\">\n        &lt;props>\n            &lt;prop key=\"administrator\">administrator@example.org&lt;/prop>\n            &lt;prop key=\"support\">support@example.org&lt;/prop>\n            &lt;prop key=\"development\">development@example.org&lt;/prop>\n        &lt;/props>\n    &lt;/property>\n    &lt;!-- results in a setSomeList(java.util.List) call -->\n    &lt;property name=\"someList\">\n        &lt;list>\n            &lt;value>a list element followed by a reference&lt;/value>\n            &lt;ref bean=\"myDataSource\" />\n        &lt;/list>\n    &lt;/property>\n    &lt;!-- results in a setSomeMap(java.util.Map) call -->\n    &lt;property name=\"someMap\">\n        &lt;map>\n            &lt;entry key=\"an entry\" value=\"just some string\"/>\n            &lt;entry key=\"a ref\" value-ref=\"myDataSource\"/>\n        &lt;/map>\n    &lt;/property>\n    &lt;!-- results in a setSomeSet(java.util.Set) call -->\n    &lt;property name=\"someSet\">\n        &lt;set>\n            &lt;value>just some string&lt;/value>\n            &lt;ref bean=\"myDataSource\" />\n        &lt;/set>\n    &lt;/property>\n&lt;/bean>\n\n映射键或值或集合值的值也可以是以下元素中的任何一个:  \nbean | ref | idref | list | set | map | props | value | null\n\n\n\n（6）null值和空字符串​        Spring将属性的【空参数】等作为空字符串处理，以下基于xml的配置元数据片段将’ email ‘属性设置为空字符(“”)。  \n&lt;bean class=\"ExampleBean\">\n    &lt;property name=\"email\" value=\"\"/>\n&lt;/bean>\n\n上面的例子等价于下面的Java代码:  \nexampleBean.setEmail(\"\");\n\n &lt;null/&gt;元素处理 null值。 下面的例子显示了一个示例: \n&lt;bean class=\"ExampleBean\">\n    &lt;property name=\"email\">\n        &lt;null/>\n    &lt;/property>\n&lt;/bean>\n\n上述配置相当于以下Java代码:  \nexampleBean.setEmail(null);\n\n\n\n（7）带有【p命名空间】的XML配置方式​\t\t【p-名称空间】允许您使用【bean元素的属性】（而不是嵌套的&lt;property/&gt;元素）来描述协作bean的属性值，或者两者都使用。说的简单一点就是另外一种写法。  \n\n\n\n\n\n\n\n\n\n下面的示例显示了两个XML片段(第一个使用标准XML格式，第二个使用p-名称空间)，它们解析相同的结果:  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean name=\"classic\" class=\"com.example.ExampleBean\">\n        &lt;property name=\"email\" value=\"someone@somewhere.com\"/>\n    &lt;/bean>\n\n    &lt;bean name=\"p-namespace\" class=\"com.example.ExampleBean\"\n        p:email=\"someone@somewhere.com\"/>\n&lt;/beans>\n\n\n\n\n\n\n\n\n\n\n下一个例子包括另外两个beanDifination，它们都引用了另一个bean:  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean name=\"john-classic\" class=\"com.example.Person\">\n        &lt;property name=\"name\" value=\"John Doe\"/>\n        &lt;property name=\"spouse\" ref=\"jane\"/>\n    &lt;/bean>\n\n    &lt;bean name=\"john-modern\"\n        class=\"com.example.Person\"\n        p:name=\"John Doe\"\n        &lt;!--p命名空间支持这样定义的bean的引用-->\n        p:spouse-ref=\"jane\"/>\n\n    &lt;bean name=\"jane\" class=\"com.example.Person\">\n        &lt;property name=\"name\" value=\"Jane Doe\"/>\n    &lt;/bean>\n&lt;/beans>\n\n我们建议您仔细选择方法，并将其告知您的团队成员，用以形成规范的统一的XML文档。\n（8）带有c命名空间的XML快捷方式​        与带有p-名称空间的XML配置方式类似，在Spring 3.1中引入的【c-名称空间】允许内联属性来配置构造函数参数，而不是嵌套的【constructor-arg】元素。  \n\n\n\n\n\n\n\n\n\n下面的例子使用了【c: 命名空间】来完成与【基于构造器的依赖注入】:  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:c=\"http://www.springframework.org/schema/c\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n    &lt;bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n\n    &lt;!-- traditional declaration with optional argument names -->\n    &lt;bean id=\"beanOne\" class=\"x.y.ThingOne\">\n        &lt;constructor-arg name=\"thingTwo\" ref=\"beanTwo\"/>\n        &lt;constructor-arg name=\"thingThree\" ref=\"beanThree\"/>\n        &lt;constructor-arg name=\"email\" value=\"something@somewhere.com\"/>\n    &lt;/bean>\n\n    &lt;!-- c-namespace declaration with argument names -->\n    &lt;bean id=\"beanOne\" class=\"x.y.ThingOne\" c:thingTwo-ref=\"beanTwo\"\n        c:thingThree-ref=\"beanThree\" c:email=\"something@somewhere.com\"/>\n\n&lt;/beans>\n\n【c: 命名空间】通过名称设置构造函数参数。 类似地，它需要在XML文件中声明对应的命名空间。  \n\n\n\n\n\n\n\n\n\n对于【构造函数参数名不可用的罕见情况】(通常是在没有调试信息的情况下编译字节码)，可以使用回退参数索引，如下所示:  \n&lt;!-- c-namespace index declaration -->\n&lt;bean id=\"beanOne\" class=\"x.y.ThingOne\" c:_0-ref=\"beanTwo\" c:_1-ref=\"beanThree\"\n    c:_2=\"something@somewhere.com\"/>\n\n​\t\t由于XML语法的原因，索引表示法要求出现前导’ _ ‘，因为XML属性名不能以数字开头(尽管一些ide允许它)。 对于&lt;constructor-arg&gt;元素也有相应的索引表示法，但不常用，因为一般的声明顺序就足够了。\n​\t\t实际上，【构造函数解析机制】在匹配参数方面非常有效，所以除非真的需要，否则我们建议在整个配置中使用名称表示法。  \n（9）复合属性名当您设置bean属性时，您可以使用复合或嵌套属性名，只要路径的所有组件（除了最终属性名）不为’ null ‘。 考虑以下beanDifination:  \n&lt;bean id=\"something\" class=\"things.ThingOne\">\n    &lt;property name=\"fred.bob.sammy\" value=\"123\" />\n&lt;/bean>\n\n​\t\t【 something】bean有一个【 fred 】属性，fred 属性有一个【bob】属性，bob 属性有一个【sammy】’属性，最后的【sammy】属性的值被设置为’123’。 为了使其工作，在构造bean之后，’ something ‘的’ fred ‘属性和’ fred ‘的’ bob ‘属性不能为’ null ‘。 否则，抛出一个NullPointerException。  \n（10）延迟初始化的 Bean​\t\t默认情况下，【ApplicationContext】实现会作为初始化过程的一部分，会在容器初始化的时候急切地创建和配置所有【singleton bean】。 通常，这种预实例化是可取的，因为配置或周围环境中的错误可以被立马发现，而不是几个小时甚至几天之后（调用一个方法，创建一个实例的时候等）。 当这种行为不可取时，您可以通过将beanDifination标记为【惰性初始化】来防止【单例bean的预实例化】。 延迟初始化的bean告诉IoC容器在【第一次请求】时创建bean实例，而不是在启动时。  \n\n\n\n\n\n\n\n\n\n在XML中，这种行为是由&lt;bean/&gt; 元素上的【lazy-init】属性控制的，如下面的示例所示:  \n&lt;bean id=\"lazy\" class=\"com.something.ExpensiveToCreateBean\" lazy-init=\"true\"/>\n&lt;bean name=\"not.lazy\" class=\"com.something.AnotherBean\"/>\n\n​\t\t然而，当一个【延迟初始化的bean】是一个没有延迟初始化的单例bean的依赖时，ApplicationContext会在启动时创建这个延迟初始化的bean，因为它必须满足单例bean的依赖， 延迟初始化的bean会被注入到没有延迟初始化的其他单例bean中。  \n\n\n\n\n\n\n\n\n\n你也可以在容器级通过在&lt;beans/&gt;元素上使用“default-lazy-init”属性来控制延迟初始化，如下面的例子所示:  \n&lt;beans default-lazy-init=\"true\">\n    &lt;!-- no beans will be pre-instantiated... -->\n&lt;/beans>\n\n\n\n5、自动装配\n\n\n\n\n\n\n\n\nSpring容器可以自动装配【协作bean之间的关系】。 自动装配具有以下优点:  \n\n自动装配可以显著减少指定属性或构造函数参数的需要。\n自动装配可以随着对象的发展更新配置。 例如，如果您需要向类添加依赖项，则无需修改配置即可自动满足该依赖项。\n\n​\t\t当使用基于xml的配置元数据时，您可以使用&lt;bean/&gt;元素的【autowire】属性为beanDifination指定自动装配模式。 自动装配功能有四种模式。 您可以指定每个bean的自动装配，从而可以选择要自动装配哪些bean，自动装配的四种模式如下表所示:  \n\n\n\n运行方式\n解释\n\n\n\nno\n(默认)没有自动装配。 Bean引用必须由【ref】元素定义。 对于较大的部署，不建议更改默认设置，因为【明确指定协作者】可以提供更大的控制和清晰度。 在某种程度上，它记录了系统的结构。\n\n\nbyName\n通过属性名自动装配。 Spring寻找与需要自动连接的属性同名的bean。 例如，如果一个beanDifination被设置为按名称自动装配，并且它包含一个“master”属性（也就是说，它有一个“setMaster(..)”方法），Spring会寻找一个名为“master”的beanDifination并使用它来设置属性。\n\n\nbyType\n如果容器中恰好有一个属性类型的bean，则允许自动连接属性。 如果存在多个，则抛出异常，这表明您不能对该bean使用’ byType ‘自动装配。 如果没有匹配的bean，则不会发生任何事情(没有设置属性)。\n\n\nconstructor\n类似于’ byType ‘，但适用于构造函数参数。 如果容器中没有一个构造函数参数类型的bean，则会引发致命错误。\n\n\n​\t\t通过’ byType ‘或’ constructor ‘自动装配模式，您可以连接【数组和类型化集合】。 在这种情况下，容器中所有【匹配预期类型的自动装配候选对象】都将被提供以满足依赖关系。其中，自动连接的“Map”实例的值包含所有与期望类型匹配的bean实例，而“Map”实例的键包含相应的bean名称。  \n\n\n\n\n\n\n\n\n\n从自动装配中排除Bean\n​\t\t在每个bean的基础上，您可以将一个bean排除在自动装配之外。 在Spring的XML格式中，将&lt;bean/&gt;元素的【autowire-candidate】属性设置为’ false ‘。 \n​\t\t“autowire-candidate”属性被设计成只影响【基于类型】的自动装配。 它不会影响【按名称的显式引用】，即使指定的bean没有被标记为自动连接候选对象，也会解析该引用。 因此，如果名称匹配，按名称自动装配仍然会注入一个bean。\n​\t\t您还可以根据bean名称的模式匹配来限制自动装配候选对象。 顶级元素 &lt;beans/&gt;在其【default-autowire-candidates】属性中接受一个或多个匹配规则。 例如，要将自动装配候选状态限制为名称以’ Repository ‘结尾的任何bean，可以提供’ *Repository ‘值。 要提供多个规则，请在逗号分隔的列表中定义它们。 beanDifination的【autowire-candidate】属性的值“true”或“false”总是优先。 对于这样的bean，模式匹配规则不适用。  \n​\t\t这些技术对于那些【永远不想通过自动装配将其注入到其他bean中的bean】非常有用。 但这并不意味着被排除的bean本身不能通过使用自动装配来配置。\n6、循环依赖\n\n\n\n\n\n\n\n\n\n容器会按照如下方式执行bean依赖关系解析:  \n\n使用描述所有bean的配置元数据创建和初始化【ApplicationContext】。 配置元数据可以由XML、Java代码或注解指定。  \n\n对于每个bean，其依赖关系都以属性、构造函数参数或静态工厂方法参数的形式表示。 这些依赖项是在实际创建bean时提供给bean的。  \n\n每个属性或构造函数参数的值将从其指定的格式转换为该属性或构造函数参数的实际类型。 默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，比如’ int ‘、’ long ‘、’ string ‘、’ boolean ‘等等。\n\n\n​\t\tSpring会在需要的时候实例化一个bean，我们说的简单一点，Spring创建A对象，创建后会注入一个依赖项B，注入时发现依赖的bean不存在，于是就开始创建依赖的B对象，这是一个典型的控制翻转，循环依赖的问题就是实例化B时发现，B竟然依赖A，这是两个对象的互相依赖，组成了一个圆环，循环依赖可能是三个或是更多对象组成。\n​\t\t使用setter注入的循环依赖是可以解决的，通常是采用三级缓存的方式。\n—–循环依赖的问题​\t\t但如果主要使用构造函数注入，可能会创建不可解析的循环依赖场景。  \n七、Bean 作用范围（作用域）​\t\t当您创建一个beanDifination时，其实是在为这个bean的定义创建描述它的元数据。 beanDifination是元数据的想法很重要，因为这意味着，与类一样，您可以从一份元数据中创建许多对象实例。  \n​\t\t您不仅可以控制beanDifination的对象中的各种依赖项和配置值，还可以控制从特定的bean的定义中创建的对象的作用范围。 这种方法功能强大且灵活，因为您可以通过配置，选择创建的对象的作用范围，而不必在Java类级别上确定对象的作用范围。 Spring框架支持六个作用域，其中四个只有在你使用web感知的ApplicationContext时才可用： \n\n\n\n\n\n\n\n\n\n下表描述了支持的范围:  \n\n\n\nscope\n描述\n\n\n\nsingleto\n每个bean在ioc容器中都是独一无二的单例形式。\n\n\nprototype\n将单个beanDifination定义为，spring容器可以【实例化任意数量】的对象实例。\n\n\nrequest\n将单个beanDifination限定为单个HTTP请求的生命周期。 也就是说，每个HTTP请求都有自己的bean实例，它是在单个beanDifination的后面创建的。 仅在web环境中的Spring【ApplicationContext】的上下文中有效。\n\n\nsession\n将单个beanDifination定义为HTTP 【Session】的生命周期。 仅在web环境中的Spring 【ApplicationContext】的上下文中有效。\n\n\napplication\n将单个beanDifination定义为【ServletContext】的生命周期。 仅在web环境中的Spring 【ApplicationContext】的上下文中有效。\n\n\nwebsocket\n将单个beanDifination作用域定义为【WebSocket】的生命周期。 仅在web环境中的Spring【ApplicationContext】的上下文中有效。\n\n\n（1）单例的作用域​\t\t容器只管理【一个bean的共享实例】，所有对具有一个或多个标识符的bean的请求都将导致Spring容器返回一个特定唯一的bean实例。  \n​\t\t换句话说，当您定义一个beanDifination并且它的作用域为单例时，Spring IoC容器会创建由该beanDifination定义的对象的一个实例。 这个实例对象会存储单例bean的缓存中，对该命名bean的所有后续请求和引用都会返回缓存的对象。 下面的图片展示了单例作用域是如何工作的:  \n\n​\t\t【Spring的单例bean概念不同于设计模式书中定义的单例模式】。 单例设计模式对对象的作用域进行硬编码，使得每个ClassLoader只创建一个特定类的实例。 Spring单例的作用域最好描述为每个容器和每个bean，这并不影响我们手动创建更多个实例。 单例作用域是Spring中的默认作用域。 要在XML中将beanDifination为单例，可以定义如下示例所示的bean:  \n&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\"/>\n\n&lt;!-- the following is equivalent， though redundant (singleton scope is the default) -->\n&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n\n\n\n（2）原型作用域​\t\t非单例原型作用域导致【每次对特定bean发出请求时都要创建一个新的bean实例】。 也就是说，该bean被注入到另一个bean中，或者您通过容器上的getBean()方法调用请求它，都会创建一个新的bean。 作为一条规则，您应该对所有有状态bean使用原型作用域，对无状态bean使用单例作用域。  \n\n\n\n\n\n\n\n\n\n下图说明了Spring原型的作用域:  \n\n\n\n\n\n\n\n\n\n\n下面的示例用XML将beanDifination为原型:  \n&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n\n​\t\t与其他作用域相比，Spring并【不管理原型bean的完整生命周期】。 容器实例化、配置和组装一个原型对象，并将其传递给客户端，而不需要进一步记录该原型实例，不会缓存，不会管理他的后续生命周期。 因此，尽管初始化生命周期回调方法在所有对象上都被调用但在原型的情况下，配置的销毁生命周期回调不会被调用（这个小知识下个小节讲）。\n​\t\t在某些方面，Spring容器在原型作用域bean中的角色是Java【new】操作符的替代。 超过这一点的所有生命周期管理都必须由客户端处理。\n（3）会话、应用和WebSocket作用域​\t\t【request 】，【session 】， 【application】和【websocket 】作用域只有在你使用web项目中的Spring【ApplicationContext】实现（如XmlWebApplicationContext）时才可用。 如果您将这些作用域与常规Spring IoC容器一起使用，例如“ClassPathXmlApplicationContext”，则会抛出一个“IllegalStateException”，该异常会告知一个未知的bean作用域。  \n（4）自定义范围​\t\tbean作用域机制是可扩展的，您可以定义自己的作用域，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法，而且您不能覆盖内置的’ singleton ‘和’ prototype ‘作用域。  \n八、更多bean的特性Spring框架提供了许多接口，您可以使用这些接口自定义bean的性质。将它们归类如下:  \n\n生命周期回调\nApplicationContextAware和BeanNameAware\n其他rAware 接口\n\n1、生命周期回调\n\n\n\n\n\n\n\n\n初始化回调\n​\t\torg.springframework.beans.factory.InitializingBean.InitializingBean的接口允许bean在容器设置了bean上的所有必要属性之后执行【初始化工作】。【InitializingBean】接口指定了一个方法:  \nvoid afterPropertiesSet() throws Exception;\n\n​\t\t我们建议您不要使用【InitializingBean】接口，因为这将你的代码与Spring的代码耦合在一起。 我们更推荐使用【@PostConstruct】注解或指定POJO初始化方法。 \n​\t\t在基于xml的配置元数据的情况下，您可以使用【init-method】属性指定具有void无参数签名的方法的名称。 在Java配置中，您可以使用【@Bean】的【initMethod】属性。可以看看下面的例子:  \n&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n\npublic class ExampleBean &#123;\n\n    public void init() &#123;\n        // do some initialization work\n    &#125;\n&#125;\n\n前面的示例几乎与下面的示例（包含两个例子）具有完全相同的效果:  \n&lt;bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>\n\npublic class AnotherExampleBean implements InitializingBean &#123;\n\n    @Override\n    public void afterPropertiesSet() &#123;\n        // do some initialization work\n    &#125;\n&#125;\n\n然而，前面两个示例中的第一个并没有将代码与Spring耦合起来。  \n2、销毁回调实现org.springframework.beans.factory.DisposableBean接口可以让bean在管理它的容器被销毁时获得回调。 ‘ DisposableBean ‘接口指定了一个方法:  \nvoid destroy() throws Exception;\n\n​\t\t同样，我们并不建议您使用【DisposableBean】回调接口，因为我们没有必要将自己的代码与Spring耦合在一起。 另外，我们建议使用【@PreDestroy】注解或指定beanDifination支持的销毁方法。 对于基于xml的配置元数据，您可以在&lt;bean/&gt;上使用’ destroy-method ‘属性。 在Java配置中，您可以使用“@Bean”的【destroyMethod】属性。如下所示:  \n&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n\npublic class ExampleBean &#123;\n\n    public void cleanup() &#123;\n        // do some destruction work (like releasing pooled connections)\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n前面的定义与下面的定义几乎完全相同:  \n&lt;bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>\n\npublic class AnotherExampleBean implements DisposableBean &#123;\n\n    @Override\n    public void destroy() &#123;\n        // do some destruction work (like releasing pooled connections)\n    &#125;\n&#125;\n\n\n\n3、默认初始化和销毁方法​\t\t当我们不使用spring特有的InitializingBean和disapablebean回调接口进行初始化和销毁时，我们通常会编写名为【init()】、 【initialize()】、 【dispose()】等的方法。 理想情况下，这种生命周期回调方法的名称在项目中应该是标准化的（项目经理规定了都必须这么写），以便所有开发人员使用相同的方法名称，并确保一致性。  \n​\t\t您可以配置统一的bean的初始化和销毁方法。 这意味着，作为应用程序开发人员，您可以仅仅声明一个名为【init()】的初始化方法即可，而不必为每个beanDifination配置一个【init-method&#x3D;“init】属性。\n​\t\t假设你的初始化回调方法名为“init()”，你的destroy回调方法名为“destroy()”。 你的类就像下面这个例子中的类:  \npublic class DefaultBlogService implements BlogService &#123;\n\n    private BlogDao blogDao;\n\n    public void setBlogDao(BlogDao blogDao) &#123;\n        this.blogDao = blogDao;\n    &#125;\n\n    // this is (unsurprisingly) the initialization callback method\n    public void init() &#123;\n        if (this.blogDao == null) &#123;\n            throw new IllegalStateException(\"The [blogDao] property must be set.\");\n        &#125;\n    &#125;\n&#125;\n\n然后，您可以在bean中使用该类，类似如下:  \n&lt;beans default-init-method=\"init\">\n\n    &lt;bean id=\"blogService\" class=\"com.something.DefaultBlogService\">\n        &lt;property name=\"blogDao\" ref=\"blogDao\" />\n    &lt;/bean>\n\n&lt;/beans>\n\n​\t\t顶层&lt;beans/&gt;元素属性上的【default-init-method】属性导致Spring IoC容器将bean类上的一个名为【init】的方法识别为初始化方法回调。 在创建和组装bean时，如果bean类有这样的方法，就会在适当的时候调用它。   \n​\t\t如果现有的bean类已经有按约定命名的回调方法，那么您可以通过使用&lt;bean/&gt;本身的【init-method】和【destroy-method】属性指定对应方法来覆盖默认值。\n4、总结\n\n\n\n\n\n\n\n\n从Spring 2.5开始，你有三个选项来控制bean的生命周期行为:  \n\nInitializingBean和 DisposableBean 和 DisposableBean回调接口\n自定义 init()和 destroy() 方法\n@PostConstruct 和 @PreDestroy 您可以组合这些机制来控制给定的bean。\n\n\n\n\n\n\n\n\n\n\n为同一个bean配置的多个生命周期机制(具有不同的初始化方法)，调用顺序如下：\n\n用“@PostConstruct”注解的方法\nafterPropertiesSet() 由 InitializingBean 回调接口\n自定义配置的init()方法\n\n\n\n\n\n\n\n\n\n\nDestroy方法的调用顺序相同:\n\n用 @PreDestroy注解的方法\ndestroy()由 DisposableBean 回调接口定义\n自定义配置的 destroy() 方法\n\n5、ApplicationContextAware 和 BeanNameAware\n\n\n\n\n\n\n\n\n下面显示了“ApplicationContextAware”接口的定义:  \npublic interface ApplicationContextAware &#123;\n\n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n&#125;\n\n​\t\t因此，bean可以通过【ApplicationContextAware】接口，以编程方式【操作】创建它们的【ApplicationContext】。 其中一个用途是对其他bean进行编程检索， 有时这种能力是有用的。 但是，一般来说，您应该【避免使用它】，因为它将代码与Spring耦合在一起，而不遵循控制反转(Inversion of Control)风格，在这种风格中，协作者作为属性提供给bean。 ApplicationContext的其他方法提供了对文件资源的访问、发布应用程序事件和访问MessageSource。  \n​\t\t当ApplicationContext创建一个实现了BeanNameAware接口的类时。 他提供了对其关联对象定义中定义的名称的引用。 下面的例子显示了BeanNameAware接口的定义:  \npublic interface BeanNameAware &#123;\n\n    void setBeanName(String name) throws BeansException;\n&#125;\n\n​\t\t回调在填充普通bean属性之后，但在初始化回调(如“InitializingBean.afterPropertiesSet()”或自定义初始化方法之前调用。  \n​\t\t总结：实现了aware相关的接口，ioc容器不在遵循ioc风格，意思就是不在遵循按需初始化并注入依赖，而是在统一的地方统一注入，这个在源码中有所体现，后边的内容会涉及。\n6、Other Aware Interfaces​\t\t除了“ApplicationContextAware”和“BeanNameAware”，spring提供了一个广泛的“aware”回调接口，让bean指示容器，他们需要一定【基础设施】的依赖。 作为一般规则，名称指示了所需依赖项的类型。 下表总结了一些最重要的“Aware”接口:  \n\n\n\n命名\n依赖注入\n\n\n\nApplicationContextAware\n将ApplicationContext注入bean当中\n\n\nApplicationEventPublisherAware\n将ApplicationEventPublisherAware注入bean当中\n\n\nBeanClassLoaderAware\n将类加载器用于装入bean类\n\n\nBeanFactoryAware\n将BeanFactory注入bean当中\n\n\nBeanNameAware\n将bean的名称注入bean中\n\n\nResourceLoaderAware\n配置了用于访问资源的加载器\n\n\nServletConfigAware\n当前的’ ServletConfig ‘容器运行。 仅在web感知的Spring ‘ ApplicationContext ‘中有效。\n\n\nServletContextAware\n当前运行容器的“ServletContext”。 仅在web感知的Spring ‘ ApplicationContext ‘中有效。\n\n\n​\t\t再次注意，使用这些接口将您的代码与Spring API绑定在一起，而不是遵循控制反转风格。 因此，我们将它们推荐给需要对容器进行编程访问的基础架构bean。  \n7、Bean的继承​\t\tbean的定义可以包含大量配置信息，包括构造函数参数、属性值和特定于容器的信息，比如初始化方法、静态工厂方法名，等等。 子beanDifination可以从父beanDifination继承配置数据。 子beanDifination可以根据需要覆盖一些值或添加其他值。 使用父beanDifination和子beanDifination可以节省大量输入。 实际上，这是模板的一种形式。 \n​\t\t当您使用基于xml的配置元数据时，您可以通过使用“parent”属性来指示子beanDifination，下面的例子展示了如何做到这一点:  \n&lt;bean id=\"inheritedTestBean\" abstract=\"true\"\n        class=\"org.springframework.beans.TestBean\">\n    &lt;property name=\"name\" value=\"parent\"/>\n    &lt;property name=\"age\" value=\"1\"/>\n&lt;/bean>\n\n&lt;bean id=\"inheritsWithDifferentClass\"\n        class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\">  \n    &lt;property name=\"name\" value=\"override\"/>\n    &lt;!-- the age property value of 1 will be inherited from parent -->\n&lt;/bean>\n\n​\t\t如果没有指定，子beanDifination将使用来自父beanDifination的bean类，但也可以覆盖它。 在后一种情况下，子bean类必须与父bean兼容(也就是说，它必须接受父bean的属性值)。  \n​\t\t子beanDifination从父bean继承范围、构造函数参数值、属性值和方法覆盖，并可选择添加新值。 您指定的任何scope、初始化方法、销毁方法或“静态”工厂方法设置都会覆盖相应的父方法设置。  \n​\t\t其余的设置总是取自子定义:依赖、自动装配模式、依赖项检查、单例和延迟初始化。  \n​\t\t前面的示例通过使用【 abstract 】属性显式地将父beanDifination标记为抽象。 如果父beanDifination没有指定类，则需要显式地将父beanDifination标记为【抽象】，如下例所示:  \n&lt;bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n    &lt;property name=\"name\" value=\"parent\"/>\n    &lt;property name=\"age\" value=\"1\"/>\n&lt;/bean>\n\n&lt;bean id=\"inheritsWithClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBeanWithoutClass\" init-method=\"initialize\">\n    &lt;property name=\"name\" value=\"override\"/>\n    &lt;!-- age will inherit the value of 1 from the parent bean definition-->\n&lt;/bean>\n\n​\t\t父bean不能单独实例化，因为它是不完整的，而且它也显式地被标记为“抽象”。 当定义是【抽象的】时，它只能作为作为一个父beanDifination的【纯模板beanDifination使用】。 试图单独使用这样一个【抽象】的父bean，通过将其作为另一个bean的ref属性引用，或使用父bean ID执行显式的“getBean()”调用，将返回错误。 类似地，容器内部的’ preinstantiatesingleton() ‘方法会忽略定义为抽象的beanDifination。  \n九、基于注解的容器配置\n\n\n\n\n\n\n\n\n在配置Spring时，注解比XML更好吗?  \n​\t\t引入基于注解的配置提出了这样一个问题：这种方法是否比XML“更好”， 简短的回答是“视情况而定”。 长期的答案是，每种方法都有其优点和缺点。通常，由开发人员决定哪种策略更适合他们。 由于注解在其声明中提供了【大量上下文】，从而导致配置更简短、更简洁。 然而，XML擅长【连接组件】，而无需修改它们的源代码或重新编译它们。 一些开发人员更喜欢接近源代码进行连接，而另一些开发人员则认为带注解的类不再是pojo，而且配置变得分散且更难控制。  \n\n\n\n\n\n\n\n\n\n使用注解配置，我们需要开启以下的配置：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;context:annotation-config/>\n\n&lt;/beans>\n\n\n\n1、使用 @Autowired\n\n\n\n\n\n\n\n\n作用就是自动装配，有byType的语义。你可以将@Autowired注解应用到构造函数中，如下面的例子所示:  \npublic class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n\n注意：从Spring Framework 4.3开始，如果目标bean只定义了一个构造函数，就不再需要在这样的构造函数上添加【 @Autowired 】注解。 然而，如果有几个构造函数可用，并且没有主&#x2F;默认构造函数，那么至少其中一个构造函数必须用【@Autowired 】注解，以便告诉容器使用哪个构造函数。 \n\n\n\n\n\n\n\n\n\n你也可以将@Autowired注解应用到传统的 setter方法，如下面的例子所示:  \npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n你还可以将注解应用到具有任意名称和多个参数的方法，如下面的示例所示:  \npublic class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(MovieCatalog movieCatalog，\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n用的最多的但spring官方并不推荐的方法是，你也可以将 @Autowired 应用到字段上，甚至可以将它与构造函数混合使用，如下面的示例所示:  \npublic class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n你也可以通过在一个字段或方法中添加【@Autowired】注解来指示Spring从【ApplicationContext】中提供所有特定类型的bean，该字段或方法需要该类型的数组，如下面的例子所示:  \npublic class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n这同样适用于类型化的集合，如下例所示:  \npublic class MovieRecommender &#123;\n\n    private Set&lt;MovieCatalog> movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Set&lt;MovieCatalog> movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n即使是类型化的“Map”实例，只要期望的键类型是“String”，也可以自动连接。 映射值包含预期类型的所有bean，键包含相应的bean名，如下例所示:  \npublic class MovieRecommender &#123;\n\n    private Map&lt;String， MovieCatalog> movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Map&lt;String， MovieCatalog> movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n注意：默认情况下，当给定注入点没有可用的匹配候选bean时，自动装配将失败。 对于声明的数组、集合或映射，至少需要一个匹配元素。  \n​\t\t\n\n\n\n\n\n\n\n\n\n默认行为是将带注解的方法和字段视为指示所需的依赖关系。 你可以像下面的例子一样改变这种行为，通过将一个不满足的注入点标记为非必需的(例如，通过将【 @Autowired】中的’ required ‘属性设置为’ false ‘)来让框架跳过它:  \npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired(required = false)\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n2、使用 @Primary微调基于注解的自动装配​\t\t由于按类型自动装配可能会导致多个【候选者】，因此通常需要对选择过程进行更多的控制。 实现这一点的一种方法是使用Spring的【@Primary 】注解。 【@Primary】表示当多个bean可以作为一个依赖项的候选bean时，应该优先考虑某个特定bean。 如果在候选bean中恰好存在一个主要的bean，那么它将成为自动连接的值。  \n\n\n\n\n\n\n\n\n\n考虑以下配置，将’ firstMovieCatalog ‘定义为主要的’ MovieCatalog ‘:  \n以下内容【@Bean】是下个章节的:\n@Configuration\npublic class MovieConfiguration &#123;\n\n    @Bean\n    @Primary\n    public MovieCatalog firstMovieCatalog() &#123; ... &#125;\n\n    @Bean\n    public MovieCatalog secondMovieCatalog() &#123; ... &#125;\n\n    // ...\n&#125;\n\n通过上述配置，下面的“MovieRecommender”将自动与“firstMovieCatalog”连接:  \npublic class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n当然在xml中我们可以如下配置、相应的beanDifination如下，效果是等价的:\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;context:annotation-config/>\n\n    &lt;bean class=\"example.SimpleMovieCatalog\" primary=\"true\">\n        &lt;!-- inject any dependencies required by this bean -->\n    &lt;/bean>\n\n    &lt;bean class=\"example.SimpleMovieCatalog\">\n        &lt;!-- inject any dependencies required by this bean -->\n    &lt;/bean>\n\n    &lt;bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n\n&lt;/beans>\n\n\n\n3、使用@Qualifier微调基于注解的自动装配​\t\t当可以确定一个主要候选时，【@Primary】注解可以轻松完成这个工作。 当您需要对选择过程进行更多控制时，可以使用Spring的【@Qualifier】注解。 您可以将【限定符值】与特定的参数关联起来，从而缩小类型匹配的集合，以便为每个参数选择特定的bean。 在最简单的情况下，这可以是一个简单的描述性值，如下例所示:  \npublic class MovieRecommender &#123;\n\n    @Autowired\n    @Qualifier(\"main\")\n    private MovieCatalog movieCatalog;\n\n    // ...\n&#125;\n\n您还可以在单个构造函数参数或方法参数上指定’ @Qualifier ‘注解，如下面的示例所示:  \npublic class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog，\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n\n\n\n\n\n\n\n下面的示例显示了相应的beanDifination：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;context:annotation-config/>\n\n    &lt;bean class=\"example.SimpleMovieCatalog\">\n        &lt;qualifier value=\"main\"/> \n\n        &lt;!-- inject any dependencies required by this bean -->\n    &lt;/bean>\n\n    &lt;bean class=\"example.SimpleMovieCatalog\">\n        &lt;qualifier value=\"action\"/> \n\n        &lt;!-- inject any dependencies required by this bean -->\n    &lt;/bean>\n\n    &lt;bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n\n&lt;/beans>\n\n注意：除了使用qualifier标签决定，其实 @Qualifier可以使用id，name等属性定义的任何标识符。\n​\t\t其实，如果您打算按【名称标识符】完成的注入，那么就可以不使用【@Autowired 】，即使它能够在类型匹配的候选对象中按bean名称进行选择（需要配合@Qualifier同时使用）。 有一个更好的选择是使用JSR-250的 【@Resource】注解，该注解在语义上定义为通过惟一的【名称标识】选择特定的目标组件，声明的类型与匹配过程无关。\n4、使用 @Resource​\t\tSpring还通过在字段或bean属性设置方法上使用JSR-250的 【@Resource】注解(‘ javax.annotation.Resource ‘)来支持注入。 这是Java EE中的常见模式， Spring也支持这种模式用于Spring管理的对象。  \n@Resource 带有一个name属性。 默认情况下，Spring将该值解释为要注入的bean名。 换句话说，它遵循by-name语义，如下面的示例所示:  \npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Resource(name=\"myMovieFinder\") \n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n&#125;\n\n​\t\t如果没有显式指定名称，则默认名称为【字段名或setter方法的参数名】。 对于字段，它接受字段名。 对于setter方法，它采用bean属性名。 下面的例子将把名为【movieFinder】的bean注入到它的setter方法中:  \npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Resource\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n&#125;\n\n​\t\t因此，在下面的示例中，’ customerPreferenceDao ‘字段首先查找名为”customerPreferenceDao”的bean，然后按照类型’ customerPreferenceDao ‘的主类型匹配:  \npublic class MovieRecommender &#123;\n\n    @Resource\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Resource\n    private ApplicationContext context; \n\n    public MovieRecommender() &#123;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n——十、容器的启动过程核心方法：refresh()\n@Override\npublic void refresh() throws BeansException， IllegalStateException &#123;\n    synchronized (this.startupShutdownMonitor) &#123;\n        // 准备刷新，准备开店，检查环境，是不是适合开店，比如我选用哪个日志\n        prepareRefresh();\n\n        // 把门面租下来，获得一个bean工厂，loadBeanDefinitions(beanFactory)获取蛋糕的制作流程\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n        // 忽略对应的自动装配\n            //beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\n        try &#123;\n            // Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            // bean工厂已经基本好了，后置处理器\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // Register bean processors that intercept bean creation.\n            registerBeanPostProcessors(beanFactory);\n\n            // Initialize message source for this context.\n            initMessageSource();\n\n            // Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n\n            // Initialize other special beans in specific context subclasses.\n            onRefresh();\n\n            // Check for listener beans and register them.\n            registerListeners();\n\n            // 初始化bean\n            finishBeanFactoryInitialization(beanFactory);\n\n            // Last step: publish corresponding event.\n            finishRefresh();\n        &#125;\n\n        catch (BeansException ex) &#123;\n            if (logger.isWarnEnabled()) &#123;\n                logger.warn(\"Exception encountered during context initialization - \" +\n                            \"cancelling refresh attempt: \" + ex);\n            &#125;\n\n            // Destroy already created singletons to avoid dangling resources.\n            destroyBeans();\n\n            // Reset 'active' flag.\n            cancelRefresh(ex);\n\n            // Propagate exception to caller.\n            throw ex;\n        &#125;\n\n        finally &#123;\n            // Reset common introspection caches in Spring's core， since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n// 已经完成了创建和属性填充给你的工作\nprotected Object initializeBean(String beanName， Object bean， @Nullable RootBeanDefinition mbd) &#123;\n\t\tif (System.getSecurityManager() != null) &#123;\n\t\t\tAccessController.doPrivileged((PrivilegedAction&lt;Object>) () -> &#123;\n\t\t\t\tinvokeAwareMethods(beanName， bean);\n\t\t\t\treturn null;\n\t\t\t&#125;， getAccessControlContext());\n\t\t&#125;\n\t\telse &#123;\n\t\t// 1、调用实现的aware接口\n           invokeAwareMethods(beanName， bean);\n\t\t&#125;\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) &#123;\n            // 调用beanpostproccessor的BeforeInitialization方法\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean， beanName);\n\t\t&#125;\n\n\t\ttry &#123;\n            // 调用初始化方法在这里\n\t\t\tinvokeInitMethods(beanName， wrappedBean， mbd);\n\t\t&#125;\n\t\tcatch (Throwable ex) &#123;\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null)，\n\t\t\t\t\tbeanName， \"Invocation of init method failed\"， ex);\n\t\t&#125;\n\t\tif (mbd == null || !mbd.isSynthetic()) &#123;\n            // 调用beanpostproccessor的AfterInitialization\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean， beanName);\n\t\t&#125;\n\n\t\treturn wrappedBean;\n\t&#125;\n\n\n\n1、初始化Spring容器\n这个阶段相当于考察一下地理环境怎么样\nprepareRefresh()：做一些准备阶段做的是：标记容器为active状态，以及检查当前的运行环境，比如使用log4j，还是jdklog等。\n2、获得一个新的容器\n这个阶段相当于租一个门面，同时准备好产品的制作流程\nConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();\n如果有旧的容器，那么清空容器和容器中注册了的bean，创建新的容器DefaultListableBeanFactory。\nprotected final void refreshBeanFactory() throws BeansException &#123;\n\t\tif (hasBeanFactory()) &#123;\n\t\t\tdestroyBeans();\n\t\t\tcloseBeanFactory();\n\t\t&#125;\n\t\ttry &#123;\n\t\t\tDefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();\n\t\t\tbeanFactory.setSerializationId(getId());\n\t\t\tcustomizeBeanFactory(beanFactory);\n\t\t\tloadBeanDefinitions(beanFactory);\n\t\t\tthis.beanFactory &#x3D; beanFactory;\n\t\t&#125;\n\t\tcatch (IOException ex) &#123;\n\t\t\tthrow new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName()， ex);\n\t\t&#125;\n\t&#125;\n\n\n\n3、bean工厂的准备阶段\n相当于做一些基础装修，比如设备的采购\nprepareBeanFactory(beanFactory);\n设置一些处理器\ntandardBeanExpressionResolver\nResourceEditorRegistrar\n\n\n\n4、调用所有的BeanFactory后置处理器\n这是留给我们进行扩展的，同事spring在也有很多的扩展实现。\n 执行\n&#x2F;&#x2F; Invoke factory processors registered as beans in the context.\ninvokeBeanFactoryPostProcessors(beanFactory);\n\n\n\n5、注册BeanPostProcessors\n6、完成bean的创建\nbeanFactory.preInstantiateSingletons();\n\n在创建bean的过程中，会执行如下流程：\n（1）创建bean\n（3）执行BeanPostProcessors\npostProcessBeforeInitialization\n\n（4）执行配置的初始化方法\n（5）执行BeanPostProcessors\npostProcessAfterInitialization\n\nprotected Object initializeBean(String beanName， Object bean， @Nullable RootBeanDefinition mbd) &#123;\n   if (System.getSecurityManager() !&#x3D; null) &#123;\n      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;\n         invokeAwareMethods(beanName， bean);\n         return null;\n      &#125;， getAccessControlContext());\n   &#125;\n   else &#123;\n      invokeAwareMethods(beanName， bean);\n   &#125;\n\n   Object wrappedBean &#x3D; bean;\n   if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;\n      wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean， beanName);\n   &#125;\n\n   try &#123;\n      invokeInitMethods(beanName， wrappedBean， mbd);\n   &#125;\n   catch (Throwable ex) &#123;\n      throw new BeanCreationException(\n            (mbd !&#x3D; null ? mbd.getResourceDescription() : null)，\n            beanName， &quot;Invocation of init method failed&quot;， ex);\n   &#125;\n   if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;\n      wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean， beanName);\n   &#125;\n   return wrappedBean;\n&#125;\n\n\n\n\n\n一些重要的BeanFactory后置处理器\n\nBeanFactoryPostProcessor：BeanFactory后置处理器\nConfigurationClassPostProcessor：解析配置类的BeanFactory后置处理器\n\n一些重要的BeanFactory\n\nInstantiationAwareBeanPostProcessor：Bean实例化前后运行的后置处理器，还负责设置属性值populateBean()\nAutowiredAnnotationBeanPostProcessor：对注解@Autowired的实现\nCommonAnnotationBeanPostProcessor：对注解 @Resource的实现\nInitDestroyAnnotationBeanPostProcessor：主要是实现了Bean的@PostConstruct和@PreDestroy方法。\nAnnotationAwareAspectJAutoProxyCreator：AOP代理的后置处理器，AOP生成代理的地方就是在后置处理器postProcessAfterInitialization方法中实现的。\nInfrastructureAdvisorAutoProxyCreator：自动代理创建器，仅考虑基础结构Advisor Bean，而忽略任何应用程序定义的Advisor。Spring 的事务使用的是这个后置处理器。\n\n十一、classpath扫描和组件管理​\t\t本章中的大多数例子都使用【XML来指定配置元数据】，这些元数据在Spring容器启动时被扫描，每一个bean的元数据对应生成一个“BeanDefinition”。\n​\t\t本节我们可以通过【扫描类路径】隐式检测候选组件。 【候选组件】指的是通过扫描筛选并在容器中注册了相应beanDifination的类。 这样就不需要使用XML来执行bean注册。 相反，您可以使用注解（例如，【@Component 】）。 \n​\t\t更多操作从Spring 3.0开始，Spring JavaConfig项目提供的许多特性都是核心Spring框架的一部分。 这允许您使用Java而不是使用传统的XML文件来定义bean。\n1、@Component 和及其派生出的其他注解注解\n@Component 是任何spring管理组件的通用注解。\n\n@Repository、&#96;&#96;@Service和@Controller&#96;是【@Component】用于更具体用例的注解（分别在持久性、服务和表示层中）。这些注解对于我们后期对特定bean进行批量处理时是有帮助的。\n\n\n2、自动检测类和注册beanDifination\n\n\n\n\n\n\n\n\nSpring可以自动检测类的信息，并将相应的【BeanDefinition】实例注册到【ApplicationContext】中。 例如，以下两个类适合这样的自动检测:  \n@Service\npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    public SimpleMovieLister(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n&#125;\n\n@Repository\npublic class JpaMovieFinder implements MovieFinder &#123;\n    // implementation elided for clarity\n&#125;\n\n​\t\t\n​\t\t要自动检测这些类并注册相应的bean，您需要将【@ComponentScan】添加到您的【 @Configuration】类中，其中【basePackages】属性是这两个类的公共父包。说人话就是：指定一个包名，自动扫描会检测这个包及其子包下的所有类信息。\n@Configuration\n@ComponentScan(basePackages = \"org.example\")\npublic class AppConfig  &#123;\n    // ...\n&#125;\n\n为简单起见，前面的示例可能使用了注解的value属性 （即 @ComponentScan(&quot;org.example&quot;)）。\n\n\n\n\n\n\n\n\n\n当然我们可以使用以下XML代替，他们是等效的：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;context:component-scan base-package=\"org.example\"/>\n&lt;/beans>\n\n注：&lt;context:component-scan&gt; 的使用会隐式启用  &lt;context:annotation-config&gt;，当使用 &lt;context:component-scan&gt;时，通常不需要包含&lt;context:annotation-config&gt;元素。\n3、组件命名\n\n\n\n\n\n\n\n\n当组件作为扫描过程的一部分被自动检测时，它的bean名是由该扫描器所知道的“BeanNameGenerator”策略生成的。\n 默认情况下，会使用【@Component】， 【@Repository】，【@Service】和【@Controller】注解的value值，因此将该名称会提供给相应的beanDefination。  如果你的注解不包含任何名称属性，会有默认bean名称生成器将返回【非首字母大写的非全限定类名】。 例如，如果检测到以下组件类，则名称为【myMovieLister】和【movieFinderImp】，这个和xml自动生成的标识符名称不同:  \n@Service(\"myMovieLister\")\npublic class SimpleMovieLister &#123;\n    // ...\n&#125;\n\n@Repository\npublic class MovieFinderImpl implements MovieFinder &#123;\n    // ...\n&#125;\n\n\n\n4、为自动检测组件提供scope\n\n\n\n\n\n\n\n\n与spring管理的组件一样，自动检测组件的默认和最常见的作用域是“单例”。 然而，有时您需要一个不同的范围，可以由’ @Scope ‘注解指定。 您可以在注解中提供作用域的名称，如下面的示例所示:  \n@Scope(\"prototype\")\n@Repository\npublic class MovieFinderImpl implements MovieFinder &#123;\n    // ...\n&#125;\n\n\n\n5、使用过滤器自定义扫描​\t\t默认情况下，带有【@Component】、【@Repository】、【@Service】、【@Controller】、【@Configuration】注解的类是一定能被筛选器选中并进行注册的候选组件。  但是，您可以通过应用自定义过滤器来修改和扩展此行为，自由定制筛选哪些或不包含那些组件。 将它们作为@ComponentScan注解的includeFilters 或 excludeFilters 属性添加（或者作为XML配置中’ &lt;context:include-filter &#x2F;&gt; ‘或’ &lt;context:exclude-filter &#x2F;&gt; ‘元素的子元素）。 每个筛选器元素都需要’ type ‘和’ expression ‘属性。 下表描述了过滤选项:  \n\n\n\n过滤方式\n示例表达式\n描述\n\n\n\nannotation (默认)\norg.example.SomeAnnotation\n要在目标组件的类型级别上“存在”或“元注解存在”的注解。\n\n\nassignable\norg.example.SomeClass\n指定要排除的bean的类\n\n\naspectj\norg.example..*Service+\n要被目标组件匹配的AspectJ类型表达式，后边会学习\n\n\nregex\norg\\.example\\.Default\\.*\n由目标组件的类名匹配的正则表达式\n\n\ncustom\norg.example.MyTypeFilter\n‘ org.springframework.core.type的自定义实现，TypeFilter”接口。\n\n\n\n\n\n\n\n\n\n\n\n下面的示例显示了忽略所有【@Repository】注解，而使用【stub】包下的类进行替换:  \n@Configuration\n@ComponentScan(basePackages = \"org.example\"，\n        includeFilters = @Filter(type = FilterType.REGEX， pattern = \".*Stub.*Repository\")，\n        excludeFilters = @Filter(Repository.class))\npublic class AppConfig &#123;\n    // ...\n&#125;\n\n下面的例子显示了等效的XML:  \n&lt;beans>\n    &lt;context:component-scan base-package=\"org.example\">\n        &lt;context:include-filter type=\"regex\"\n                expression=\".*Stub.*Repository\"/>\n        &lt;context:exclude-filter type=\"annotation\"\n                expression=\"org.springframework.stereotype.Repository\"/>\n    &lt;/context:component-scan>\n&lt;/beans>\n\n【小知识】：您还可以通过在注解上设置useDefaultFilters=false 或通过提供use-default-filters=&quot;false&quot; 作为&lt;component-scan/&gt; 元素的属性来禁用默认过滤器。 这将有效地禁用使用【@Component】、【@Repository 】、【@Service】、【 @Controller】、【@Configuration】注解或元注解的类的自动检测。\n6、在组件中定义Bean元数据\n\n\n\n\n\n\n\n\nSpring组件还可以向容器提供beanDifination元数据。 可以使用 @Bean 注解来实现这一点。 \n@Component\npublic class FactoryMethodComponent &#123;\n\n    @Bean\n    @Qualifier(\"public\")\n    public TestBean publicInstance() &#123;\n        return new TestBean(\"publicInstance\");\n    &#125;\n\n    public void doWork() &#123;\n        // Component method implementation omitted\n    &#125;\n&#125;\n\n​\t\t前面的类是一个Spring组件，它的【doWork()】方法中包含特定于应用程序的代码。  然而，它还提供了一个beanDifination，该beanDifination有一个引用方法【public Instance()】的工厂方法。  【@Bean注解】标识工厂方法，通过【@Qualifier】注解标识一个限定符值。 其他可以指定的方法级注解有【@Scope 】， 【@Lazy 】等。  \n\n\n\n\n\n\n\n\n\n下面的例子展示了如何做到这一点: \n@Component\npublic class FactoryMethodComponent &#123;\n\n    private static int i;\n\n    @Bean\n    @Qualifier(\"public\")\n    public TestBean publicInstance() &#123;\n        return new TestBean(\"publicInstance\");\n    &#125;\n\n    // use of a custom qualifier and autowiring of method parameters\n    @Bean\n    protected TestBean protectedInstance(\n            @Qualifier(\"public\") TestBean spouse，\n            @Value(\"#&#123;privateInstance.age&#125;\") String country) &#123;\n        TestBean tb = new TestBean(\"protectedInstance\"， 1);\n        tb.setSpouse(spouse);\n        tb.setCountry(country);\n        return tb;\n    &#125;\n\n    @Bean\n    private TestBean privateInstance() &#123;\n        return new TestBean(\"privateInstance\"， i++);\n    &#125;\n\n&#125;\n\n​\t\n7、基于Java的容器配置（1） @Bean和@Configuration​\t\tSpring新的java配置支持的中心组件是带注解的【@Configuration】类和带注解的【@Bean】方法。  \n​\t\t@Bean注解用于指示一个方法，该方法负责【实例化、配置和初始化】一个由Spring IoC容器管理的新对象。 对于那些熟悉Spring &lt;beans/&gt;XML配置的人来说，@Bean注解扮演着与&lt;bean/&gt; 元素相同的角色。 你可以在任何Spring  @Component中使用@Bean注解方法。 但是，它们最常与@Configuration一起使用。  \n​\t\t用@Configuration注解的一个类表明它的主要目的是作为beanDifination的源，我们通常称之为【配置类】。 此外，【@Configuration】类允许通过调用同一类中的其他【@Bean 】方法来【定义bean间的依赖关系】。 最简单的【@Configuration】类如下所示：\n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public MyService myService() &#123;\n        return new MyServiceImpl();\n    &#125;\n&#125;\n\n前面的’ AppConfig ‘类等价于下面的Spring &lt;beans/&gt;XML:  \n&lt;beans>\n    &lt;bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/>\n&lt;/beans>\n\n​\t\n（2）使用 AnnotationConfigApplicationContext实例化Spring容器​\t\t下面的章节记录了Spring 3.0中引入的【AnnotationConfigApplicationContext】。 这个通用的【ApplicationContext】实现不仅能够接受【@Configuration】类作为输入，还能够接受普通的【@Component】类和用JSR-330元数据注解的类。  \n​\t\t当提供【@Configuration】类作为输入时，【@Configuration】类本身被注册为一个beanDifination，并且类中所有声明的【@Bean】方法也被注册为beanDifination。  \n​\t\t当提供【@Component 】和JSR-330相关的注解类时，它们被注册为beanDifination。  \n\n\n\n\n\n\n\n\n\na、结构简洁\n​\t\t就像Spring XML文件在实例化【ClassPathXmlApplicationContext】时被用作输入一样，当实例化【AnnotationConfigApplicationContext】时，你可以使用【@Configuration】类作为输入。 这允许Spring容器完全不使用xml，如下例所示:  \npublic static void main(String[] args) &#123;\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n    MyService myService = ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;\n\n​\t\t\n​\t\t正如前面提到的，【AnnotationConfigApplicationContext】并不局限于只与【@Configuration】类一起工作。 任何【@Component】或JSR-330注解类都可以作为输入提供给构造函数，如下面的例子所示:  \npublic static void main(String[] args) &#123;\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class， Dependency1.class， Dependency2.class);\n    MyService myService = ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;\n\n前面的例子假设【MyServiceImpl】、【Dependency1】和【Dependency2】使用Spring依赖注入注解，比如【@Autowired】。  \n\n\n\n\n\n\n\n\n\nb、通过使用’ register(Class&lt;?&gt;…)’以编程方式构建容器  \n​\t\t你可以使用一个【没有参数的构造函数】来实例化一个【AnnotationConfigApplicationContext】，然后使用【register()】方法来配置它。 当以编程方式构建一个“AnnotationConfigApplicationContext”时，这种方法特别有用。 下面的例子展示了如何做到这一点:  \npublic static void main(String[] args) &#123;\n    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n    ctx.register(AppConfig.class， OtherConfig.class);\n    ctx.register(AdditionalConfig.class);\n    ctx.refresh();\n    MyService myService = ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nc、使用 scan(String…)启用组件扫描 \n要启用组件扫描，你可以像下面这样注解你的 @Configuration 类：\n@Configuration\n@ComponentScan(basePackages = \"com.acme\") \npublic class AppConfig  &#123;\n    // ...\n&#125;\n\n&lt;beans> \n\t&lt;context:component-scan base-package=\"com.ydlclass\" / > \n&lt;/beans>”\n\n​\t\n同时，AnnotationConfigApplicationContext也暴露了【 scan(String…)】方法来允许相同的组件扫描功能，如下例所示:  \npublic static void main(String[] args) &#123;\n    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n    ctx.scan(\"com.acme\");\n    ctx.refresh();\n    MyService myService = ctx.getBean(MyService.class);\n&#125;\n\n​\t\t请记住，【@Configuration】类是带有【@Component】元注解的一个注解，因此它们是组件扫描的候选对象。 在前面的例子中，假设【AppConfig】在”com.acme”中声明。 在’ refresh() ‘之后，它的所有’ @Bean ‘方法都被处理并注册为容器中的beanDifination。\n（3） @Bean注解【@Bean】是一个方法级注解，与XML&lt;bean/&gt; 元素具有相同的能力。 注解支持&lt;bean/&gt;提供的一些属性，例如:  \n\ninit-method\ndestroy-method\nautowiring\nname\n\n你可以在带有【@Configuration】注解的类或带有【@Component】注解的类中使用【@Bean】注解。  \n\n\n\n\n\n\n\n\n\na、声明一个 Bean\n​\t\t使用【@Bean】对方法进行注解可以帮助我们申明一个bean。 您可以使用此方法在【ApplicationContext】中注册一个beanDifination，该bean的类型会被指定为【方法的返回值类型】，而具体的返回值则是交由spring管理的bean实例。 默认情况下，bean名与方法名相同。 下面的例子显示了一个【 @Bean 】方法声明:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public TransferServiceImpl transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n&#125;\n\n上面的配置与下面的Spring XML完全相同:  \n&lt;beans>\n    &lt;bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/>\n&lt;/beans>\n\n注：你也可以使用接口（或基类）作为返回类型来声明你的@Bean方法，如下面的例子所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public TransferService transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nb、Bean的依赖关系\n​\t\t带注解的【@Bean】方法可以有任意数量的参数，这些参数描述构建该bean所需的依赖关系。 例如，如果我们的【TransferService】需要一个【AccountRepository】，我们可以用一个方法参数来实现这个依赖，如下例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public TransferService transferService(AccountRepository accountRepository) &#123;\n        return new TransferServiceImpl(accountRepository);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nc、接受生命周期回调\n\n任何用【@Bean】注解定义的类都支持常规的生命周期回调，并且可以使用JSR-250的’ @PostConstruct ‘和’ @PreDestroy ‘注解。\n\n也完全支持常规的Spring lifecycle回调。 如果一个bean实现了’ InitializingBean ‘、’ DisposableBean ‘或’ Lifecycle ‘，则容器会调用它们各自的方法。  \n\n标准的【Aware 】接口也完全支持。\n\n\n【@Bean注解】支持指定任意的初始化和销毁回调方法，就像Spring XML在’ bean ‘元素上的’ init-method ‘和’ destroy-method ‘属性一样，如下面的示例所示:  \npublic class BeanOne &#123;\n\n    public void init() &#123;\n        // initialization logic\n    &#125;\n&#125;\n\npublic class BeanTwo &#123;\n\n    public void cleanup() &#123;\n        // destruction logic\n    &#125;\n&#125;\n\n@Configuration\npublic class AppConfig &#123;\n\n    @Bean(initMethod = \"init\")\n    public BeanOne beanOne() &#123;\n        return new BeanOne();\n    &#125;\n\n    @Bean(destroyMethod = \"cleanup\")\n    public BeanTwo beanTwo() &#123;\n        return new BeanTwo();\n    &#125;\n&#125;\n\n小知识：对于上面例子中的’ BeanOne ‘，在构造过程中直接调用’ init() ‘方法同样有效，如下例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public BeanOne beanOne() &#123;\n        BeanOne beanOne = new BeanOne();\n        beanOne.init();\n        return beanOne;\n    &#125;\n\n    // ...\n&#125;\n\n当您直接在代码中进行配置时，您可以对您的对象做任何您想做的事情，而不总是需要依赖于容器生命周期。\n\n\n\n\n\n\n\n\n\nd、指定Bean范围\nSpring包含了【@Scope】注解，以便您可以指定bean的范围。  \n默认的作用域是’ singleton ‘，但是你可以用’ @Scope ‘注解来覆盖它，如下面的例子所示:  \n@Configuration\npublic class MyConfiguration &#123;\n\n    @Bean\n    @Scope(\"prototype\")\n    public Encryptor encryptor() &#123;\n        // ...\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\ne、定制Bean命名\n默认情况下，配置类使用【@Bean】方法的名称作为结果bean的名称。 但是，可以使用’ name ‘属性覆盖该功能，如下例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean(\"myThing\")\n    public Thing thing() &#123;\n        return new Thing();\n    &#125;\n&#125;\n\n有时需要为单个bean提供多个名称，或者称为bean别名。【@Bean】注解的’ name ‘属性为此接受String数组。 下面的例子展示了如何为一个bean设置多个别名:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean(&#123;\"dataSource\"， \"subsystemA-dataSource\"， \"subsystemB-dataSource\"&#125;)\n    public DataSource dataSource() &#123;\n        // instantiate， configure and return DataSource bean...\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nf、Bean 描述\n有时，提供bean的更详细的文本描述是很有帮助的。 当bean被公开（可能通过JMX）用于监视目的时，这可能特别有用。  \n要向【@Bean】添加描述，可以使用【@Description】注解，如下面的示例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    @Description(\"Provides a basic example of a bean\")\n    public Thing thing() &#123;\n        return new Thing();\n    &#125;\n&#125;\n\n\n\n（4）  @Configuration​\t\t【@Configuration】是一个类级注解，指示一个对象是beanDifination的源。【@Configuration】类通过【@Bean】带注解的方法声明bean。 【在“@Configuration”类上调用“@Bean”方法也可以用来定义bean间的依赖关系】。   \n\n\n\n\n\n\n\n\n\n注入bean之间的依赖\n​\t \t当@Bean方法在没有标注@Configuration的类中声明时，它们被认为是在【lite】模式下处理的。 在【@Component】中声明的Bean方法甚至在一个普通的类中声明的Bean方法都被认为是【lite】。在这样的场景中，【@Bean】方法是一种通用工厂方法机制。  \n​\t\t与@Configuration 不同，【lite】模式下 【@Bean】方法不能【声明bean】间的【依赖关系】。  因此，这样的【@Bean】方法不应该调用其他【@Bean】下的方法。 每个这样的方法实际上只是特定bean引用的工厂方法，没有任何特殊的运行时语义。\n​\t\t在一般情况下，@Bean方法要在【@Configuration】类中声明，这种功能情况下，会使用【full】模式，因此交叉方法引用会被重定向到容器的生命周期管理。 这可以防止通过常规Java调用意外调用相同的Bean，这有助于减少在【lite】模式下操作时难以跟踪的微妙错误。  \n​\t\t@Bean 和@Configuration注解将在下面几节中深入讨论。 不过，我们首先介绍通过使用基于java的配置创建spring容器的各种方法。  \n当bean相互依赖时，表示这种依赖就像让一个bean方法调用另一个bean方法一样简单，如下面的示例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public BeanOne beanOne() &#123;\n        // full模式可以直接调用方法，这个调用过程由容器管理，lite模式这就是普通方法调用，多次调用会产生多个实例。\n        return new BeanOne(beanTwo());\n    &#125;\n\n    @Bean\n    public BeanTwo beanTwo() &#123;\n        return new BeanTwo();\n    &#125;\n&#125;\n\n在前面的例子中，【beanOne】通过构造函数注入接收对【beanTwo】的引用。  \n\n\n\n\n\n\n\n\n\n考虑下面的例子，它显示了一个带注解的@Bean方法被调用两次:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean\n    public ClientService clientService1() &#123;\n        ClientServiceImpl clientService = new ClientServiceImpl();\n        clientService.setClientDao(clientDao());\n        return clientService;\n    &#125;\n\n    @Bean\n    public ClientService clientService2() &#123;\n        ClientServiceImpl clientService = new ClientServiceImpl();\n        clientService.setClientDao(clientDao());\n        return clientService;\n    &#125;\n\n    @Bean\n    public ClientDao clientDao() &#123;\n        return new ClientDaoImpl();\n    &#125;\n&#125;\n\n​\t\tclientDao() 在【clientService1()】和【clientService2()】中分别被调用一次。 由于该方法创建了一个新的【ClientDaoImpl】实例并返回它，所以通常期望有两个实例(每个服务一个)。 这肯定会有问题。在Spring中，实例化的bean默认有一个【单例】作用域，在调用父方法并创建新实例之前，首先检查容器中是否有缓存的（有作用域的）bean。\n\n\n\n\n\n\n\n\n\n我们目前学习的描述候选组件的注解很多，但是仔细意思考，其实很简单：\n我们自己的写代码通常使用以下注解来标识一个组件：\n\n@Component      组件的通用注解\n@Repository，持久层\n@Service，业务层\n@Controller，控制层\n\n​\t\t配置类通常是我们不能修改源代码，但是需要注入别人写的类。例如向容器注入一个德鲁伊数据源的bean，我们是绝对不能给这个类加个【@Component 】注解的。\n@Configuration + @Bean\n（5） 使用 @Import 注解\n\n\n\n\n\n\n\n\n就像在Spring XML文件中使用&lt;import/&gt; 元素来实现模块化配置一样，@Import注解允许从另一个配置类加载【@Bean】定义，如下面的示例所示:  \n@Configuration\npublic class ConfigA &#123;\n\n    @Bean\n    public A a() &#123;\n        return new A();\n    &#125;\n&#125;\n\n@Configuration\n@Import(ConfigA.class)\npublic class ConfigB &#123;\n\n    @Bean\n    public B b() &#123;\n        return new B();\n    &#125;\n&#125;\n\n现在，在实例化上下文时不需要同时指定ConfigA.class 和ConfigB.class，只需要显式地提供【ConfigB】，如下面的示例所示:  \npublic static void main(String[] args) &#123;\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);\n\n    // now both beans A and B will be available...\n    A a = ctx.getBean(A.class);\n    B b = ctx.getBean(B.class);\n&#125;\n\n这种方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造过程中记住潜在的大量【@Configuration】类。  \n【小知识】我们一样可以给该注解传入一个实现了ImportSelector接口的类，返回的字符串数组的Bean都会被加载到容器当中：\npublic class ConfigSelector implements ImportSelector &#123;\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;\n        return new String[]&#123;\"com.ydlclass.A\"，\"com.ydlclass.B\"&#125;;\n    &#125;\n&#125;\n\n\n\n（6）结合Java和XML配置\n\n\n\n\n\n\n\n\nSpring的【@Configuration】类支持的目标并不是100%完全替代Spring XML，有些场景xml仍然是配置容器的理想方式。\n我们有如下选择：\n1、容器实例化在一个“以XML为中心”的方式使用，例如，“ClassPathXmlApplicationContext”。\n2、”以java编程的方式为中心”的方式，实例化它通过使用【@ImportResource】注解导入XML。  \n\n\n\n\n\n\n\n\n\n以xml为中心使用“@Configuration”类\n​\t\t最好从XML引导Spring容器，并以一种特别的方式包含【@Configuration 】类。将【@Configuration 】类声明为普通的Spring &lt;bean/&gt; 元素。记住，【@Configuration】类最终是容器中的beanDifination。 \n下面的例子展示了Java中一个普通的配置类:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Bean\n    public AccountRepository accountRepository() &#123;\n        return new JdbcAccountRepository(dataSource);\n    &#125;\n\n    @Bean\n    public TransferService transferService() &#123;\n        return new TransferService(accountRepository());\n    &#125;\n&#125;\n\n下面的例子显示了一个’ system-test-config.xml ‘文件的一部分:  \n&lt;beans>\n    &lt;!-- enable processing of annotations such as @Autowired and @Configuration -->\n    &lt;context:annotation-config/>\n    &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n\n    &lt;bean class=\"com.acme.AppConfig\"/>\n\n    &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n    &lt;/bean>\n&lt;/beans>\n\n下面的示例显示了一个可能的’ jdbc ‘。 属性的文件:  \nuser=root\npassword=root\nurl=jdbc:mysql://127.0.0.1:3306/ydlclass?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\ndriverName=com.mysql.cj.jdbc.Driver\n\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\");\n    TransferService transferService = ctx.getBean(TransferService.class);\n    // ...\n&#125;\n\n​\t\t因为【@Configuration】是用【@Component】注解的，所以被【@Configuration】注解的类会自动被组件扫描。 使用与前面示例中描述的相同的场景，我们可以重新定义system-test-config.xml来利用组件扫描。 \n下面的示例显示了修改后的system-test-config.xml文件:  \n&lt;beans>\n    &lt;!-- picks up and registers AppConfig as a bean definition -->\n    &lt;context:component-scan base-package=\"com.acme\"/>\n    &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n\n    &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n    &lt;/bean>\n&lt;/beans>\n\n\n\n\n\n\n\n\n\n\n\n\n使用@ImportResource以类为中心使用XML  \n​\t\t在【@Configuration】类是配置容器的主要机制的应用程序中，可能仍然需要使用至少一些XML。 在这些场景中，您可以使用【@ImportResource】注解，并只定义所需的XML。 这样做可以实现一种“以java为中心”的方法来配置容器，并将XML最小化。 \n下面的例子说明了这一点：\n@Configuration\n@ImportResource(\"classpath:/com/acme/properties-config.xml\")\npublic class AppConfig &#123;\n\n    @Value(\"$&#123;jdbc.url&#125;\")\n    private String url;\n\n    @Value(\"$&#123;jdbc.username&#125;\")\n    private String username;\n\n    @Value(\"$&#123;jdbc.password&#125;\")\n    private String password;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new DriverManagerDataSource(url， username， password);\n    &#125;\n&#125;\n\n\n\n\nproperties-config.xml\n&lt;beans>\n    &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n&lt;/beans>\n\njdbc.properties：\njdbc.url=jdbc:hsqldb:hsql://localhost/xdb\njdbc.username=sa\njdbc.password=\n\n启动容器：\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n    TransferService transferService = ctx.getBean(TransferService.class);\n    // ...\n&#125;\n\n\n\n8、BeanFactory和FactoryBeanFactoryBean通常用来创建一个复杂对象：\npublic interface FactoryBean&lt;T> &#123;\n\n\tString OBJECT_TYPE_ATTRIBUTE = \"factoryBeanObjectType\";\n\n\t@Nullable\n\tT getObject() throws Exception;\n\n\t@Nullable\n\tClass&lt;?> getObjectType();\n\n\tdefault boolean isSingleton() &#123;\n\t\treturn true;\n\t&#125;\n\n&#125;\n\n\n\n\n\n\n\n9、环境抽象\n【Environment 】接口是一个抽象，集成在容器中，它模拟了应用程序环境的两个关键方面:【profiles】 and 【properties】。  \n\n一个profile是一个【给定名字】的，在【逻辑上分了组】的beanDifination配置，只有在给定的profile是激活的情况下才向容器注册。 \n\nproperties 在几乎所有的应用程序中都扮演着重要的角色，并且可能源自各种来源：属性文件、JVM系统属性、系统环境变量、JNDI、servlet上下文参数、特定的【Properties】对象、“Map”对象，等等。 与属性相关的“Environment”对象的作用是为用户提供一个方便的服务接口，用于配置属性源并从那里解析属性。\n\n\n（1）ProfilesProfiles在核心容器中提供了一种机制，允许在不同环境中注册不同的Bean。 “环境”这个词对不同的用户有不同的含义，\n\n在开发中使用内存中的数据源，还是在生产中从JNDI中查找的数据源。  \n为客户A和客户B部署注册定制的bean实现。\n\n考虑一个实际应用程序中的第一个用例，它需要一个“数据源”。 在测试环境中，配置可能类似如下:  \n@Bean\npublic DataSource dataSource() &#123;\n    return new EmbeddedDatabaseBuilder()\n        .setType(EmbeddedDatabaseType.HSQL)\n        .addScript(\"my-schema.sql\")\n        .addScript(\"my-test-data.sql\")\n        .build();\n&#125;\n\n现在考虑如何将该应用程序部署到生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录中。 我们的’ dataSource ‘ bean现在看起来如下所示:  \n@Bean\npublic DataSource dataSource() throws Exception &#123;\n    Context ctx = new InitialContext();\n    return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n&#125;\n\n\n\n重点：问题是如何根据当前环境在使用这两种数据源之间进行切换？\n当然，我们可以使用 @Profile。\n【@Profile】注解允许您指出，当一个或多个bean在哪一种Profile被激活时被注入。 使用前面的例子，我们可以将dataSource配置重写如下:  \n@Configuration\n@Profile(\"development\")\npublic class StandaloneDataConfig &#123;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n            .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n            .build();\n    &#125;\n&#125;\n\n@Configuration\n@Profile(\"production\")\npublic class JndiDataConfig &#123;\n\n    @Bean(destroyMethod=\"\")\n    public DataSource dataSource() throws Exception &#123;\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n@Profile也可以在方法级别声明，只包含一个配置类的一个特定bean(例如，对于一个特定bean的替代变体)，如下面的示例所示:  \n@Configuration\npublic class AppConfig &#123;\n\n    @Bean(\"dataSource\")\n    @Profile(\"development\") \n    public DataSource standaloneDataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n            .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n            .build();\n    &#125;\n\n    @Bean(\"dataSource\")\n    @Profile(\"production\") \n    public DataSource jndiDataSource() throws Exception &#123;\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n    &#125;\n&#125;\n\n\n\n（2）XML Bean 定义环境\n\n\n\n\n\n\n\n\nXML对应的是&lt;beans&gt; 元素的’ profile ‘属性。 前面的示例配置可以在两个XML文件中重写，如下所示：  \n&lt;beans profile=\"development\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xsi:schemaLocation=\"...\">\n\n    &lt;jdbc:embedded-database id=\"dataSource\">\n        &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n        &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n    &lt;/jdbc:embedded-database>\n&lt;/beans>\n\n&lt;beans profile=\"production\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n&lt;/beans>\n\n也可以避免在同一个文件中分割和嵌套&lt;beans/&gt; 元素，如下例所示:  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    &lt;!-- other bean definitions -->\n\n    &lt;beans profile=\"development\">\n        &lt;jdbc:embedded-database id=\"dataSource\">\n            &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n            &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n        &lt;/jdbc:embedded-database>\n    &lt;/beans>\n\n    &lt;beans profile=\"production\">\n        &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n    &lt;/beans>\n&lt;/beans>\n\n“spring bean。 Xsd ‘被限制为只允许这些元素作为文件中的最后一个元素。 这将有助于在不引起XML文件混乱的情况下提供灵活性。  \n（3）激活一个环境​\t\t现在我们已经更新了配置，我们仍然需要指示Spring哪个配置文件是活动的。 如果我们现在启动我们的样例应用程序，我们会看到抛出一个NoSuchBeanDefinitionException，因为容器无法找到名为dataSource的Spring bean。  \n​\t\t激活配置文件有几种方式，但最直接的方式是通过【ApplicationContext】可用的【Environment】API以编程方式执行。 下面的例子展示了如何做到这一点:  \n@Test\npublic void testProfile()&#123;\n    // 创建容器\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n    // 激活环境\n    context.getEnvironment().setActiveProfiles(\"development\");\n    // 扫包\n    context.scan(\"com.ydlclass.datasource\");\n    //  刷新\n    context.refresh();\n    // 使用\n    DataSource bean = context.getBean(DataSource.class);\n    logger.info(\"&#123;&#125;\"，bean);\n&#125;\n\n​\t\t\n​\t\t此外，你还可以通过spring.profiles来声明性地激活环境【active】属性，它可以通过系统环境变量、JVM系统属性、servlet上下文参数在’ web.xml ‘中指定。 \n​\t\t请注意，配置文件不是一个“非此即彼”的命题。 您可以一次激活多个配置文件。 通过编程方式，您可以向’ setActiveProfiles() ‘方法提供多个配置文件名，该方法接受’ String…’可变参数。 下面的示例激活多个配置文件:  \n加入启动参数：\n-Dspring.profiles.active&#x3D;&quot;profile1，profile2&quot;\n\n编程的方式\nctx.getEnvironment().setActiveProfiles(\"profile1\"， \"profile2\");\n\n\n\n（4）porpertiesSpring的【环境抽象】提供了对【属性】的搜索操作。 考虑以下例子:  \nApplicationContext ctx = new GenericApplicationContext();\nEnvironment env = ctx.getEnvironment();\nboolean containsMyProperty = env.containsProperty(\"my-property\");\nSystem.out.println(\"Does my environment contain the 'my-property' property? \" + containsMyProperty);\n\n​\t\t\n​\t\t在前面的代码片段中，我们看到了查询Spring是否为当前环境定义了【my-property】属性的方法。 为了回答这个问题，“Environment”对象对一组【PropertySource】对象执行搜索。 “PropertySource”是对任何【键值对源】的一个简单抽象， spring的【StandardEnvironment】配置了两个PropertySource对象——一个代表JVM系统属性的集合（“System.getProperties()”）和一个代表系统环境变量的设置（System.getenv()”）。  \n\n​\t\t具体地说，当你使用【StandardEnvironment】时，如果【my-property】系统属性或【my-property】环境变量在运行时存在，对env.containsProperty(&quot;my-property&quot;)的调用将返回true。  \n​\t\t最重要的是，整个机制都是可配置的。 也许您有一个自定义的属性源，希望将其集成到此搜索中。 为此，我们可以实例化自己的【PropertySource】，并将它添加到当前’ Environment ‘的’ propertyssources ‘集合中。 下面的示例显示了如何这样做:  \nConfigurableApplicationContext ctx = new GenericApplicationContext();\nMutablePropertySources sources = ctx.getEnvironment().getPropertySources();\nsources.addFirst(new MyPropertySource());\n\n\n\n\n\n\n\n\n\n\n\n\n使用@PropertySource\n【@PropertySource ]】注解提供了一种方便的声明性机制，用于向Spring的【Environment】中添加【 PropertySource】。  \n给定一个名为app的文件。 下面的【@Configuration】类使用了【@PropertySource】，从而调用“testBean.getName()”返回“myTestBean”:  \n@Configuration\n@PropertySource(\"classpath:/com/myco/app.properties\")\npublic class AppConfig &#123;\n\n    @Autowired\n    Environment env;\n\n    @Bean\n    public TestBean testBean() &#123;\n        TestBean testBean = new TestBean();\n        testBean.setName(env.getProperty(\"testbean.name\"));\n        return testBean;\n    &#125;\n&#125;\n\n\n\n@Value(“${}”)对于引入的properties文件\n10、事件机制为了以更面向框架的风格增强【BeanFactory】功能，ApplicationContext还提供了以下功能:  \n\n通过MessageSource接口访问i18n风格的消息，实现国际化。  \n通过ResourceLoader接口访问资源，例如url和文件。  \n事件发布，即通过使用’ ApplicationEventPublisher ‘接口发布实现’ ApplicationListener ‘接口的bean。  \n通过“HierarchicalBeanFactory”接口，加载多个(分层的)上下文，让每个上下文都集中在一个特定的层上，比如应用程序的web层。\n\n\n\n\n\n\n\n\n\n\n1、自定义事件\n​\t\tApplicationContext中的事件处理是通过【ApplicationEvent】类和【ApplicationListener】接口提供的。 如果将实现“ApplicationListener”接口的bean部署到上下文中，那么每次将【ApplicationEvent】发布到【ApplicationContext】时，都会通知该bean。 本质上，这是标准的Observer设计模式。  \n​\t\t从spring4.2开始，事件基础设施得到了显著的改进，并提供了一个【基于注解的事件模型】以及发布任意事件的能力 。\n​\t\t您可以使用spring创建和发布自己的自定义事件。 下面的例子展示了一个简单的类，它扩展了Spring的【ApplicationEvent】基类:  \npublic class BlockedListEvent extends ApplicationEvent &#123;\n\n    private final String address;\n    private final String content;\n\n    public BlockedListEvent(Object source， String address， String content) &#123;\n        super(source);\n        this.address = address;\n        this.content = content;\n    &#125;\n\n    // accessor and other methods...\n&#125;\n\n​\t\t要发布自定义的【ApplicationEvent】，需要调用【ApplicationEventPublisher】上的【publishEvent()】方法。 通常，这是通过创建一个实现’ ApplicationEventPublisherAware ‘的类并将其注册为Spring bean来实现的。 下面的例子展示了这样一个类:  \npublic class EmailService implements ApplicationEventPublisherAware &#123;\n\n    private List&lt;String> blockedList;\n    private ApplicationEventPublisher publisher;\n\n    public void setBlockedList(List&lt;String> blockedList) &#123;\n        this.blockedList = blockedList;\n    &#125;\n\n    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123;\n        this.publisher = publisher;\n    &#125;\n\n    public void sendEmail(String address， String content) &#123;\n        if (blockedList.contains(address)) &#123;\n            publisher.publishEvent(new BlockedListEvent(this， address， content));\n            return;\n        &#125;\n        // send email...\n    &#125;\n&#125;\n\n​\t\t\n​\t\t在配置时，Spring容器检测到【EmailService】实现了【 ApplicationEventPublisherAware】并自动调用【setApplicationEventPublisher()】。 实际上，传入的参数是Spring容器本身。 你通过它的【ApplicationEventPublisher】接口与应用上下文交互。  \n​\t\t要接收自定义的【 ApplicationEvent】，您可以创建一个类来实现【ApplicationListener】并将其注册为Spring bean。 下面的例子展示了这样一个类:  \npublic class BlockedListNotifier implements ApplicationListener&lt;BlockedListEvent> &#123;\n\n    private String notificationAddress;\n\n    public void setNotificationAddress(String notificationAddress) &#123;\n        this.notificationAddress = notificationAddress;\n    &#125;\n\n    public void onApplicationEvent(BlockedListEvent event) &#123;\n        // notify appropriate parties via notificationAddress...\n    &#125;\n&#125;\n\n 将来容器只要发布这个事件，这个监听者就可以感知。\n\n\n\n\n\n\n\n\n\n基于注解的事件监听器\n您可以使用【@EventListener】注解在托管bean的任何方法上注册一个事件侦听器。 【BlockedListNotifier】可以重写如下:  \npublic class BlockedListNotifier &#123;\n\n    private String notificationAddress;\n\n    public void setNotificationAddress(String notificationAddress) &#123;\n        this.notificationAddress = notificationAddress;\n    &#125;\n\n    @EventListener\n    public void processBlockedListEvent(BlockedListEvent event) &#123;\n        // notify appropriate parties via notificationAddress...\n    &#125;\n&#125;\n\n​\t\t方法签名再次声明它侦听的事件类型，但这一次使用了灵活的名称，而没有实现特定的侦听器接口。 只要实际事件类型在其实现层次结构中解析泛型参数，就可以通过泛型缩小事件类型。  \n​\t\t如果您的方法应该侦听多个事件，或者您想在不带参数的情况下定义它，也可以在注解本身上指定事件类型。 下面的例子展示了如何做到这一点:  \n@EventListener(&#123;ContextStartedEvent.class， ContextRefreshedEvent.class&#125;)\npublic void handleContextStart() &#123;\n    // ...\n&#125;\n\n​\t\n\n\n\n\n\n\n\n\n\n2、Spring提供的标准事件\n\n\n\n事件\n说明\n\n\n\nContextRefreshedEvent\n在“ApplicationContext”被初始化或刷新时发布(例如，通过使用“ConfigurableApplicationContext”接口上的“refresh()”方法)。 这里，“初始化”意味着加载了所有bean，检测并激活了后处理器bean，预实例化了单例，并且“ApplicationContext”对象已经准备好使用了。 只要上下文还没有被关闭，一个刷新可以被触发多次，只要选择的’ ApplicationContext ‘实际上支持这种“热”刷新。 例如，’ XmlWebApplicationContext ‘支持热刷新，但’ GenericApplicationContext ‘不支持。\n\n\nContextStartedEvent\n在’ ConfigurableApplicationContext ‘接口上使用’ start() ‘方法启动’ ApplicationContext ‘时发布。 在这里，“started”意味着所有的“生命周期”bean都接收一个显式的开始信号。 通常，此信号用于在显式停止之后重新启动bean，但它也可用于启动尚未配置为自动启动的组件(例如，在初始化时尚未启动的组件)。\n\n\nContextStoppedEvent\n在’ ConfigurableApplicationContext ‘接口上使用’ stop() ‘方法停止’ ApplicationContext ‘时发布。 这里，“stopped”意味着所有“Lifecycle”bean都接收一个显式的停止信号。 一个停止的上下文可以通过’ start() ‘调用重新启动。\n\n\nContextClosedEvent\n在’ ConfigurableApplicationContext ‘接口上的’ close() ‘方法或通过JVM关闭钩子关闭’ ApplicationContext ‘时发布。 这里，“closed”意味着将销毁所有单例bean。 一旦关闭上下文，它将到达其生命周期的结束，不能刷新或重新启动。\n\n\nRequestHandledEvent\n一个特定于web的事件，告诉所有bean一个HTTP请求已经得到了服务。 此事件在请求完成后发布。 这个事件只适用于使用Spring ‘ DispatcherServlet ‘的web应用程序。\n\n\nServletRequestHandledEvent\n‘ requestthandledevent ‘的子类，用于添加特定于servlet的上下文信息。\n\n\n这些标准事件会在特定的时间发布，我们可以监听这些事件，并在事件发布时做我们想做的工作。\n第三章：Resources​\t\tJava拥有标准【java.net.URL】类和各种URL前缀的标准处理程序，不幸的是，对于所有底层资源的访问来说，还不够充分。 例如，没有标准化的【URL】用来访问需要从类路径或相对于【ServletContext】获取资源的方式，而spring为我们解决了这些问题。\n一、Resource接口​\t\tSpring的【Resource】接口位于【org.springframework.core.io】 包，他抽象了对资源的访问的能力。 下面提供了【Resource】接口的概述， Spring本身广泛地使用了Resource接口。\npublic interface Resource extends InputStreamSource &#123;\n\n    boolean exists();\n    boolean isReadable();\n    boolean isOpen();\n    boolean isFile();\n    URL getURL() throws IOException;\n    URI getURI() throws IOException;\n    File getFile() throws IOException;\n    ReadableByteChannel readableChannel() throws IOException;\n    long contentLength() throws IOException;\n    long lastModified() throws IOException;\n    Resource createRelative(String relativePath) throws IOException;\n    String getFilename();\n    String getDescription();\n&#125;\n\n\n\n二、内置的 Resource的实现Spring包含了几个内置的 Resource 实现，如下所示：\n1、UrlResourceUrlResource包装了java.net.URL，可以用来访问任何需要通过URL访问的对象，例如文件、HTTPS目标、FTP目标等。 所有URL都用一个标准化的“String”表示，这样就可以使用适当的标准化前缀来表示不同类型的URL。 这包括用于访问文件系统路径的’ file: ‘，用于通过https协议访问资源的’ https: ‘，用于通过ftp访问资源的’ ftp: ‘等。  \n2、 ClassPathResource该类表示应该从【类路径】中获取的资源。 它使用线程上下文类装入器、给定的类装入器或给定的类装入资源。  \n3、FileSystemResource这是【java.io】的【Resource】实现。\n4、PathResource这是一个【java.nio.file】的【资源】实现。\n5、ServletContextResource这是【ServletContext】资源的【Resource】实现，它解释了相关web应用程序根目录中的相对路径。  \n6、InputStreamResource一个【InputStreamResource】是一个给定的【InputStream】的【Resource】实现。 只有当没有特定的【资源】实现适用时，才应该使用它。 特别是，如果可能的话，最好使用【ByteArrayResource】或任何基于文件的【Resource】实现。  \n7、 ByteArrayResource这是一个给定字节数组的【资源】实现。 它为给定的字节数组创建一个ByteArrayInputStream。  \n它可以从任何给定的字节数组加载内容，而不需要求助于一次性使用的InputStreamResource。  \n三、ResourceLoader接口 ResourceLoader 接口定义了加载资源的基本能力和方式。 下面的例子显示了 ResourceLoader接口定义:  \npublic interface ResourceLoader &#123;\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n&#125;\n\n所有应用程序上下文（applicationContext）都实现了【ResourceLoader】接口。 因此，可以所有的【应用程序上下文实现（ClassPathXmlA…）】都拥有加载资源的能力。  \n当您在特定的应用程序上下文中调用’ getResource() ‘时，如果指定的位置路径【没有特定的前缀】，您将返回【适合该特定应用程序上下文中】的’ Resource ‘类型。 例如，假设以下代码片段是在’ ClassPathXmlApplicationContext ‘实例上运行的:  \nResource template = ctx.getResource(\"some/resource/path/myTemplate.txt\");\n\n\n针对 ClassPathXmlApplicationContext，该代码返回’ ClassPathResource ‘。 \n\n针对FileSystemXmlApplicationContext实例运行相同的方法，它将返回’ FileSystemResource ‘。 \n\n针对WebApplicationContext，它会返回’ ServletContextResource ‘。 它同样会为每个上下文返回适当的对象。\n\n\n另一方面，你也可以通过指定特殊的【’ classpath: ‘前缀】来强制使用【ClassPathResource】，无论应用程序的上下文类型是什么，如下面的示例所示:  \nResource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\");\n\n类似地，您可以通过指定任何标准的java.net.URL前缀来强制使用【UrlResource】。 下面的例子使用了【file】和【https】前缀:  \nResource template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\");\n\nResource template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\");\n\n下表总结了将’ String ‘对象转换为’ Resource ‘对象的策略:  \n\n\n\n前缀\n举例\n说明\n\n\n\nclasspath:\nclasspath:com/myapp/config.xml\n从类路径加载。\n\n\nfile:\nfile:///data/config.xml\n作为一个“URL”从文件系统加载。 请参见‘ FileSystemResource ‘ Caveats。\n\n\nhttps:\nhttps://myserver/logo.png\n作为一个 URL加载。\n\n\n(none)\n/data/config.xml\n依赖于底层的 ApplicationContext。\n\n\n四、 应用环境和资源路径本节介绍如何【使用资源】创建应用程序上下文，包括使用XML的快捷方式、使用通配符以及其他细节。  \n1、构建应用程序上下文应用程序上下文构造函数通常采用【字符串或字符串数组】作为资源的位置路径，例如组成上下文定义的XML文件。  \n当这样的位置路径没有前缀时，从该路径构建并用于加载beanDifination的特定【Resource】类型取决于我们使用的这个特定的应用程序上下文。 例如，考虑下面的例子，它创建了一个’ ClassPathXmlApplicationContext ‘:  \nApplicationContext ctx = new ClassPathXmlApplicationContext(\"conf/appContext.xml\");\n\nbeanDifination是从类路径加载的，因此他使用了【ClassPathResource】。 但是，考虑下面的例子，它创建了一个’ FileSystemXmlApplicationContext ‘:  \nApplicationContext ctx =\n    new FileSystemXmlApplicationContext(\"conf/appContext.xml\");\n\n现在从【文件系统】位置加载beanDifination(在本例中，相对于当前工作目录)。  \n注意，在位置路径上使用特殊的【classpath前缀】或标准URL前缀会覆盖为加载beanDifination而创建的【默认类型Resource】。 考虑以下例子:  \nApplicationContext ctx =\n    new FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\");\n\n使用【FileSystemXmlApplicationContext】从类路径加载beanDifination。 然而，它仍然是一个“FileSystemXmlApplicationContext”。 如果它随后被用作【ResourceLoader】，任何没有前缀的路径仍然被视为文件系统路径。  \n2、源路径中的通配符应用程序上下文构造函数值中的资源路径可以是简单路径，每个路径都有到【目标资源】的一对一映射。当然，也可以包含特殊的【classpath*:】前缀或【内部ant模式】， 后者实际上都是通配符。  \n注意，这种通配符特定于在应用程序上下文构造函数中使用资源路径(或直接使用“PathMatcher”实用程序类层次结构时)，并在构造时解析。 它与“资源”类型本身无关。 你不能使用’ classpath*: ‘前缀来构造一个【实际的Resource】，因为一个resource一次只指向一个资源。  \n\n\n\n\n\n\n\n\n\nAnt-style的匹配原则\n\n\n\n\n\n\n\n\n\n\nAnt-style 模式\n路径位置可以包含ant样式的模式，如下例所示:  \n&#x2F;WEB-INF&#x2F;*-context.xml\ncom&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml\nfile:C:&#x2F;some&#x2F;path&#x2F;*-context.xml\nclasspath:com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml\n\n当路径位置包含【ant样式模式】时，解析器将遵循更复杂的过程来尝试解析通配符。   \n\n\n\n\n\n\n\n\n\nclasspath*:前缀\n当构造基于xml的应用上下文时，位置字符串可以使用特殊的’ classpath*: ‘前缀，如下所示:  \nApplicationContext ctx =\n    new ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\");\n\n\n\n\n\n\n\n\n\n\nclasspath:和classpath*:的区别\nclasspath: ：表示从该工程中的类路径中加载资源，classpath:和classpath:&#x2F;是等价的，都是相对于类的根路径。资源文件库标准的在文件系统中，也可以在JAR或ZIP的类包中。classpath*：假设多个JAR包或文件系统类路径都有一个相同的配置文件，classpath:只会在第一个加载的类路径下查找，而【classpath*:】会扫描所有这些JAR包及类路径下出现的同名文件。\n第四章 验证、数据绑定和类型转换一、BeanWrapper​\t\tbean包中一个非常重要的类是【BeanWrappe】接口及其相应的实现(【BeanWrapperImpl】)。 正如在javadoc中引用的，【BeanWrapper】提供了【设置和获取属性值】、【获取属性描述符】等功能。 此外，【BeanWrapper】提供了对嵌套属性的支持，允许对子属性进行无限深度的检索。 说的简单一点，就是这个类能帮助我对使用更简单的api通过反射操作一个bean的属性。\n\n\n\n\n\n\n\n\n\n我们以设置和获取基本和嵌套属性为例  \n设置和获取属性是通过【BeanWrapper】的’ setPropertyValue ‘和’ getPropertyValue ‘重载方法变体来完成的。 下表显示了这些约定的一些例子:  \n\n\n\n表达式\n释义\n\n\n\nname\n指示属性“name”对应于“getName()”或“isName()”和“setName(..)”方法。\n\n\naccount.name\n指示属性’ account ‘的嵌套属性’ name ‘，该属性对应于(例如)’ getAccount(). setname() ‘或’ getAccount(). getname() ‘方法。\n\n\naccount[2]\n指示索引属性’ account ‘的third元素。 索引属性的类型可以是’ array ‘、’ list ‘或其他自然有序的集合。\n\n\naccount[COMPANYNAME]\n指示由“account”、“map”属性的“COMPANYNAME”键索引的映射条目的值。\n\n\n下面两个示例类使用’ BeanWrapper ‘来获取和设置属性:  \npublic class Company &#123;\n\n    private String name;\n    private Employee managingDirector;\n\n    public String getName() &#123;\n        return this.name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public Employee getManagingDirector() &#123;\n        return this.managingDirector;\n    &#125;\n\n    public void setManagingDirector(Employee managingDirector) &#123;\n        this.managingDirector = managingDirector;\n    &#125;\n&#125;\n\n\n\npublic class Employee &#123;\n\n    private String name;\n\n    private float salary;\n\n    public String getName() &#123;\n        return this.name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public float getSalary() &#123;\n        return salary;\n    &#125;\n\n    public void setSalary(float salary) &#123;\n        this.salary = salary;\n    &#125;\n&#125;\n\n下面的代码片段展示了如何【检索和操作】实例化后的’ Company ‘ 和’ Employee ‘ 的一些属性:  \nBeanWrapper company = new BeanWrapperImpl(new Company());\n// setting the company name..\ncompany.setPropertyValue(\"name\"， \"Some Company Inc.\");\n// ... can also be done like this:\nPropertyValue value = new PropertyValue(\"name\"， \"Some Company Inc.\");\ncompany.setPropertyValue(value);\n\n// ok， let's create the director and tie it to the company:\nBeanWrapper jim = new BeanWrapperImpl(new Employee());\njim.setPropertyValue(\"name\"， \"Jim Stravinsky\");\ncompany.setPropertyValue(\"managingDirector\"， jim.getWrappedInstance());\n\n// retrieving the salary of the managingDirector through the company\nFloat salary = (Float) company.getPropertyValue(\"managingDirector.salary\");\n\n\n\n\n\n二、PropertyEditor属性编辑器​\t\tSpring使用【PropertyEditor】的概念来实现【对象】和【字符串】之间的转换。 \n​\t\t例如，【Date】可以用人类可读的方式表示（如”2007-14-09”），而我们仍然可以将人类可读的形式转换回原始日期（或者，更好的是，将任何以人类可读形式输入的日期转换回【Date 对象】。 这种行为可以通过注册类型为【java.beans.PropertyEditor 】的自定义编辑器来实现。 \n\n\n\n\n\n\n\n\n\nSpring中使用PropertyEditor的几个例子:  \n\n通过使用【PropertyEditor】实现来设置bean的属性。\n在Spring的MVC框架中解析HTTP请求参数是通过使用各种各样的【PropertyEditor】实现来完成的，后续学mvc的时候会讲。\n\n​\t\tSpring有许多内置的【PropertyEditor】实现，这使得我们的工作变得更加简单。 它们都位于【org.springframework.beans】中的propertyeditors包中。 默认情况下，大多数是由【BeanWrapperImpl】注册的。 下表描述了Spring提供的各种【PropertyEditor】实现:  \n\n\n\n分类\n释义\n\n\n\nClassEditor\n将表示类的字符串解析为实际类，反之亦然。 当未找到类时，将抛出一个’ IllegalArgumentException ‘。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\nCustomBooleanEditor\n【布尔属性】的属性编辑器。完成字符串和布尔值的转化。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\nCustomCollectionEditor\n集合的属性编辑器，将给定的描述集合的字符串转化为目标【集合类型】。\n\n\nCustomDateEditor\n可自定义的属性编辑器，支持自定义【日期格式】。 默认未注册。 必须根据需要使用适当的格式进行用户注册。\n\n\nByteArrayPropertyEditor\n字节数组的编辑器， 将字符串转换为对应的字节表示形式。 默认情况下由’ BeanWrapperImpl ‘注册。\n\n\nCustomNumberEditor\n可自定义任何【数字类】的属性编辑器，如“整数”、“长”、“Float”或“Double”。 默认情况下，由’ BeanWrapperImpl ‘注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。\n\n\nFileEditor\n将字符串解析为【java.io.file】的对象。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\nLocaleEditor\n可以将字符串解析为’ Locale ‘对象，反之亦然(字符串格式为’ [language][country][variant] ‘，与’ Locale ‘的’ toString() ‘方法相同)。 也接受空格作为分隔符，作为下划线的替代。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\nPatternEditor\n可以将字符串解析为’ java.util.regex。 模式的对象，反之亦然。\n\n\nPropertiesEditor\n可以转换字符串到’ Properties ‘对象。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\nStringTrimmerEditor\n修剪字符串的属性编辑器。 允许将空字符串转换为’ null ‘值。 默认情况下未注册-必须是用户注册的。\n\n\nURLEditor\n可以将URL的字符串表示形式解析为实际的’ URL ‘对象。 默认情况下，由’ BeanWrapperImpl ‘注册。\n\n\n\n\n\n\n\n\n\n\n\n注册额外的自定义【PropertyEditor】实现  \n​\t\t当将bean属性设置为【字符串值】时，Spring IoC容器最终使用标准JavaBeans的PropertyEditor实现将这些字符串转换为属性的复杂类型。 Spring预注册了许多自定义的【PropertyEditor】实现（例如，将一个表示为字符串的类名转换为’ class ‘对象）。 此外，Java的标准JavaBeans 【PropertyEditor】查找机制允许对类的【 PropertyEditor 】进行适当的命名，并将其放置在与其提供支持的类相同的包中，这样就可以自动找到它。  \n\n\n\n\n\n\n\n\n\n如果需要注册其他自定义的【propertyeEditors】，可以使用几种机制，其实本质是一样的。 \n\n第一种手动的方法（通常不方便也不推荐）是使用【ConfigurableBeanFactory】接口的【registerCustomEditor()】方法，这里您必须佣有一个【BeanFactory】引用，比如我们可以写一个【beanFactoryPostProccessor】。 \n另一种（稍微方便一点）机制是使用名为【CustomEditorConfigurer】的特殊beanFactoryPostProccessor，这是spring给我们提供的，下边的案例演示了这个方式。\n\n标准【PropertyEditor】实例用于将表示为字符串的属性值转换为属性的实际复杂类型。 你可以使用【CustomEditorConfigurer】，一个beanFactoryPostProccessor，来方便地添加对附加的【PropertyEditor】实例的支持到【ApplicationContext】。  \n考虑下面的例子，它定义了一个名为【ExoticType】的用户类和另一个名为【DependsOnExoticType】的类，后者需要将【ExoticType】设置为属性:  \npackage example;\n\npublic class ExoticType &#123;\n\n    private String name;\n\n    public ExoticType(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n\npublic class DependsOnExoticType &#123;\n\n    private ExoticType type;\n\n    public void setType(ExoticType type) &#123;\n        this.type = type;\n    &#125;\n&#125;\n\n我们希望能够将type属性分配为字符串，【PropertyEditor】将其转换为实际的【ExoticType】实例。 下面的beanDifination展示了如何建立这种关系:  \n&lt;bean id=\"sample\" class=\"example.DependsOnExoticType\">\n    &lt;!-- 这里没有使用rel，二十使用value，这个会当做字符串进行解析 -->\n    &lt;property name=\"type\" value=\"aNameForExoticType\"/>\n&lt;/bean>\n\n【PropertyEditor】实现类似如下:  \n// converts string representation to ExoticType object\npackage example;\n\npublic class ExoticTypeEditor extends PropertyEditorSupport &#123;\n\t// 容器发现需要一个对象的实例，而只是找到了一个字符串，就会根据type的类型匹配这个转化器\n    // 这个转化器会进行构造\n    public void setAsText(String text) &#123;\n        setValue(new ExoticType(text.toUpperCase()));\n    &#125;\n&#125;\n\n最后，下面的例子展示了如何使用【CustomEditorConfigurer】向【ApplicationContext】注册新的【PropertyEditor】，然后它将能够在需要时使用它:  \npublic class CustomEditorConfigurer implements BeanFactoryPostProcessor, Ordered\n\n这家伙是一个BeanFactoryPostProcessor，他会在创建好bean工厂后进行注册：\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;\n    if (this.propertyEditorRegistrars != null) &#123;\n        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) &#123;\n            beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);\n        &#125;\n    &#125;\n    if (this.customEditors != null) &#123;\n        this.customEditors.forEach(beanFactory::registerCustomEditor);\n    &#125;\n&#125;\n\n需要我们写的仅仅是在xml中注册一下即可：\n&lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n    &lt;property name=\"customEditors\">\n        &lt;map>\n            &lt;entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/>\n        &lt;/map>\n    &lt;/property>\n&lt;/bean>\n\n\n\n\n\n\n\n\n\n\n\n\n我们还可以使用PropertyEditorRegistrar\n下面的例子展示了如何创建自己的【propertyeditorregistry】实现:  \npackage com.foo.editors.spring;\n\npublic final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar &#123;\n\n    public void registerCustomEditors(PropertyEditorRegistry registry) &#123;\n\n        // it is expected that new PropertyEditor instances are created\n        registry.registerCustomEditor(ExoticType.class， new ExoticTypeEditor());\n\n        // you could register as many custom property editors as are required here...\n    &#125;\n&#125;\n\n下一个例子展示了如何配置一个【CustomEditorConfigurer】，并将一个【CustomPropertyEditorRegistrar】的实例注入其中:  \n&lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n    &lt;property name=\"propertyEditorRegistrars\">\n        &lt;list>\n            &lt;ref bean=\"customPropertyEditorRegistrar\"/>\n        &lt;/list>\n    &lt;/property>\n&lt;/bean>\n\n&lt;bean id=\"customPropertyEditorRegistrar\"\n    class=\"com.foo.editors.spring.CustomPropertyEditorRegistrar\"/>\n\n\n\n三、类型转换​\t\tSpring 3核心包提供了一个【通用类型转换系统】。  在Spring容器中，您可以使用此系统作为【PropertyEditor】的替代方案，将外部化bean属性值字符串转换为所需的属性类型。 \n1、 Converter的API实现类型转换逻辑很简单，如下面的接口定义所示:  \npackage org.springframework.core.convert.converter;\n\npublic interface Converter&lt;S, T> &#123;\n\n    T convert(S source);\n&#125;\n\n​\t\t创建你自己的转换器，需要实现【转换器】接口，并使用泛型“S”作为你要转换的【原始类型】，“T”作为你要转换的【目标类型】。 \n​\t\tcore.convert中提供了几个转换器实现。 其中包括从字符串到数字和其他常见类型的转换器。 下面的例子显示了’ StringToInteger ‘类，它是一个典型的’ Converter ‘实现:  \npackage org.springframework.core.convert.support;\n\nfinal class StringToInteger implements Converter&lt;String,Integer> &#123;\n\n    public Integer convert(String source) &#123;\n        return Integer.valueOf(source);\n    &#125;\n&#125;\n\n\n\n2、 ConversionService的 API【conversionservice】定义了一个用于在运行时执行类型转换逻辑的统一API：\npackage org.springframework.core.convert;\n\npublic interface ConversionService &#123;\n\n    boolean canConvert(Class&lt;?> sourceType， Class&lt;?> targetType);\n\n    &lt;T> T convert(Object source， Class&lt;T> targetType);\n\n    boolean canConvert(TypeDescriptor sourceType， TypeDescriptor targetType);\n\n    Object convert(Object source， TypeDescriptor sourceType， TypeDescriptor targetType);\n&#125;\n\n​\t\t大多数【ConversionService】实现也实现【ConverterRegistry】，它提供了一个用于注册转换器的API。\n​\t\tspring提供了一个强大的【ConversionService】实现，即 【GenericConversionService】 ，他是适合在大多数环境中使用的通用实现。Spring会选择’ ConversionService’，并在框架需要执行类型转换时使用它。\n​\t\t要在Spring中注册默认的’ conververService ‘，请添加以下带有【converversionservice】id ‘的beanDifination:  \n&lt;bean id=\"conversionService\"\n    class=\"org.springframework.context.support.ConversionServiceFactoryBean\"/>\n\n​\t\t默认的【converversionservice】可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。 要使用您自己的【自定义转换器】来补充或覆盖默认转换器，请设置【converters】属性。 属性值可以实现任何’ Converter ‘、’ ConverterFactory ‘或’ GenericConverter ‘接口。  \n&lt;bean id=\"conversionService\"\n        class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n    &lt;property name=\"converters\">\n        &lt;set>\n            &lt;bean class=\"example.MyCustomConverter\"/>\n        &lt;/set>\n    &lt;/property>\n&lt;/bean>\n\n\n\n\n\n3、 配置 DataBinder进行数据验证​\t\t从Spring 3开始，你就可以用一个【Validator】配置一个【DataBinder】实例。 一旦配置完成，您就可以通过调用【binder.validate() 】来调用【 Validator】。 任何验证’ Errors ‘都会自动添加到绑定的’ BindingResult ‘中。  \n下面的例子展示了如何通过编程方式使用DataBinder在绑定到目标对象后调用验证逻辑:  \n// 绑定一个要验证的实例\nDataBinder dataBinder = new DataBinder(new User(105,\"22\",\"22\"));\n// 绑定一个验证的规则\ndataBinder.addValidators(new Validator() &#123;\n    @Override\n    public boolean supports(Class&lt;?> clazz) &#123;\n        return clazz == User.class;\n    &#125;\n\n    @Override\n    public void validate(Object target, Errors errors) &#123;\n        User user = (User)target;\n        if (user.getId() > 100)&#123;\n            errors.rejectValue(\"id\",\"202\",\"值太大了\");\n        &#125;\n    &#125;\n&#125;);\n// 开始验证\ndataBinder.validate();\n// 获取验证的结果\nBindingResult bindingResult = dataBinder.getBindingResult();\nList&lt;ObjectError> allErrors = bindingResult.getAllErrors();\nfor (ObjectError allError : allErrors) &#123;\n    System.out.println(allError);\n&#125;\n\n\n\n\n\n\n\n第五章：Spring表达式语言（SpEL）一、简介本节介绍【SpEL接口及其表达式语言】的简单使用。 下面的代码引入了SpEL API来计算字符串字面表达式’ Hello World ‘。  \nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"'Hello World'\"); \nString message = (String) exp.getValue();\n\n消息变量的值是“Hello World”。\n【ExpressionParser】接口【负责解析表达式字符串】。 在前面的示例中，表达式字符串是由单引号表示的字符串字面量。 【Expression】接口负责计算前面定义的表达式字符串。 当调用parser 时，可以抛出ParseException和EvaluationException两个异常。 \n【Expression】接口负责【计算前面定义的表达式字符串】。 SpEL支持广泛的特性，例如调用方法、访问属性和调用构造函数。   \n\n\n\n\n\n\n\n\n\n在下面的方法调用示例中，我们甚至可以在字符串字面量上调用【concat】方法：\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"'Hello World'.concat('!')\"); \nString message = (String) exp.getValue();\n\n‘ message ‘的值现在是’Hello World!’。\n\n\n\n\n\n\n\n\n\n下面的例子调用了’ String ‘属性【bytes】:  \nExpressionParser parser = new SpelExpressionParser();\n\n// invokes 'getBytes()'\nExpression exp = parser.parseExpression(\"'Hello World'.bytes\"); \nbyte[] bytes = (byte[]) exp.getValue();\n\n这一行将字面值转换为字节数组。\n\n\n\n\n\n\n\n\n\nSpEL还通过使用标准点表示法（如’ prop1.prop2.prop3 ‘）和相应的属性值设置来支持嵌套属性。 也可以访问公共字段。  \n下面的例子展示了如何使用点表示法来获取文字的长度:  \nExpressionParser parser = new SpelExpressionParser();\n\n// invokes 'getBytes().length'\nExpression exp = parser.parseExpression(\"'Hello World'.bytes.length\"); \nint length = (Integer) exp.getValue();\n\n\n\n\n\n\n\n\n\n\n\n\n还可以调用String的构造函数而不是使用字符串字面值，如下例所示:  \nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"new String('hello world').toUpperCase()\"); \nString message = exp.getValue(String.class);\n\n从字面量构造一个新的’ String ‘，并使其为大写。\n\n\n\n\n\n\n\n\n\nSpEL更常见的用法是提供一个针对特定对象实例（称为根对象）求值的表达式字符串。 下面的例子展示了如何从’ Inventor ‘类的实例中检索’ name ‘属性:  \n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856， 7， 9);\n\n// The constructor arguments are name， birthday， and nationality.\nInventor tesla = new Inventor(\"Nikola Tesla\"， c.getTime()， \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\n\nExpression exp = parser.parseExpression(\"name\"); // Parse name as an expression\nString name = (String) exp.getValue(tesla);\n// name == \"Nikola Tesla\"\n// 这个表达式在比较连个名字是不是’Nikola Tesla‘\nexp = parser.parseExpression(\"name == 'Nikola Tesla'\");\nboolean result = exp.getValue(tesla， Boolean.class);\n// result == true\n\n二 、 Bean 定义中的表达式​\t\t您可以使用SpEL表达式和基于xml或基于注解的配置元数据来定义【BeanDefinition】实例。 在这两种情况下，定义表达式的语法形式都是#&#123;&lt;expression string&gt;&#125;。  \n1、XML配置属性或构造函数参数值可以通过使用表达式设置，如下例所示:  \n&lt;bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n    &lt;property name=\"randomNumber\" value=\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"/>\n\n    &lt;!-- other properties -->\n&lt;/bean>\n\n\n\n应用程序上下文中的所有bean都可以作为【具有公共bean名称】的预定义【变量】使用。 这包括用于访问运行时环境的标准上下文bean，如【environment】(类型为’ org.springframework.core.env.Environment ‘)，以及【systemProperties】和【systemEnvironment 】(类型为’ Map&lt;String， Object&gt; ‘)。  \n下面的示例显示了对【systemProperties】 bean的SpEL变量访问:  \n&lt;bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\">\n    &lt;property name=\"defaultLocale\" value=\"#&#123;systemProperties['user.region'] &#125;\"/>\n\n    &lt;!-- other properties -->\n&lt;/bean>\n\n注意，这里不需要在预定义变量前加上’ # ‘符号。  \n您还可以通过名称引用其他bean属性，如下例所示:  \n&lt;bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n    &lt;property name=\"randomNumber\" value=\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"/>\n\n    &lt;!-- other properties -->\n&lt;/bean>\n\n&lt;bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\">\n    &lt;property name=\"initialShapeSeed\" value=\"#&#123; numberGuess.randomNumber &#125;\"/>\n\n    &lt;!-- other properties -->\n&lt;/bean>\n\n\n\n2、注解配置要指定默认值，可以在字段、方法和方法或构造函数参数上放置“@Value”注解。  \n设置字段的默认值的示例如下:  \npublic class FieldValueTestBean &#123;\n\n    @Value(\"#&#123; systemProperties['user.region'] &#125;\")\n    private String defaultLocale;\n\n    public void setDefaultLocale(String defaultLocale) &#123;\n        this.defaultLocale = defaultLocale;\n    &#125;\n\n    public String getDefaultLocale() &#123;\n        return this.defaultLocale;\n    &#125;\n&#125;\n\n下面的例子展示了一个等价的属性setter方法:  \npublic class PropertyValueTestBean &#123;\n\n    private String defaultLocale;\n\n    @Value(\"#&#123; systemProperties['user.region'] &#125;\")\n    public void setDefaultLocale(String defaultLocale) &#123;\n        this.defaultLocale = defaultLocale;\n    &#125;\n\n    public String getDefaultLocale() &#123;\n        return this.defaultLocale;\n    &#125;\n&#125;\n\n自动连接的方法和构造函数也可以使用’ @Value ‘注解，如下面的例子所示:  \npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n    private String defaultLocale;\n\n    @Autowired\n    public void configure(MovieFinder movieFinder，\n            @Value(\"#&#123; systemProperties['user.region'] &#125;\") String defaultLocale) &#123;\n        this.movieFinder = movieFinder;\n        this.defaultLocale = defaultLocale;\n    &#125;\n\n    // ...\n&#125;\n\n\n\npublic class MovieRecommender &#123;\n\n    private String defaultLocale;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao，\n            @Value(\"#&#123;systemProperties['user.country']&#125;\") String defaultLocale) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n        this.defaultLocale = defaultLocale;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n三、语法参考（不需要记忆啊）本节描述Spring表达式语言的工作原理。 它涵盖以下主题:\n1、 文字表达方式​\t\t支持的文字表达式类型有字符串、数字值(int、real、hex)、布尔值和空值。 字符串由单引号分隔。 若要将单引号本身放入字符串中，请使用两个单引号字符。  \n​\t\t下面的例子显示了文字的简单用法。 通常，它们不会像这样单独使用，而是作为更复杂表达式的一部分使用——例如，在逻辑比较运算符的一侧使用文字。  \nExpressionParser parser = new SpelExpressionParser();\n\n// evals to \"Hello World\"\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n\ndouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n\n// evals to 2147483647\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n\nObject nullValue = parser.parseExpression(\"null\").getValue();\n\n数字支持使用负号、指数符号和小数点。 默认情况下，使用Double.parseDouble()解析实数。  \n2、  Arrays， Lists， Maps\n\n\n\n\n\n\n\n\n使用句点来指示嵌套的属性值。\n// evals to 1856\nint year = (Integer) parser.parseExpression(\"birthdate.year + 1900\").getValue(context);\n\nString city = (String) parser.parseExpression(\"placeOfBirth.city\").getValue(context);\n\nMore Actions允许属性名称的首字母不区分大小写。 因此，上面例子中的表达式可以写成“生日”。 “年+ 1900”和“出生地点”。 分别城”。 此外，可以通过方法调用访问属性——例如，’ getPlaceOfBirth(). getcity() ‘而不是’ placeOfBirth.city ‘。\n\n\n\n\n\n\n\n\n\n使用方括号表示法获取数组和列表的内容，示例如下:  \nExpressionParser parser = new SpelExpressionParser();\nEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n// Inventions Array\n\n// evaluates to \"Induction motor\"\nString invention = parser.parseExpression(\"inventions[3]\").getValue(\n        context,tesla,String.class);\n\n// Members List\n\n// evaluates to \"Nikola Tesla\"\nString name = parser.parseExpression(\"members[0].name\").getValue(\n        context,ieee,String.class);\n\n// List and Array navigation\n// evaluates to \"Wireless communication\"\nString invention = parser.parseExpression(\"members[0].inventions[6]\").getValue(\n        context,ieee,String.class);\n\n\n\n3、  内联列表可以使用&#123;&#125;符号在表达式中直接表示列表。  \n// evaluates to a Java list containing the four numbers\nList numbers = (List) parser.parseExpression(\"&#123;1，2，3，4&#125;\").getValue(context);\n\nList listOfLists = (List) parser.parseExpression(\"&#123;&#123;'a'，'b'&#125;，&#123;'x'，'y'&#125;&#125;\").getValue(context);\n\n&#123;&#125; 它本身就是一个空列表。 出于性能原因，如果列表本身完全由固定的字面值组成，则创建一个常量列表来表示表达式(而不是在每次求值时构建一个新列表)。  \n4、 内联映射您还可以使用&#123;key:value&#125; 表示法在表达式中直接表示映射。 下面的例子展示了如何做到这一点:  \n// evaluates to a Java map containing the two entries\nMap inventorInfo = (Map) parser.parseExpression(\"&#123;name:'Nikola'，dob:'10-July-1856'&#125;\").getValue(context);\n\nMap mapOfMaps = (Map) parser.parseExpression(\"&#123;name:&#123;first:'Nikola'，last:'Tesla'&#125;，dob:&#123;day:10，month:'July'，year:1856&#125;&#125;\").getValue(context);\n\n&#123;:&#125;它本身就是一个空映射。 出于性能原因，如果映射本身由固定的文字或其他嵌套的常量结构(列表或映射)组成，则创建一个常量映射来表示表达式(而不是在每次求值时构建一个新映射)。 map键的引用是可选的(除非键包含句号(‘ . ‘))。 上面的例子没有使用引号键。  \n5、 数组结构可以使用熟悉的Java语法构建数组，也可以提供一个初始化式，以便在构造时填充数组。 下面的例子展示了如何做到这一点:  \nint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context);\n\n// Array with initializer\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]&#123;1，2，3&#125;\").getValue(context);\n\n// Multi dimensional array\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n\nYou cannot currently supply an initializer when you construct a multi-dimensional array.\n6、  方法调用您可以使用典型的Java编程语法来调用方法。 您还可以在文字上调用方法。 也支持变量参数。 下面的例子展示了如何调用方法:  \n// string literal， evaluates to \"bc\"\nString bc = parser.parseExpression(\"'abc'.substring(1,3)\").getValue(String.class);\n\n// evaluates to true\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n        societyContext， Boolean.class);\n\n7、 运算符Spring表达式语言支持以下类型的操作符: \n\n关系运算符\n逻辑运算符\n数学运算符\n赋值运算符\n\n\n\n\n\n\n\n\n\n\n关系运算符\n使用标准操作符表示法支持关系操作符(等于、不等于、小于、小于或等于、大于和大于或等于)。 下面的例子展示了一些操作符示例:  \n// evaluates to true\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"2 &lt; -5.0\").getValue(Boolean.class);\n\n// evaluates to true\nboolean trueValue = parser.parseExpression(\"'black' &lt; 'block'\").getValue(Boolean.class);\n\n除了标准的关系操作符外，SpEL还支持instanceof和基于正则表达式的matches操作符。 下面的例子展示了两者的例子:  \n// evaluates to false\nboolean falseValue = parser.parseExpression(\n        \"'xyz' instanceof T(Integer)\").getValue(Boolean.class);\n\n// evaluates to true\nboolean trueValue = parser.parseExpression(\n        \"'5.00' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\").getValue(Boolean.class);\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\n        \"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\").getValue(Boolean.class);\n\n每个符号运算符也可以指定为纯字母等效符。 这避免了所使用的符号对嵌入表达式的文档类型(例如XML文档)具有特殊意义的问题。 对应文本为:  \n\nlt (&lt;)\ngt (&gt;)\nle (&lt;=)\nge (&gt;=)\neq (==)\nne (!=)\ndiv (/)\nmod (%)\nnot (!).\n\n所有的文本操作符都是不区分大小写的。 \n\n\n\n\n\n\n\n\n\n逻辑运算符\nSpEL支持以下逻辑操作符:  \n\nand (&amp;&amp;)\nor (||)\nnot (!)\n\n下面的示例演示如何使用逻辑运算符:  \n// -- AND --\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// evaluates to true\nString expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext， Boolean.class);\n\n// -- OR --\n\n// evaluates to true\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// evaluates to true\nString expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext， Boolean.class);\n\n// -- NOT --\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n// -- AND and NOT --\nString expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext， Boolean.class);\n\n\n\n\n\n\n\n\n\n\n\n\n数学运算符\n你可以在数字和字符串上使用加法运算符(+)。 您可以只在数字上使用减法(-)、乘法(*)和除法(/)操作符。 您还可以对数字使用模(%)和指数幂(^)运算符。 执行标准操作符优先级。 下面的例子展示了使用中的数学运算符:  \n// Addition\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class);  // 2\n\nString testString = parser.parseExpression(\n        \"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// Subtraction\nint four = parser.parseExpression(\"1 - -3\").getValue(Integer.class);  // 4\n\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class);  // -9000\n\n// Multiplication\nint six = parser.parseExpression(\"-2 * -3\").getValue(Integer.class);  // 6\n\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class);  // 24.0\n\n// Division\nint minusTwo = parser.parseExpression(\"6 / -3\").getValue(Integer.class);  // -2\n\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class);  // 1.0\n\n// Modulus\nint three = parser.parseExpression(\"7 % 4\").getValue(Integer.class);  // 3\n\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class);  // 1\n\n// Operator precedence\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class);  // -21\n\n\n\n\n\n\n\n\n\n\n\n\n赋值运算\n要设置属性，请使用赋值操作符(=)。 这通常是在调用 setValue中完成的，但也可以在调用getValue中完成。 下面的例子展示了使用赋值操作符的两种方法:  \nInventor inventor = new Inventor();\nEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\nparser.parseExpression(\"name\").setValue(context， inventor， \"Aleksandar Seovic\");\n\n// alternatively\nString aleks = parser.parseExpression(\n        \"name = 'Aleksandar Seovic'\").getValue(context， inventor， String.class);\n\n8、类型你可以使用特殊的’ T ‘操作符来指定一个’ java.lang.Class ‘(类型)的实例。 静态方法也可以通过使用此操作符来调用。 ‘ StandardTypeLocator ‘(它可以被替换)是建立在对’ java。 朗的包。 这意味着’ T() ‘引用’ java。 Lang ‘包不需要完全限定，但所有其他类型引用必须是完全限定的。 下面的示例演示如何使用“T”操作符:  \nClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue = parser.parseExpression(\n        \"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\")\n        .getValue(Boolean.class);\n\n9、构造函数你可以使用new操作符来调用构造函数。 你应该对所有类型使用完全限定类名，除了那些位于 java. lang package ( Integer ，  Float ，  String ，等等)。 下面的例子展示了如何使用new操作符来调用构造函数:  \nInventor einstein = p.parseExpression(\n        \"new org.spring.samples.spel.inventor.Inventor('Albert Einstein'， 'German')\")\n        .getValue(Inventor.class);\n\n// create new Inventor instance within the add() method of List\np.parseExpression(\n        \"Members.add(new org.spring.samples.spel.inventor.Inventor(\n            'Albert Einstein'， 'German'))\").getValue(societyContext);\n\n10、 变量可以使用 #variableName 语法引用表达式中的变量。 变量是通过在EvaluationContext实现上使用setVariable方法设置的。\n下面的例子展示了如何使用变量。  \nInventor tesla = new Inventor(\"Nikola Tesla\",\"Serbian\");\n\n// 我们必须创建一个上下文，在上下文中定义变量\nEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\ncontext.setVariable(\"newName\",\"Mike Tesla\");\n\nparser.parseExpression(\"name = #newName\").getValue(context,tesla);\nSystem.out.println(tesla.getName())  // \"Mike Tesla\"\n\n\n\n11、 Bean 的引用如果计算上下文已经配置了bean解析器，那么您可以使用@符号从表达式中查找bean。 \n下面的例子展示了如何做到这一点:  \n// 定义一个容器\nApplicationContext ctx = new AnnotationConfigApplicationContext(A.class);\n// 创建一个解析器\nExpressionParser parser = new SpelExpressionParser();\n// 定义一个表达式上下文\nStandardEvaluationContext context = new StandardEvaluationContext();\n// 这个地方规定了我要从哪里查找bean，我们的具体实现是BeanFactoryResolver，代表了从容器中获取\ncontext.setBeanResolver(new BeanFactoryResolver(ctx));\nObject bean = parser.parseExpression(\"@messageListener\").getValue(context);\n\n要访问FactoryBean本身，应该在bean名称前加上’ &amp; ‘符号。 下面的例子展示了如何做到这一点: \nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setBeanResolver(new MyBeanResolver());\n\n// This will end up calling resolve(context，\"&amp;foo\") on MyBeanResolver during evaluation\nObject bean = parser.parseExpression(\"&amp;foo\").getValue(context);\n\n\n\n12、 三元运算符 (If-Then-Else)可以使用三元运算符在表达式中执行if-then-else条件逻辑。 下面的例子显示了一个最小的示例:  \nString falseString = parser.parseExpression(\n        \"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n\n在这种情况下，布尔值false导致返回字符串值&#39;false exp &#39; 。 下面是一个更现实的例子:  \nExpression exp = parser.parseExpression(\"'Hello World'.bytes.length gt 2 ? 2:3\")\n\n\n\n\n\n\n\n第六章 Spring面向切面编程我们有这样的需求：\n批量给所有的service层的方法实现上统一加上事务，而不是一个个加：\n\n其实我们可以通过BeanPostProcessor做一个简单的实现：\n一、 AOP 概述\n面向切面编程(AOP)通过提供另一种考虑程序结构的方法对面向对象编程(OOP)进行了补充。 \n\nOOP中模块化的关键单元是类，而AOP中模块化的关键单元是aspect（切面）。 \n\nSpring的关键组件之一是AOP框架。 虽然Spring IoC容器不依赖于AOP(这意味着如果您不想使用AOP就不需要)，但AOP对Spring IoC进行了补充，提供了一个非常强大的企业级解决方案。\n\n\n\n\n\n\n\n\n\n\n\n这里有几个名词需要了解一下：\n\naop alliance：是AOP联盟，该组织定义了很多针对面向切面的接口api，通常Spring等其它具备动态织入功能的框架依赖此包。\nAspectJ：AOP虽然是方法论，但就好像OOP中的Java一样，一些先行者也开发了一套语言来支持AOP。目前用得比较火的就是AspectJ语言了，它是一种几乎和Java完全一样的语言，而且完全兼容Java。当然spring也有独立的AOP的实现。\n\n\n\n\n\n\n\n\n\n\n让我们从定义一些核心的AOP概念和术语开始：\n\nAspect（切面）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 \nJoin point（连接点 ）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。  \nAdvice（通知）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。 \nPointcut（切入点 ）：匹配连接点（Joinpoint）的断言。通知和一个【切入点表】达式关联，并在满足这个切入点的连接点上运行。 【切入点表达式如何和连接点匹配】是AOP的核心：Spring缺省使用AspectJ切入点语法。\nIntroduction（引入）： Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。\nTarget object（目标对象）：被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。\nAOP代理 AOP proxy： 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 \nWeaving（织入）：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象，这个过程叫织入。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n\n\n\n\n\n\n\n\n\nSpring AOP包括以下类型的通知:  \n\nBefore advice :在连接点之前运行的通知，但不能阻止执行流继续执行到连接点(除非它抛出异常)。  \nAfter returning advice :在连接点正常完成后运行的通知(例如，如果方法返回而不引发异常)。  \nAfter throwing advice:在方法通过抛出异常退出时运行的通知。  \nAfter (finally) advice:不管连接点以何种方式退出(正常或异常返回)，都要运行的通知。  \nAround advice:围绕连接点(如方法调用)的通知。 这是最有力的建议。 Around通知可以在方法调用前后执行自定义行为。 它还负责选择是继续到连接点，还是通过返回自己的返回值或抛出异常来简化被通知的方法执行。\n\n更多的内容会在后边的学习中进一步深入。\n二、Spring AOP能力和目标\nSpring AOP是用纯Java实现的。 不需要特殊的编译过程。\n\nSpring AOP目前只支持【方法执行连接点】(在Spring bean上的方法上执行通知)。  如果需要通知字段访问和更新连接点，可以考虑使用AspectJ之类的语言。  \n\nSpring AOP的AOP方法不同于大多数其他AOP框架。 目的不是提供最完整的AOP实现(尽管Spring AOP很有能力)。 相反，其目的是提供AOP实现和Spring IoC之间的紧密集成，以帮助解决企业应用程序中的常见问题。\n\n\n\n\n\n\n\n\n\n\n\nSpring和AspectJ\n​\t\tSpring框架的AOP功能通常与Spring IoC容器一起使用。 切面是通过使用普通beanDifination语法配置的。 使用Spring AOP不能轻松或有效地完成一些事情，比如通知非常细粒度的对象（通常是域对象）。 AspectJ是这种情况下的最佳选择。 然而，我们的经验是，Spring AOP为企业Java应用程序中的大多数问题提供了一个很好的解决方案。  \n​\t\tSpring AOP从不与AspectJ竞争，以提供全面的AOP解决方案。 我们相信基于代理的框架（如Spring AOP）和成熟的框架（如AspectJ）都是有价值的，它们是互补的，而不是相互竞争的。 Spring无缝地将Spring AOP和IoC与AspectJ集成在一起，以支持在一致的基于Spring的应用程序体系结构中使用AOP。 这种集成不会影响Spring AOP API或AOP Alliance API， Spring AOP保持向后兼容。 \n三、AOP代理​\t\tSpring AOP默认为AOP代理使用标准的JDK动态代理， 这允许代理任何接口（或接口集）。  \n​\t\tSpring AOP也可以使用CGLIB代理。  缺省情况下，如果业务对象没有实现接口，则使用CGLIB。 由于编写接口是很好的实践，因此业务类通常实现一个或多个业务接口是可能的。\n四、@AspectJ风格的支持​\t\t@AspectJ是将【切面】声明为带有注解的常规Java类的一种风格。 @AspectJ风格是由AspectJ项目作为AspectJ 5发行版的一部分引入的。 Spring与AspectJ 5有相同的注解， 但是，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或编织器。  \n1、对于 @AspectJ的支持​\t\t要在Spring配置中使用@AspectJ注解，您需要启用Spring支持，以便基于@AspectJ注解配置Spring AOP，如果Spring确定一个bean被一个或多个切面通知，它将自动为该bean生成一个代理，以拦截方法调用，并确保通知在需要时运行。  \n​\t\t@AspectJ支持可以通过XML或java的配置来启用。 在这两种情况下，你还需要确保【AspectJ的’ aspectjweaver.jar ‘库】在你的应用程序的类路径上(1.8或更高版本)。 这个库可以在AspectJ发行版的’ lib ‘目录中或Maven中央存储库中获得。  \n\n\n\n\n\n\n\n\n\n使用Java配置启用@AspectJ支持  \n要使用Java的【@Configuration】启用@AspectJ支持，请添加【@EnableAspectJAutoProxy】注解，如下面的示例所示:  \n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig &#123;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n使用XML配置启用@AspectJ支持，请使用&lt;aop:aspectj-autoproxy/&gt;元素，如下例所示:  \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    &lt;!-- bean definitions here -->\n\t&lt;aop:aspectj-autoproxy/>\n&lt;/beans>\n\n当然，我们需要引入aop的命名空间。\n2、 声明一个切面启用@AspectJ支持后，在应用程序上下文中定义的任何带有@AspectJ注解类的bean都会被Spring自动检测并用于配置Spring AOP。\n两个示例中的第一个展示了应用程序上下文中的常规beanDifination，它指向一个具有“@Aspect”注解的bean类:  \n&lt;bean id=\"myAspect\" class=\"org.xyz.NotVeryUsefulAspect\">\n    &lt;!-- configure properties of the aspect here -->\n&lt;/bean>\n\n两个示例中的第二个展示了’ NotVeryUsefulAspect ‘类定义，它是用’ org.aspectj.lang.annotation ‘标注的。 方面的注解;  \npackage org.xyz;\nimport org.aspectj.lang.annotation.Aspect;\n\n@Aspect\npublic class NotVeryUsefulAspect &#123;\n\n&#125;\n\n用“@Aspect”标注的类可以有方法和字段，与任何其他类一样。 它们还可以包含切入点、通知和引入(类型间)声明。  \n通过组件扫描自动检测切面你可以在Spring XML配置中通过“@Configuration”类中的“@Bean”方法将切面类注册为常规bean，或者让Spring通过类路径扫描自动检测它们——就像任何其他Spring管理的bean一样。 但是，请注意，“@Aspect”注解不足以实现类路径中的自动检测。 为了达到这个目的，您需要添加一个单独的【@Component】注解。\n在Spring AOP中，切面本身不能成为来自其他通知的目标。 类上的“@Aspect”注解将其标记为一个切面类，因此会将其排除在自动代理之外。\n3、声明一个切入点【切入点确定感兴趣的连接点】，从而使我们能够控制通知何时运行。\n切入点声明由两部分组成：包含【名称和方法签名】，以及确定我们感兴趣的方法执行的【切入点表达式】。\n怎么确定一个方法：public void com.ydlclass.service.impl.*(..)\n@Pointcut(\"execution(* transfer(..))\") // the pointcut expression\nprivate void anyOldTransfer() &#123;&#125; // the pointcut signature\n\n\n\n\n\n\n\n\n\n\n\n\n支持切入点指示器\nSpring AOP支持以下在切入点表达式中使用的AspectJ切入点指示器(PCD):  \n\nexecution: （常用）用于匹配方法执行的连接点，这是在使用Spring AOP时使用的主要切入点指示符。（匹配方法）\n\n\n\nwithin: 用于匹配指定类型内的方法执行。（匹配整个类）\n\n\n\nthis: 用于匹配当前【AOP代理对象】类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能【包括引入接口】也进行类型匹配。（配置整个类）\n\n\n\ntarget: 用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就【不包括引入接口】也进行类型匹配。（配置整个类）\n\n\n\nargs: 限制匹配连接点(使用Spring AOP时的方法执行)，其中参数是给定类型的实例。 （参数类型匹配）\n\n\n\n@target: 用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解 。（类上的注解）\n\n\n\n@args: 用于匹配当前执行的方法传入的参数持有指定注解的执行。（参数上的注解）\n\n\n\n@within: 用于匹配所有持有指定注解类型内的方法。（类上的注解）\n\n\n\n@annotation: （常用）于匹配当前执行方法持有指定注解的方法。（方法上的注解）\n\n\nbean：使用“bean(Bean id或名字通配符)”匹配特定名称的Bean对象的执行方法；Spring ASP扩展的，在AspectJ中无相应概念。\n\n\n\n\n\n\n\n\n\n\n切入点表达式运算\n可以使用’ &amp;&amp;’ || ‘和’ ! ‘组合切入点表达式。 您还可以通过名称引用切入点表达式。 下面的例子展示了三个切入点表达式:  \n@Pointcut(\"execution(public * *(..))\")\nprivate void anyPublicOperation() &#123;&#125; \n\n@Pointcut(\"within(com.xyz.myapp.trading..*)\")\nprivate void inTrading() &#123;&#125; \n\n@Pointcut(\"anyPublicOperation() &amp;&amp; inTrading()\")\nprivate void tradingOperation() &#123;&#125; \n\n\n\n\n\n\n\n\n\n\n\n\n共享公共切入点定义\n在使用企业应用程序时，开发人员经常希望从几个切面引用应用程序的模块和特定的操作集。 我们建议定义一个【CommonPointcut】切面来捕获通用的切入点表达式。 这样一个方面典型地类似于以下示例:  \npackage com.xyz.myapp;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\n\n@Aspect\npublic class CommonPointcuts &#123;\n\n    /**\n     * A join point is in the web layer if the method is defined\n     * in a type in the com.xyz.myapp.web package or any sub-package\n     * under that.\n     */\n    @Pointcut(\"within(com.xyz.myapp.web..*)\")\n    public void inWebLayer() &#123;&#125;\n\n    /**\n     * A join point is in the service layer if the method is defined\n     * in a type in the com.xyz.myapp.service package or any sub-package\n     * under that.\n     */\n    @Pointcut(\"within(com.xyz.myapp.service..*)\")\n    public void inServiceLayer() &#123;&#125;\n\n    /**\n     * A join point is in the data access layer if the method is defined\n     * in a type in the com.xyz.myapp.dao package or any sub-package\n     * under that.\n     */\n    @Pointcut(\"within(com.xyz.myapp.dao..*)\")\n    public void inDataAccessLayer() &#123;&#125;\n\n    /**\n     * A business service is the execution of any method defined on a service\n     * interface. This definition assumes that interfaces are placed in the\n     * \"service\" package， and that implementation types are in sub-packages.\n     *\n     * If you group service interfaces by functional area (for example，\n     * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then\n     * the pointcut expression \"execution(* com.xyz.myapp..service.*.*(..))\"\n     * could be used instead.\n     *\n     * Alternatively， you can write the expression using the 'bean'\n     * PCD， like so \"bean(*Service)\". (This assumes that you have\n     * named your Spring service beans in a consistent fashion.)\n     */\n    @Pointcut(\"execution(* com.xyz.myapp..service.*.*(..))\")\n    public void businessService() &#123;&#125;\n\n    /**\n     * A data access operation is the execution of any method defined on a\n     * dao interface. This definition assumes that interfaces are placed in the\n     * \"dao\" package， and that implementation types are in sub-packages.\n     */\n    @Pointcut(\"execution(* com.xyz.myapp.dao.*.*(..))\")\n    public void dataAccessOperation() &#123;&#125;\n\n&#125;\n\n您可以在任何需要切入点表达式的地方引用在这样一个切面中定义的切入点。 例如，要使服务层成为事务性的，可以这样写: \n&lt;aop:config>\n    &lt;aop:advisor\n        pointcut=\"com.xyz.myapp.CommonPointcuts.businessService()\"\n        advice-ref=\"tx-advice\"/>\n&lt;/aop:config>\n\n&lt;tx:advice id=\"tx-advice\">\n    &lt;tx:attributes>\n        &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/>\n    &lt;/tx:attributes>\n&lt;/tx:advice>\n\n\n\n4、 声明通知通知与切入点表达式相关联，并在切入点匹配的方法执行之前、之后或前后运行。 切入点表达式可以是对指定切入点的【简单引用】，也可以是适当声明的切入点表达式。  \na、（Before advice）前置通知你可以使用【@Before】注解在方面中声明before通知:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\n\n@Aspect\npublic class BeforeExample &#123;\n\n    @Before(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\")\n    public void doAccessCheck() &#123;\n        // ...\n    &#125;\n&#125;\n\n如果使用切入点表达式，可以将前面的示例重写为以下示例:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\n\n@Aspect\npublic class BeforeExample &#123;\n\n    @Before(\"execution(* com.xyz.myapp.dao.*.*(..))\")\n    public void doAccessCheck() &#123;\n        // ...\n    &#125;\n&#125;\n\nb、（After returning advice）返回通知当匹配的方法执行正常返回时，返回通知运行。 你可以通过使用【@AfterReturning】注解声明它:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.AfterReturning;\n\n@Aspect\npublic class AfterReturningExample &#123;\n\n    @AfterReturning(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\")\n    public void doAccessCheck() &#123;\n        // ...\n    &#125;\n&#125;\n\n有时，您需要在通知主体中访问返回的实际值。 你可以使用’ @afterreturn ‘的形式绑定返回值以获得访问，如下例所示:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.AfterReturning;\n\n@Aspect\npublic class AfterReturningExample &#123;\n\n    @AfterReturning(\n        pointcut=\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\"，\n        returning=\"retVal\")\n    public void doAccessCheck(Object retVal) &#123;\n        // ...\n    &#125;\n&#125;\n\n​\t\t\nc、（After throwing advice）抛出异常后通知抛出通知后，当匹配的方法执行通过抛出异常退出时运行。 你可以通过使用【 @AfterThrowing】注解来声明它，如下面的例子所示:\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.AfterThrowing;\n\n@Aspect\npublic class AfterThrowingExample &#123;\n\n    @AfterThrowing(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\")\n    public void doRecoveryActions() &#123;\n        // ...\n    &#125;\n&#125;\n\n通常，您如果希望通知仅在【抛出给定类型】的异常时运行，而且您还经常需要访问通知主体中抛出的异常。 你可以使用’ thrown ‘属性来限制匹配（如果需要，则使用’ Throwable ‘作为异常类型），并将抛出的异常绑定到一个advice参数。 下面的例子展示了如何做到这一点:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.AfterThrowing;\n\n@Aspect\npublic class AfterThrowingExample &#123;\n\n    @AfterThrowing(\n        pointcut=\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\"，\n        throwing=\"ex\")\n    public void doRecoveryActions(DataAccessException ex) &#123;\n        // ...\n    &#125;\n&#125;\n\n【throwing】属性中使用的【名称必须与通知方法中的参数名称】相对应。 当一个方法执行通过抛出异常而退出时，异常将作为相应的参数值传递给advice方法。\nd、After (Finally) 最终通知After （finally）通知在匹配的方法执行退出时运行。 它是通过使用【@After 】注解声明的。 After advice必须准备好处理正常和异常返回条件，它通常用于释放资源以及类似的目的。 下面的例子展示了如何使用after finally通知:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.After;\n\n@Aspect\npublic class AfterFinallyExample &#123;\n\n    @After(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\")\n    public void doReleaseLock() &#123;\n        // ...\n    &#125;\n&#125;\n\n更多值得注意的地方，AspectJ中的’ @After ‘通知被定义为【after finally】，类似于try-catch语句中的finally块。 它将对任何结果，其中包括【正常返回】或【从连接点抛出异常】都会进行调用，而【 @ afterreturn】只适用于成功的正常返回。\ne、Around通知【Around advice】环绕匹配的方法执行。 它有机会在方法运行之前和之后进行工作，并确定方法何时、如何运行，甚至是否真正运行。 如果您需要在方法执行之前和之后以线程安全的方式共享状态（例如，启动和停止计时器），经常使用Around通知。 我们推荐，总是使用最弱的通知形式，以满足你的要求(也就是说，不要使用环绕通知，如果前置通知也可以完成需求)。  \nAround通知是通过使用【@Around】注解声明的。 advice方法的第一个参数必须是【ProceedingJoinPoint】类型。 在通知体中，在【ProceedingJoinPoint】上调用【proceed()】会导致底层方法运行。 【proceed】方法也可以传入【Object[] 】。 当方法执行时，数组中的值被用作方法执行的参数。  \n\n\n\n\n\n\n\n\n\n下面的例子展示了如何使用around advice:  \nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.ProceedingJoinPoint;\n\n@Aspect\npublic class AroundExample &#123;\n\n    @Around(\"com.xyz.myapp.CommonPointcuts.businessService()\")\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n        // 我们可以在前边做一些工作，比如启动计时器\n        \n        // 这里是真正的方法调用的地方\n        Object retVal = pjp.proceed();\n        // 我们可以在后边做一些工作，比如停止计时器，搜集方法的执行时间\n        return retVal;\n    &#125;\n&#125;\n\n注：around通知返回的值是【方法调用者看到的返回值】。 例如，一个简单的缓存切面可以从缓存返回一个值(如果它有一个值)，如果没有，则调用’ proceed() ‘。 注意，【proceed方法】你可以只调用一次，也可以调用多次，也可以根本不去调用， 这都是可以的。  \nf、通知的参数Spring提供了完整类型的通知，这意味着您可以在【通知签名】中声明【所需的参数】(就像我们前面在返回和抛出示例中看到的那样)。 \n\n\n\n\n\n\n\n\n\n访问当前 JoinPoint\n任何通知方法都可以声明一个类型为【org.aspectj.lang.JoinPoint】的参数作为它的【第一个参数】（注意，around通知需要声明类型为’ ProceedingJoinPoint ）的第一个参数，它是【oinPoint】的一个子类。 【JoinPoint】接口提供了许多有用的方法:  \n\ngetArgs(): 返回方法参数。\ngetThis(): 返回代理对象。\ngetTarget(): 返回目标对象。\ngetSignature(): 返回被通知的方法的签名。  \ntoString(): 打印被建议的方法的有用描述。\n\n@Before(\"beforePointcut()\")\nprivate void beforeAdvice(JoinPoint jp) throws InvocationTargetException, IllegalAccessException &#123;\n    MethodSignature signature = (MethodSignature)jp.getSignature();\n    // 能拿到方法，能不能拿到方法的注解\n    Method method = signature.getMethod();\n    // 调用方法的过程\n    method.invoke(jp.getTarget(), jp.getArgs());\n\n    System.out.println(\"this is before advice\");\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n将参数传递给Advice\n我们已经看到了如何绑定【返回值或异常值】。 要使参数值对通知主体可用，可以使用【args 】的绑定形式。 如果在args表达式中使用【参数名】代替类型名，则在【调用通知】时将传递相应值作为参数值。 \n举个例子应该能更清楚地说明这一点：\n@Override\npublic String order(Integer money) &#123;\n    try &#123;\n        logger.info(\"这是order的方法\");\n        return \"inner try\";\n    &#125; finally &#123;\n        logger.info(\"finally\");\n        //return \"finally\";\n    &#125;\n&#125;\n\n@Before(\"execution(* com.ydlclass.service.impl.OrderService.*(..)) &amp;&amp; args(money,..)\")\npublic void validateAccount(Integer money) &#123;\n    System.out.println(\"before--------\" + money);\n&#125;\n\n\n\n\n\n\n\n\n\n\n切入点表达式的’ args(account，..) ‘部分有两个目的 \n\n首先，它限制只匹配哪些方法执行，其中方法接受至少一个参数，并且传递给该参数的参数是’ Account ‘的一个实例。 \n其次，它通过’ Account ‘参数使通知可以使用实际的’ Account ‘对象。\n\n​\t\t另一种方式是【编写方法】声明一个切入点，该切入点在匹配连接点时“提供”‘Account’对象值，然后从通知中引用指定的切入点。 这看起来如下:  \n@Pointcut(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account，..)\")\nprivate void accountDataAccessOperation(Account account) &#123;&#125;\n\n@Before(\"accountDataAccessOperation(account)\")\npublic void validateAccount(Account account) &#123;\n    // ...\n&#125;\n\n\n\n5、引入Introduction引入使切面能够声明被通知的对象【实现给定的接口】，也就是让代理对象实现新的接口。  \n@DeclareParents(value=\"com.ydlclass.service.impl.OrderService\",defaultImpl= ActivityService.class)\npublic static IActivityService activityService;\n\n要实现的接口由注解字段的类型决定。 @DeclareParents注解的【value】属性是一个AspectJ类型类。 任何与之匹配的类型的bean都将实现【UsageTracked】接口。 注意，在前面示例的before通知中，服务bean可以直接用作【UsageTracked】接口的实现。 如果以编程方式访问bean，您将编写以下代码:  \nIActivityService bean = ctx.getBean(IActivityService.class);\nbean.sendGif();\n\n\n\n搞过debug看到了，生成的代理实现了两个接口：\n\n6、Advice Ordering\n当多个通知都想在同一个连接点上运行时，Spring AOP遵循与AspectJ相同的优先规则来确定通知执行的顺序。 优先级最高的通知在【进入时】首先运行【因此，给定两个before通知，优先级最高的将首先运行】。 从连接点【退出】时，优先级最高的通知最后运行【因此，给定两个after通知，优先级最高的通知将第二运行】。  \n\n当在不同切面定义的两个通知都需要在同一个连接点上运行时，除非另行指定，否则执行顺序是未定义的。 您可以通过指定优先级来控制执行顺序。 在切面类中使用【Ordered】接口，或者用【@Order】注释它。 对于两个切面，从’ Ordered.getOrder() ‘返回较低值的切面(或注释值)具有较高的优先级。\n\n\n7、AOP 的例子业务代码的执行有时会由于【并发性问题】而失败（例如，死锁而导致的失败）。 如果再次尝试该操作，很可能在下一次尝试时成功。 对于适合在这种条件下重试的业务服务，我们希望进行透明地重试操作。 这是一个明显跨越service层中的多个服务的需求，因此是通过切面实现的理想需求。  \n因为我们想要重试操作，所以我们需要使用around通知，以便我们可以多次调用’ proceed ‘。 下面的例子显示了基本方面的实现:  \n@Aspect\npublic class ConcurrentOperationExecutor implements Ordered &#123;\n\n    private static final int DEFAULT_MAX_RETRIES = 2;\n\n    private int maxRetries = DEFAULT_MAX_RETRIES;\n    private int order = 1;\n\n    public void setMaxRetries(int maxRetries) &#123;\n        this.maxRetries = maxRetries;\n    &#125;\n\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n\n    public void setOrder(int order) &#123;\n        this.order = order;\n    &#125;\n\n    @Around(\"com.xyz.myapp.CommonPointcuts.businessService()\")\n    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;\n        int numAttempts = 0;\n        PessimisticLockingFailureException lockFailureException;\n        do &#123;\n            numAttempts++;\n            try &#123;\n                return pjp.proceed();\n            &#125;\n            catch(PessimisticLockingFailureException ex) &#123;\n                lockFailureException = ex;\n            &#125;\n        &#125; while(numAttempts &lt;= this.maxRetries);\n        throw lockFailureException;\n    &#125;\n&#125;\n\n注意，切面实现了’ Ordered ‘接口，因此我们可以将【该切面的优先级】设置得高于【事务通知】，我们希望每次重试时都有一个新的事务。 ‘ maxRetries ‘和’ order ‘属性都是可以由Spring配置注入的。 \n对应的Spring配置如下:  \n&lt;aop:aspectj-autoproxy/>\n\n&lt;bean id=\"concurrentOperationExecutor\" class=\"com.xyz.myapp.service.impl.ConcurrentOperationExecutor\">\n    &lt;property name=\"maxRetries\" value=\"3\"/>\n    &lt;property name=\"order\" value=\"100\"/>\n&lt;/bean>\n\n\n\n五、基于schema的AOP支持如果您喜欢基于xml的格式，Spring还提供了使用【aop命名空间】标记定义切面的支持。 它支持与使用@AspectJ样式时完全相同的切入点表达式和通知类型。 \n要使用本节中描述的aop命名空间标记，您需要导入’ spring-aop ‘模块。\n在Spring配置中，所有【切面和通知】元素都必须放在一个&lt;aop:config&gt; 元素中（在应用程序上下文配置中可以有多个&lt;aop:config&gt; 元素）。 一个&lt;aop:config&gt; 元素可以包含切入点、通知和切面元素（注意这些元素必须按照这个顺序声明）。  \n\n\n\n\n\n\n\n\n\n配置切面，切点表达式，通知的方法如下\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n&lt;/beans>\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n&lt;!--    &lt;aop:aspectj-autoproxy/>-->\n\n    &lt;aop:config>\n        &lt;aop:aspect ref=\"aop\">\n            &lt;aop:pointcut id=\"point\" expression=\"execution(* com.ydlclass..*(..))\"/>\n            &lt;aop:before method=\"beforeAdvice\" pointcut=\"execution(* com.ydlclass..*(..)) and args(money,..)\"/>\n            &lt;aop:after method=\"afterAdvice\" pointcut-ref=\"point\"/>\n            &lt;aop:after-returning method=\"afterReturningAdvice\" pointcut-ref=\"point\"/>\n            &lt;aop:after-throwing throwing=\"ex\" method=\"afterThrowing\" pointcut-ref=\"point\"/>\n\n        &lt;/aop:aspect>\n    &lt;/aop:config>\n\n    &lt;bean id=\"aop\" class=\"com.ydlclass.aspecj.MyAop\"/>\n    &lt;bean id=\"orderService\" class=\"com.ydlclass.service.impl.OrderService\"/>\n    &lt;bean id=\"userService\" class=\"com.ydlclass.service.impl.UserService\"/>\n\n&lt;/beans>\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\n&lt;aop:aspect id=\"usageTrackerAspect\" ref=\"usageTracking\">\n\n    &lt;aop:declare-parents\n        types-matching=\"com.xzy.myapp.service.*+\"\n        implement-interface=\"com.xyz.myapp.service.tracking.UsageTracked\"\n        default-impl=\"com.xyz.myapp.service.tracking.DefaultUsageTracked\"/>\n\n&lt;/aop:aspect>\n\n\n\n\n\n\n\n\n\n\n\n\nAOP示例\npublic class ConcurrentOperationExecutor implements Ordered &#123;\n\n    private static final int DEFAULT_MAX_RETRIES = 2;\n\n    private int maxRetries = DEFAULT_MAX_RETRIES;\n    private int order = 1;\n\n    public void setMaxRetries(int maxRetries) &#123;\n        this.maxRetries = maxRetries;\n    &#125;\n\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n\n    public void setOrder(int order) &#123;\n        this.order = order;\n    &#125;\n\n    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;\n        int numAttempts = 0;\n        PessimisticLockingFailureException lockFailureException;\n        do &#123;\n            numAttempts++;\n            try &#123;\n                return pjp.proceed();\n            &#125;\n            catch(PessimisticLockingFailureException ex) &#123;\n                lockFailureException = ex;\n            &#125;\n        &#125; while(numAttempts &lt;= this.maxRetries);\n        throw lockFailureException;\n    &#125;\n&#125;\n\n对应的Spring配置如下:  \n&lt;aop:config>\n\n    &lt;aop:aspect id=\"concurrentOperationRetry\" ref=\"concurrentOperationExecutor\">\n\n        &lt;aop:pointcut id=\"idempotentOperation\"\n            expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/>\n        &lt;aop:around\n            pointcut-ref=\"idempotentOperation\"\n            method=\"doConcurrentOperation\"/>\n    &lt;/aop:aspect>\n\n&lt;/aop:config>\n\n&lt;bean id=\"concurrentOperationExecutor\"\n    class=\"com.xyz.myapp.service.impl.ConcurrentOperationExecutor\">\n        &lt;property name=\"maxRetries\" value=\"3\"/>\n        &lt;property name=\"order\" value=\"100\"/>\n&lt;/bean>\n\n​\t\t\n六、选择使用哪种AOP声明风格​\t\t一旦您确定使用aop是实现给定需求的最佳方法，您如何决定是使用Spring AOP还是AspectJ，是使用【切面语言(代码)风格aspectj】、@AspectJ注解风格还是Spring XML风格?   \n1、Spring AOP 还是 Full AspectJ?​\t\tSpring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器&#x2F;编织器。 如果您只需要在Spring bean上执行操作，那么Spring AOP是正确的选择。 如果需要【通知不受Spring容器管理的对象】，则需要AspectJ。 \n2、 @AspectJ还是Spring AOP的 XML?​\t\t如果您选择使用Spring AOP，那么您可以选择@AspectJ或XML样式。   \n​\t\tXML样式可能是现有Spring用户最熟悉的，并且它是由真正的pojo支持的。 当使用AOP作为配置企业服务的工具时，XML可能是一个很好的选择(一个很好的测试是您是否认为切入点表达式是您可能想要独立更改的配置的一部分)。 使用XML样式，可以从配置中更清楚地看出系统中存在哪些。  \n​\t\tXML样式有两个缺点。 首先，它没有将它所处理的需求的实现完全封装在一个地方。 其次，与@AspectJ风格相比，XML风格在它能表达的内容上稍微受到一些限制，只支持“单例”切面实例化模型，并且不可能组合在XML中声明的命名切入点。 例如，在@AspectJ风格中，你可以写如下内容:  \n@Pointcut(\"execution(* get*())\")\npublic void propertyAccess() &#123;&#125;\n\n@Pointcut(\"execution(org.xyz.Account+ *(..))\")\npublic void operationReturningAnAccount() &#123;&#125;\n\n@Pointcut(\"propertyAccess() &amp;&amp; operationReturningAnAccount()\")\npublic void accountPropertyAccess() &#123;&#125;\n\n在XML样式中，可以声明前两个切入点:  \n&lt;aop:pointcut id=\"propertyAccess\"\n        expression=\"execution(* get*())\"/>\n\n&lt;aop:pointcut id=\"operationReturningAnAccount\"\n        expression=\"execution(org.xyz.Account+ *(..))\"/>\n\nXML方法的缺点是不能通过组合这些定义来定义“accountPropertyAccess”切入点。  \n​\t\t@AspectJ还有一个优点，即@AspectJ切面可以被Spring AOP和AspectJ理解(从而使用)。 因此，如果您以后决定需要AspectJ的功能来实现额外的需求，您可以轻松地迁移到经典的AspectJ当中。 \n​\t\t总的来说，Spring团队更喜欢自定义切面的@AspectJ风格，而不是简单的企业服务配置。  \n七、以编程方式创建@AspectJ代理除了通过使用&lt;aop:config&gt; 或&lt;aop:aspectj-autoproxy&gt;在配置中声明方面之外，还可以通过编程方式创建通知目标对象的代理。 \n代码如下：\npublic static void main(String[] args) &#123;\n    AspectJProxyFactory aspectJProxyFactory = new AspectJProxyFactory(new OrderService());\n    aspectJProxyFactory.addAspect(MyAspect.class);\n    IOrderService proxy = (IOrderService)aspectJProxyFactory.getProxy();\n    proxy.order(111);\n\n&#125;\n\n\n\n\n\n\n\n第七章  事务管理回顾jdbc中的事务是怎么实现的：\n-- 将事务设置为手动提交\nset autocommit = false;\n-- 开启事务\nSTART TRANSACTION;\nINSERT INTO `user`(id,username,`password`) values (10001,'zs','123');\n-- 新增保存点\nSAVEPOINT x;\nINSERT INTO `user`(id,username,`password`) values (10002,'lisi','123');\n-- 回滚到保存点x\nROLLBACK TO x;\nSTART TRANSACTION;\nINSERT INTO `user`(id,username,`password`) values (10003,'lisi','123');\nSELECT * FROM user;\nCOMMIT;\n\n\n\n一、Spring框架事务支持模型的优点​\t\t全面的事务支持是使用Spring框架最令人信服的原因之一。 Spring Framework为事务管理提供了一个一致的抽象，给我们的开发带来了极大的遍历。\n​\t\tSpring允许应用程序开发人员在任何环境中使用【一致的编程模型】。 只需编写一次代码，它就可以从不同环境中的不同事务管理策略中获益。 Spring框架同时提供【声明式】和【编程式】事务管理。 大多数用户更喜欢【声明式事务管理】，这也是我们在大多数情况下所推荐的。  使用声明式模型，开发人员通常【很少或不编写】与事务管理相关的代码，因此，不依赖于Spring Framework事务API或任何其他事务API，也就是啥也不用写。  \n二、 理解Spring框架的事务抽象spring事务对事务抽象提现在一下三个类中：PlatformTransactionManager，TransactionDefinition ，TransactionStatus。\n1、TransactionManagerTransactionManage主要有一下两个子接口：\n org.springframework.transaction.PlatformTransactionManager接口用于为不同平台提供统一抽象的事务管理器。\norg.springframework.transaction.ReactiveTransactionManager接口用于响应式事务管理，这个不重要。\n\n\n\n\n\n\n\n\n\n下面显示了’ PlatformTransactionManager ‘ API的定义:  \npublic interface PlatformTransactionManager extends TransactionManager &#123;\n\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;\n\n\n\n​\t\t任何【PlatformTransactionManager】接口实现类的方法抛出的【TransactionException】是未检查的  （也就是说，它继承了【java.lang.RuntimeException】的类）。 这里边隐藏了一个知识点，我们后续再说。\npublic abstract class TransactionException extends NestedRuntimeException &#123;\n    public TransactionException(String msg) &#123;\n        super(msg);\n    &#125;\n\n    public TransactionException(String msg， Throwable cause) &#123;\n        super(msg， cause);\n    &#125;\n&#125;\n\n​\t\n​\t\t任何一个【TransactionManager】的实现通常需要了解它们工作的环境：JDBC、mybatis、Hibernate等等。 下面的示例展示了如何定义一个本地的【PlatformTransactionManager】实现（在本例中，使用纯JDBC）。  \n你可以通过创建一个类似于下面这样的bean来定义JDBC ‘ DataSource ‘:  \nusername=root\npassword=root\nurl=jdbc:mysql://127.0.0.1:3306/ydlclass?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\ndriverName=com.mysql.cj.jdbc.Driver\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n    \n    &lt;context:property-placeholder location=\"jdbc.properties\"/>\n\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        &lt;property name=\"driverClassName\" value=\"$&#123;driverName&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n        &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n    &lt;/bean>\n\n&lt;/beans>\n\nDataSourceTransactionManager是PlatformTransactionManager的一个子类，他需要一个数据源进行注入：\n&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n&lt;/bean>\n\n\n\n注意点，在DataSourceTransactionManager源码中有这么一句话，讲线程的持有者绑定到线程当中：\n&#x2F;&#x2F; Bind the connection holder to the thread.\n\t\t\tif (txObject.isNewConnectionHolder()) &#123;\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n\t\t\t&#125;\n\n\n\nprivate static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources &#x3D;\n\t\t\tnew NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;);\n\n从这里我们也能大致明白，PlatformTransactionManager的事务是和线程绑定的，事务的获取是从当前线程中获取的。\n2、TransactionDefinition TransactionDefinition 接口指定了当前事务的相关配置，主要配置如下:  \n\nPropagation：通常情况下，事务范围内的所有代码都在该事务中运行。 但是，如果事务方法在 【已经存在事务的上下文中运行】，则可以指定事务的【传播行为】。\nIsolation：该事务与其他事务的工作隔离的程度。 例如，这个事务可以看到其他事务未提交的写入吗?  【隔离级别】\nTimeout：该事务在超时并被底层事务基础设施自动回滚之前运行多长时间。  \n只读状态：当代码读取但不修改数据时，可以使用只读事务。 在某些情况下，如使用Hibernate时，只读事务可能是一种有用的优化。\n\npublic interface TransactionDefinition &#123;\n\n\t/**\n\t * Support a current transaction; create a new one if none exists.\n\t */\n\tint PROPAGATION_REQUIRED = 0;\n\n\t/**\n\t * Support a current transaction; execute non-transactionally if none exists.\n\t */\n\tint PROPAGATION_SUPPORTS = 1;\n\n\t/**\n\t * Support a current transaction; throw an exception if no current transaction\n\t */\n\tint PROPAGATION_MANDATORY = 2;\n\n\t/**\n\t * Create a new transaction, suspending the current transaction if one exists.\n\t */\n\tint PROPAGATION_REQUIRES_NEW = 3;\n\n\t/**\n\t * Do not support a current transaction; rather always execute non-transactionally.\n\t */\n\tint PROPAGATION_NOT_SUPPORTED = 4;\n\n\t/**\n\t * Do not support a current transaction; throw an exception if a current transaction\n\t */\n\tint PROPAGATION_NEVER = 5;\n\n\t/**\n\t * Execute within a nested transaction if a current transaction exists,\n\t */\n\tint PROPAGATION_NESTED = 6;\n\n\n\tint ISOLATION_DEFAULT = -1;\n\n\n\tint ISOLATION_READ_UNCOMMITTED = 1;  \n\n\tint ISOLATION_READ_COMMITTED = 2; \n\n\tint ISOLATION_REPEATABLE_READ = 4;  \n\n\tint ISOLATION_SERIALIZABLE = 8;  \n\n\n\t/**\n\t * Use the default timeout of the underlying transaction system,\n\t * or none if timeouts are not supported.\n\t */\n\tint TIMEOUT_DEFAULT = -1;\n&#125;\n\n这个接口有一个默认实现：\npublic class DefaultTransactionDefinition implements TransactionDefinition, Serializable &#123;\n\n\tprivate int propagationBehavior = PROPAGATION_REQUIRED;\n\n\tprivate int isolationLevel = ISOLATION_DEFAULT;\n\n\tprivate int timeout = TIMEOUT_DEFAULT;\n\n\tprivate boolean readOnly = false;\n    \n    //....\n&#125;\n\n\n\n\n\n3、TransactionStatus​\t\tTransactionStatus接口为事务代码提供了一种简单的方法来控制事务执行和查询事务状态。下面的例子显示了TransactionStatus接口:  \npublic interface TransactionStatus extends TransactionExecution， SavepointManager， Flushable &#123;\n\n    @Override\n    //返回当前事务是否是新的; 否则将参与现有事务，或者可能从一开始就不在实际事务中运行。\n    boolean isNewTransaction();\n\n    boolean hasSavepoint();\n\n    @Override\n    // 只设置事务回滚。 这指示事务管理器，事务的唯一可能结果可能是回滚，而不是抛出异常，从而触发回滚。 \n    void setRollbackOnly();\n\n    @Override\n    // 返回事务是否被标记为仅回滚(由应用程序或事务基础设施)。  \n    boolean isRollbackOnly();\n\n    void flush();\n\n    @Override\n    // 返回该事务是否已完成，即是否已提交或回滚。  \n    boolean isCompleted();\n&#125;\n\n​\t\t\t\t\n三、编程式事务管理Spring Framework提供了两种编程式事务管理的方法:  \n\n使用TransactionTemplate。 \n使用 TransactionManager。\n\n​\t\n1、 使用 TransactionManager\n\n\n\n\n\n\n\n\n使用 PlatformTransactionManager\n​\t\t我们可以直接使用【org.springframework.transaction.PlatformTransactionManager】直接管理事务。 为此，通过bean引用将您使用的PlatformTransactionManager的实现传递给您的bean。 然后，通过使用TransactionDefinition和 TransactionStatus对象，您可以发起事务、回滚和提交。 下面的示例显示了如何这样做:  \n给容器注入对应的事务管理器：\n&lt;context:property-placeholder location=\"jdbc.properties\"/>\n&lt;context:component-scan base-package=\"com.ydlclass\"/>\n\n&lt;!-- 注入事务管理器 -->\n&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n&lt;/bean>\n\n&lt;!-- 注入事务管理器 -->\n&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n&lt;/bean>\n\n&lt;!--数据源-->\n&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n    &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n    &lt;property name=\"driverClassName\" value=\"$&#123;driverName&#125;\"/>\n    &lt;property name=\"username\" value=\"$&#123;user&#125;\"/>\n    &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n&lt;/bean>\n\n注入对应的service\n@Override\npublic void transfer(String from, String to, Integer money) &#123;\n\n    // 默认的事务配置\n    DefaultTransactionDefinition definition = new DefaultTransactionDefinition();\n    // 使用事务管理器进行事务管理\n    TransactionStatus transaction = transactionManager.getTransaction(definition);\n\n    try&#123;\n        // 转账其实是两个语句\n        String moneyFrom = \"update account set money = money - ? where username = ? \";\n        String moneyTo = \"update account set money = money + ? where username = ? \";\n        // 从转账的人处扣钱\n        jdbcTemplate.update(moneyFrom,money,from);\n        int i = 1/0;\n        jdbcTemplate.update(moneyTo,money,to);\n    &#125;catch (RuntimeException exception)&#123;\n        exception.printStackTrace();\n        // 回滚\n        transactionManager.rollback(transaction);\n    &#125;\n    // 提交\n    transactionManager.commit(transaction);\n&#125;\n\n2、 使用TransactionTemplate​\t\t【TransactionTemplate】采用了与其他Spring模板相同的方法，比如【JdbcTemplate】。 它使用回调方法将应用程序代码从获取和释放事务性资源的样板程序中解放出来，因为您的代码只关注您想要做的事情，而不是希望将大量的时间浪费在这里。  \n​\t\t正如下面的示例所示，使用【TransactionTemplate】绝对会将您与Spring的事务基础设施和api耦合在一起。 编程事务管理是否适合您的开发需求，这是您必须自己做出的决定。\n​\t\t必须在事务上下文中运行并显式使用TransactionTemplate的应用程序代码类似于下一个示例。 您作为一个应用程序开发人员，可以编写一个TransactionCallback实现（通常表示为一个匿名内部类），其中包含您需要在事务上下文中运行的代码。 然后你可以将你的自定义 TransactionCallback的一个实例传递给TransactionTemplate中暴露的 execute(..)方法。 下面的示例显示了如何这样做:  \n&lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\">\n    &lt;property name=\"transactionManager\" ref=\"transactionManager\"/>\n&lt;/bean>\n\n如果没有返回值，你可以在匿名类中使用方便的TransactionCallbackWithoutResult类，如下所示:  \n@Override\npublic void transfer3(String from, String to, Integer money) &#123;\n\n    transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status) &#123;\n            // 转账其实是两个语句\n            String moneyFrom = \"update account set money = money - ? where username = ? \";\n            String moneyTo = \"update account set money = money + ? where username = ? \";\n            // 从转账的人处扣钱\n            jdbcTemplate.update(moneyFrom, money, from);\n            //                int i = 1 / 0;\n            jdbcTemplate.update(moneyTo, money, to);\n        &#125;\n    &#125;);\n&#125;\n\n\n\n\n\n3、 声明式事务管理​\t\t大多数Spring框架用户选择声明式事务管理。 该选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n​\t\tSpring框架的声明性事务管理是通过Spring面向切面编程(AOP)实现的。 然而，由于事务切面代码随Spring Framework发行版一起提供，并且可以模板的方式使用，所以通常不需要理解AOP概念就可以有效地使用这些代码。   \n（1） 理解Spring框架的声明式事务​\t\tSpring框架的声明式事务通过AOP代理进行实现，事务的通知是由AOP元数据与事务性元数据的结合产生了一个AOP代理，该代理使用【TransactionInterceptor】结合适当的【TransactionManager】实现来驱动方法调用的事务。  \n​\t\tSpring Framework的【TransactionInterceptor】为命令式和响应式编程模型提供了事务管理。 拦截器通过检查方法返回类型来检测所需的事务管理风格。 事务管理风格会影响需要哪个事务管理器。 命令式事务需要【PlatformTransactionManager】，而响应式事务使用【ReactiveTransactionManager 】实现。\n​\t\t【@Transactional 】通常用于【PlatformTransactionManager 】管理的【线程绑定事务】，将事务暴露给当前执行线程中的所有数据访问操作。（注意：这不会传播到方法中新启动的线程）。\n（2）声明式事务实现的示例&lt;!-- from the file 'context.xml' -->\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/> bean below) -->\n    &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        &lt;!-- the transactional semantics... -->\n        &lt;tx:attributes>\n            &lt;!-- all methods starting with 'get' are read-only -->\n            &lt;tx:method name=\"get*\" read-only=\"true\"/>\n            &lt;!-- other methods use the default transaction settings (see below) -->\n            &lt;tx:method name=\"*\"/>\n        &lt;/tx:attributes>\n    &lt;/tx:advice>\n\n    &lt;!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface -->\n    &lt;aop:config>\n        &lt;aop:pointcut id=\"point\" expression=\"within(com.ydlclass.service..*)\"/>\n        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"point\"/>\n    &lt;/aop:config>\n\n&lt;/beans>\n\n\n\n\n\n（3）事务回滚​\t\t上一节概述了如何在应用程序中以声明的方式为类（通常是服务层类）指定事务设置的基础知识。 本节描述如何以简单的声明式方式控制事务的回滚。  \n重点：\n​\t\t在其默认配置中，Spring框架的事务基础结构代码只在运行时、未检查的异常情况下标记事务进行回滚。 也就是说，当抛出的异常是’ RuntimeException ‘的实例或子类时。 (默认情况下，’ Error ‘实例也会导致回滚)。 事务方法抛出的已检查异常不会导致默认配置的回滚。  \n​\t\t您还可以准确地配置哪些“Exception”类型将事务标记为回滚。 下面的XML代码片段演示了如何为一个已检查的、特定于应用程序的“Exception”类型配置回滚:  \n&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n    &lt;tx:attributes>\n    &lt;tx:method name=\"get*\" read-only=\"true\" rollback-for=\"NoProductInStockException\"/>\n    &lt;tx:method name=\"*\"/>\n    &lt;/tx:attributes>\n&lt;/tx:advice>\n\n​\t\t如果您不想在抛出异常时回滚事务，您还可以指定“无回滚规则”。 下面的例子告诉Spring框架的事务基础架构，即使面对InstrumentNotFoundException&#96;，也要提交相应的事务:  \n&lt;tx:advice id=\"txAdvice\">\n    &lt;tx:attributes>\n    &lt;tx:method name=\"updateStock\" no-rollback-for=\"InstrumentNotFoundException\"/>\n    &lt;tx:method name=\"*\"/>\n    &lt;/tx:attributes>\n&lt;/tx:advice>\n\n​\t\t当Spring Framework的事务，捕获异常并参考配置的回滚规则来决定是否将事务标记为回滚时，最强匹配规则胜出。 因此，在以下配置的情况下，除了InstrumentNotFoundException之外的任何异常都会导致事务的回滚:  \n&lt;tx:advice id=\"txAdvice\">\n    &lt;tx:attributes>\n    &lt;tx:method name=\"*\" rollback-for=\"Throwable\" no-rollback-for=\"InstrumentNotFoundException\"/>\n    &lt;/tx:attributes>\n&lt;/tx:advice>\n\n​\t\t\n（5） &lt;tx:advice/&gt; 设置本节总结了通过使用&lt;tx:advice/&gt; 标记可以指定的各种事务设置。 默认的&lt;tx:advice/&gt; 设置是:  \n\n传播行为是REQUIRED.。  \n隔离级别为 DEFAULT.\n事务处于可读写状态。\n事务超时默认为底层事务系统的默认超时，如果不支持超时，则为none。  \n任何RuntimeException触发回滚，而任何选中的Exception不会。\n\n您可以更改这些默认设置。 下表总结了嵌套在&lt;tx:advice/&gt;`和`&lt;tx:attributes/&gt;标签中的&lt;tx:method/&gt;标签的各种属性:  \n\n\n\n属性\nRequired?\n默认值\n描述\n\n\n\nname\nYes\n\n要与事务属性相关联的方法名。 通配符()字符可用于将相同的事务属性设置与许多方法相关联(例如，’ get ‘、’ handle* ‘、’ on*Event ‘等等)。\n\n\npropagation\nNo\nREQUIRED\n事务传播行为。\n\n\nisolation\nNo\nDEFAULT\n事务隔离级别。 仅适用于’ REQUIRED ‘或’ REQUIRES_NEW ‘的传播设置。\n\n\ntimeout\nNo\n-1\n事务超时(秒)。 仅适用于传播’ REQUIRED ‘或’ REQUIRES_NEW ‘。\n\n\nread-only\nNo\nfalse\n读写事务与只读事务。 只适用于’ REQUIRED ‘或’ REQUIRES_NEW ‘。\n\n\nrollback-for\nNo\n\n触发回滚的“Exception”实例的逗号分隔列表。 例如,“com.foo.MyBusinessException, ServletException”。\n\n\nno-rollback-for\nNo\n\n不触发回滚的“Exception”实例的逗号分隔列表。 例如,“com.foo.MyBusinessException, ServletException”。\n\n\n（6）使用 @Transactional​\t\t除了事务配置的基于xml的声明性方法外，还可以使用基于注解的方法。 直接在Java源代码中声明事务语义使声明更接近受影响的代码。 不存在过多耦合的危险，因为要以事务方式使用的代码几乎总是以这种方式部署的。  \n使用’ @Transactional ‘注解所提供的易用性可以用一个示例进行最好的说明，下面的文本将对此进行解释。 考虑以下类定义:  \n// the service class that we want to make transactional\n@Transactional\npublic class DefaultFooService implements FooService &#123;\n\n    @Override\n    public Foo getFoo(String fooName) &#123;\n        // ...\n    &#125;\n\n    @Override\n    public Foo getFoo(String fooName， String barName) &#123;\n        // ...\n    &#125;\n\n    @Override\n    public void insertFoo(Foo foo) &#123;\n        // ...\n    &#125;\n\n    @Override\n    public void updateFoo(Foo foo) &#123;\n        // ...\n    &#125;\n&#125;\n\n在如上所述的类级别上使用，注解指示声明类(及其子类)的所有方法的默认值。 或者，每个方法都可以单独注解。  请注意，类级注解并不适用于类层次结构中的祖先类; 在这种情况下，继承的方法需要在本地重新声明，以便参与子类级别的注解。  \n当上述POJO类被定义为Spring上下文中的bean时，您可以通过“@Configuration”类中的“@EnableTransactionManagement”注解使bean实例具有事务性。 详见javadoc。  \n在XML配置中，&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;标签提供了类似的便利:  \n&lt;!-- from the file 'context.xml' -->\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    &lt;!-- this is the service object that we want to make transactional -->\n    &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n    &lt;!-- enable the configuration of transactional behavior based on annotations -->\n    &lt;!-- a TransactionManager is still required -->\n    &lt;tx:annotation-driven transaction-manager=\"txManager\"/> \n\n    &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;!-- (this dependency is defined somewhere else) -->\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n    &lt;/bean>\n\n    &lt;!-- other &lt;bean/> definitions here -->\n\n&lt;/beans>\n\n\n\n如果要连接的’ TransactionManager ‘的bean名称为’ TransactionManager ‘，则可以省略’ tx:annotation-driven/ ‘标记中的’ transaction-manager ‘属性。 如果您想要依赖注入的’ TransactionManager ‘ bean有任何其他名称，您必须使用’ transaction-manager ‘属性，如前面的示例所示。\n当你在Spring的标准配置中使用事务性代理时，你应该只把’ @Transactional ‘注解应用到可视性为’ public ‘的方法上。 如果使用’ @Transactional ‘注解’ protected ‘、’ private ‘或包可见的方法，则不会引发错误，但已注解的方法不会显示已配置的事务设置。 \n如果需要注解非公共方法，请考虑下面段落中关于基于类的代理的提示，或者考虑使用AspectJ编译时或加载时编织(稍后介绍)。 当在“@Configuration”类中使用“@EnableTransactionManagement”时，通过注册一个自定义的“transactionAttributeSource”bean，“受保护的”或包可见的方法也可以使基于类的代理具有事务性，如下面的示例所示。 然而，请注意，基于接口的代理中的事务方法必须始终是“公共的”，并且在被代理的接口中定义。\n​\t\tSpring团队建议只使用’ @Transactional ‘注解来注解具体的类(以及具体类的方法)，而不是注解接口。 当然，您可以将’ @Transactional ‘注解放在接口(或接口方法)上，但只有当您使用基于接口的代理时，它才会发挥作用。 Java注解的事实并不意味着继承接口，如果使用基于类的代理(proxy-target-class &#x3D; “ true “)或weaving-based方面(‘模式&#x3D;“aspectj”)，事务设置不认可的代理和编织的基础设施，和对象不是包在一个事务代理。\n​\t\t在代理模式(这是默认的)中，只有通过代理进入的外部方法调用会被拦截。 这意味着，即使被调用的方法被标记为’ @Transactional ‘，自调用(实际上是目标对象中的一个方法调用目标对象的另一个方法)在运行时也不会导致实际的事务。 此外，代理必须完全初始化以提供预期的行为，因此您不应该在初始化代码中依赖此特性——例如，在’ @PostConstruct ‘方法中。\n（7）@Transactional的设置‘ @Transactional ‘注解是元数据，它指定接口、类或方法必须具有事务性语义(例如，“在调用此方法时启动一个全新的只读事务，暂停任何现有事务”)。 默认的“@Transactional”设置如下:  \n\n传播设置为 PROPAGATION_REQUIRED.\n隔离级别为 ISOLATION_DEFAULT.\n事务处于可读写状态。\n事务超时默认为底层事务系统的默认超时，如果不支持超时，则为none。  \n任何RuntimeException触发回滚，而任何选中的Exception不会。\n\n您可以更改这些默认设置。 下表总结了@Transactional注解的各种属性:  \n\n\n\n特质\n类型\n描述\n\n\n\nvalue\nString\n指定要使用的事务管理器的可选限定符。\n\n\npropagation\nenum: Propagation\n可选的传播环境。\n\n\nisolation\nenum: Isolation\n可选的隔离级别。 仅适用于REQUIRED 或 REQUIRES_NEW的传播值。\n\n\ntimeout\nint（以秒为粒度）\n可选的事务超时。 仅适用于 REQUIRED 或 REQUIRES_NEW的传播值。\n\n\nreadOnly\nboolean\n读写事务与只读事务。 只适用于 REQUIRED 或 REQUIRES_NEW的值。\n\n\nrollbackFor\nClass 对象的数组，它必须派生自 Throwable.\n必须导致回滚的异常类的可选数组。\n\n\nrollbackForClassName\n类名数组。 类必须派生自 Throwable.\n必须导致回滚的异常类名称的可选数组。\n\n\nnoRollbackFor\nClass 对象的数组，它必须派生自Throwable.\n不能导致回滚的异常类的可选数组。\n\n\nnoRollbackForClassName\nString类名数组，它必须派生自 Throwable.\n异常类名称的可选数组，该数组必须不会导致回滚。\n\n\nlabel\n数组String标签，用于向事务添加富有表现力的描述。\n事务管理器可以评估标签，以将特定于实现的行为与实际事务关联起来。\n\n\n目前，您不能显式地控制事务的名称，其中“name”指出现在事务监视器(例如，WebLogic的事务监视器)和日志输出中的事务名称。 对于声明性事务，事务名总是完全限定类名+ ‘。 +事务建议类的方法名。 例如，如果’ BusinessService ‘类的’ handlePayment(..) ‘方法启动了一个事务，事务的名称将是:  com.example.BusinessService.handlePayment.\n（8） 带 @Transactional的多个事务管理器大多数Spring应用程序只需要一个事务管理器，但是在某些情况下，您可能希望在一个应用程序中有多个独立的事务管理器。 您可以使用’ @Transactional ‘注解的’ value ‘或’ transactionManager ‘属性来指定要使用的’ transactionManager ‘的标识。 这可以是bean名，也可以是事务管理器bean的限定符值。 例如，使用限定符表示法，您可以在应用程序上下文中将下列Java代码与下列事务管理器bean声明组合起来:  \npublic class TransactionalService &#123;\n\n    @Transactional(\"order\")\n    public void setSomething(String name) &#123; ... &#125;\n\n    @Transactional(\"account\")\n    public void doSomething() &#123; ... &#125;\n\n    @Transactional(\"reactive-account\")\n    public Mono&lt;Void> doSomethingReactive() &#123; ... &#125;\n&#125;\n\n下面的例子显示了bean声明:  \n&lt;tx:annotation-driven/>\n\n    &lt;bean id=\"transactionManager1\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        ...\n        &lt;qualifier value=\"order\"/>\n    &lt;/bean>\n\n    &lt;bean id=\"transactionManager2\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        ...\n        &lt;qualifier value=\"account\"/>\n    &lt;/bean>\n\n    &lt;bean id=\"transactionManager3\" class=\"org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager\">\n        ...\n        &lt;qualifier value=\"reactive-account\"/>\n    &lt;/bean>\n\n在这种情况下，’ TransactionalService ‘上的各个方法在单独的事务管理器下运行，通过’ order ‘、’ account ‘和’ reactive-account ‘限定符进行区分。 如果没有找到特别限定的’ transactionManager ‘ bean，则仍然使用默认的’ tx:注解驱动的 ‘目标bean名’ transactionManager ‘。  \n（9）自定义注解组成如果您发现在许多不同的方法上重复使用带有’ @Transactional ‘的相同属性，Spring的元注解支持允许您为特定的用例定义自定义的组合注解。 例如，考虑以下注解定义:  \n@Target(&#123;ElementType.METHOD， ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = \"order\"， label = \"causal-consistency\")\npublic @interface OrderTx &#123;\n&#125;\n\n@Target(&#123;ElementType.METHOD， ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = \"account\"， label = \"retryable\")\npublic @interface AccountTx &#123;\n&#125;\n\n前面的注解让我们将上一节中的示例编写为如下所示:  \npublic class TransactionalService &#123;\n\n    @OrderTx\n    public void setSomething(String name) &#123;\n        // ...\n    &#125;\n\n    @AccountTx\n    public void doSomething() &#123;\n        // ...\n    &#125;\n&#125;\n\n在前面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但是我们还可以包括传播行为、回滚规则、超时和其他特性。  \n四、 事务传播\n\n\n传播行为\n含义\n\n\n\nPROPAGATION_REQUIRED\n表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务\n\n\nPROPAGATION_SUPPORTS\n表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行\n\n\nPROPAGATION_MANDATORY\n表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常\n\n\nPROPAGATION_REQUIRED_NEW\n表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager\n\n\nPROPAGATION_NOT_SUPPORTED\n表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager\n\n\nPROPAGATION_NEVER\n表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常\n\n\nPROPAGATION_NESTED\n表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务\n\n\n\n\n\n隔离级别\n含义\n\n\n\nISOLATION_DEFAULT\n使用后端数据库默认的隔离级别\n\n\nISOLATION_READ_UNCOMMITTED\n最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n\n\nISOLATION_READ_COMMITTED\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n\n\nISOLATION_REPEATABLE_READ\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生\n\n\nISOLATION_SERIALIZABLE\n最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的\n\n\n本节描述Spring中事务传播的一些语义。 本节详细描述了Spring中关于事务传播的一些语义。  \n在spring管理的事务中，要注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。  \n1、了解 PROPAGATION_REQUIRED\nPROPAGATION_REQUIRED强制物理事务，如果还没有事务存在，则强制当前范围的本地事务，或者强制参与为更大范围定义的现有“外部”事务。 在同一线程内的公共调用堆栈安排中，这是一个很好的默认设置(例如，一个服务facade将委托给几个存储库方法，其中所有底层资源都必须参与服务级事务)。  \n\n\n\n\n默认情况下，参与的事务加入外部范围的特征，静默地忽略本地隔离级别、超时值或只读标志(如果有的话)。 如果您希望在参与具有不同隔离级别的现有事务时拒绝隔离级别声明，请考虑将事务管理器上的’ validateExistingTransactions ‘标记切换为’ true ‘。 这种非宽松模式还拒绝只读不匹配(即试图参与只读外部作用域的内部读写事务)。\n\n\n\n\n\n\n\n当传播设置为“PROPAGATION_REQUIRED”时，将为应用该设置的每个方法创建一个逻辑事务范围。 每个这样的逻辑事务作用域都可以单独确定仅回滚状态，而外部事务作用域在逻辑上独立于内部事务作用域。 对于标准的‘PROPAGATION_REQUIRED’行为，所有这些作用域都映射到同一个物理事务。 因此，在内部事务作用域中设置的仅回滚标记确实会影响外部事务实际提交的机会。  \n但是，在内部事务范围设置仅回滚标记的情况下，外部事务本身没有决定回滚，因此回滚(由内部事务范围无声地触发)是不可预料的。 这时会抛出一个相应的’ unexpected drollbackexception ‘。 这是预期的行为，这样事务的调用者就不会被误导，以为执行了提交，而实际上并没有执行。 因此，如果内部事务(外部调用者不知道)将事务静默地标记为仅回滚，那么外部调用者仍然调用commit。 外部调用者需要接收一个’ unexpected drollbackexception ‘来清楚地表明回滚被执行了。  \n2、理解 PROPAGATION_REQUIRES_NEW\n 与PROPAGATION_REQUIRES_NEW相比， PROPAGATION_REQUIRED始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排中，底层资源事务是不同的，因此可以独立地提交或回滚，外部事务不受内部事务的回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务还可以声明它自己的隔离级别、超时和只读设置，而不继承外部事务的特征。  \n3、理解 PROPAGATION_NESTEDPROPAGATION_NESTED 使用单个物理事务，其中包含多个保存点，可以回滚到这些保存点。 这样的部分回滚允许内部事务范围触发其范围的回滚，而外部事务可以继续物理事务，尽管已经回滚了一些操作。 该设置通常映射到JDBC保存点上，因此它只适用于JDBC资源事务。 看到Spring的 DataSourceTransactionManager.\n五、 在编程式和声明式事务管理之间进行选择​\t\t只有在有少量事务操作的情况下，编程式事务管理通常是一个好主意。 例如，如果您有一个web应用程序，它只需要为某些更新操作使用事务，那么您可能不希望使用Spring或任何其他技术来设置事务代理。 在这种情况下，使用TransactionTemplate可能是一种很好的方法。 只有使用事务管理的编程方法才能显式地设置事务名称。  \n​\t\t另一方面，如果应用程序有许多事务操作，则声明式事务管理通常是值得的。 它使事务管理远离业务逻辑，并且不难配置。 当使用Spring框架而不是EJB CMT时，声明性事务管理的配置成本大大降低了。  \n整合mybatishttp://mybatis.org/spring\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;groupId>com.ydlclass&lt;/groupId>\n    &lt;artifactId>ssm&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n\n    &lt;properties>\n        &lt;maven.compiler.source>11&lt;/maven.compiler.source>\n        &lt;maven.compiler.target>11&lt;/maven.compiler.target>\n    &lt;/properties>\n\n\n    &lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n            &lt;version>4.13.2&lt;/version>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-context&lt;/artifactId>\n            &lt;version>5.2.18.RELEASE&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework&lt;/groupId>\n            &lt;artifactId>spring-jdbc&lt;/artifactId>\n            &lt;version>5.2.18.RELEASE&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.aspectj&lt;/groupId>\n            &lt;artifactId>aspectjweaver&lt;/artifactId>\n            &lt;version>1.9.6&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- 数据源-->\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.2.8&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 日志 -->\n        &lt;dependency>\n            &lt;groupId>ch.qos.logback&lt;/groupId>\n            &lt;artifactId>logback-classic&lt;/artifactId>\n            &lt;version>1.2.6&lt;/version>\n        &lt;/dependency>\n        &lt;!-- 数据区驱动-->\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;version>8.0.26&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- mybatis-->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis&lt;/artifactId>\n            &lt;version>3.5.5&lt;/version>\n        &lt;/dependency>\n\n        &lt;!-- 整合使用 -->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis-spring&lt;/artifactId>\n            &lt;version>2.0.6&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.22&lt;/version>\n        &lt;/dependency>\n\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n                &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n                &lt;version>3.8.1&lt;/version>\n                &lt;configuration>\n                    &lt;source>$&#123;maven.compiler.source&#125;&lt;/source>\n                    &lt;target>$&#123;maven.compiler.target&#125;&lt;/target>\n                    &lt;encoding>UTF-8&lt;/encoding>\n                &lt;/configuration>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n\n&lt;/project>\n\n\n\n\n\n/**\n * @author itnanls(微信)\n * 我们的服务： 一路陪跑，顺利就业\n */\npublic interface UserMapper &#123;\n\n    User getUser(@Param(\"userId\") int userId);\n&#125;\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://mybatis.org/schema/mybatis-spring\n        http://mybatis.org/schema/mybatis-spring.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    &lt;context:property-placeholder location=\"jdbc.properties\"/>\n    &lt;context:component-scan base-package=\"com.ydlclass\"/>\n\n    &lt;!--扫描mapper文件-->\n    &lt;mybatis:scan base-package=\"com.ydlclass.mapper\"/>\n\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n        &lt;!--        &lt;property name=\"configLocation\" value=\"mybatis-config.xml\"/>-->\n        &lt;property name=\"mapperLocations\" value=\"mapper/**/*.xml\"/>\n\n        &lt;property name=\"configuration\">\n            &lt;bean class=\"org.apache.ibatis.session.Configuration\">\n                &lt;property name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n                &lt;property name=\"logPrefix\" value=\"ydlclass_\"/>\n            &lt;/bean>\n        &lt;/property>\n    &lt;/bean>\n\n\n    &lt;!-- 注入事务管理器 -->\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n    &lt;/bean>\n\n    &lt;!--数据源-->\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n        &lt;property name=\"driverClassName\" value=\"$&#123;driverName&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;user&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n    &lt;/bean>\n\n\n    &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/> bean below) -->\n    &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        &lt;!-- the transactional semantics... -->\n        &lt;tx:attributes>\n            &lt;!-- all methods starting with 'get' are read-only -->\n            &lt;tx:method name=\"get*\" read-only=\"true\" propagation=\"SUPPORTS\"/>\n            &lt;tx:method name=\"select*\" read-only=\"true\" propagation=\"SUPPORTS\"/>\n            &lt;!-- other methods use the default transaction settings (see below) -->\n            &lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"insert*\" read-only=\"false\" propagation=\"REQUIRED\"/>\n        &lt;/tx:attributes>\n    &lt;/tx:advice>\n\n    &lt;!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface -->\n    &lt;aop:config>\n        &lt;aop:pointcut id=\"point\" expression=\"within(com.ydlclass.service..*)\"/>\n        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"point\"/>\n    &lt;/aop:config>\n    \n&lt;/beans>\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n\n    &lt;typeAliases>\n        &lt;typeAlias type=\"com.ydlclass.entity.User\" alias=\"user\"/>\n    &lt;/typeAliases>\n\n&lt;/configuration>\n\n\n\n\n\n@Slf4j\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        ClassPathXmlApplicationContext application = new ClassPathXmlApplicationContext(\"application.xml\");\n        UserMapper userMapper = application.getBean(UserMapper.class);\n        User user = userMapper.getUser(10002);\n        log.info(\"&#123;&#125;\",user);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Spring","date":"2022-10-13T02:00:00.000Z","categories_index":"java,框架,spring","tags_index":"java,框架,spring","author_index":"Leixng"},{"id":"e8eb3a6ab0f5bbc8166f7c80111edbc0","title":"linux题库","content":"1.10 练习题一、填空题1．GNU的含义是GNU’s Not Unix的递归缩写。2．Linux一般有3个主要部分： 内核　、　命令解释层　、　实用工具　。3．&#x2F;etc&#x2F;sysconfig&#x2F;network　文件主要用于设置基本的网络配置，包括主机名称、网关等。4．一块网卡对应一个配置文件，配置文件位于目录 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts　中，文件名以　ifcfg-　　　开始。5．　&#x2F;etc&#x2F;resolv.conf 文件是DNS客户端用于指定系统所用的DNS服务器的IP地址。6．POSIX是 便携式操作系统接口 的缩写，重点在规范核心与应用程序之间的接口，这是由美国电气与电子工程师学会（IEEE）所发布的一项标准。7．当前的Linux常见的应用可分为　企业应用　与个人应用　两个方面。8．Linux的版本分为　　内核版本　　和　发行版本　　　两种。9．安装Linux最少需要两个分区，分别是　swap交换分区  &#x2F;（根）分区　　　。10．Linux默认的系统管理员账号是　root　　　。二、选择题1．Linux最早是由计算机爱好者（    ）开发的。   A．Richard Petersen\t\t\t\t\tB．Linus Torvalds\t   C．Rob Pick\t\t\t\t\t\tD．Linux Sarwar2．下列中（    ）是自由软件。   A．Windows XP\tB．UNIX\t\tC．Linux\t\t\t\tD．Windows 20083．下列中（    ）不是Linux的特点。   A．多任务\t\t\tB．单用户\t\tC．设备独立性\t\tD．开放性4．Linux的内核版本2.3.20是（    ）的版本。   A．不稳定\t\t\tB．稳定的\t\tC．第三次修订\t\tD．第二次修订5．Linux安装过程中的硬盘分区工具是（    ）。   A．PQmagic\t\tB．FDISK\t\tC．FIPS\t\t\t\tD．Disk Druid6．Linux的根分区系统类型可以设置成（    ）。   A．FATl6\t\t\tB．FAT32\t\tC．ext4\t\t\t\tD．NTFS7．以下哪个命令能用来显示server当前正在监听的端口? （    ）   A．ifconfig    \t\tB．netlst   \t\t  C．iptables    \t\tD．netstat8．以下哪个文件存放机器名到IP地址的映射? （    ）   A．&#x2F;etc&#x2F;hosts   \tB．&#x2F;etc&#x2F;host  \t  C．&#x2F;etc&#x2F;host.equiv  \tD．&#x2F;etc&#x2F;hdinit9．Linux系统提供了一些网络测试命令，当与某远程网络连接不上时，就需要跟踪路由查看，以便了解在网络的什么位置出现了问题，请从下面的命令中选出满足该目的的命令。（    ）   A．ping\t\t\tB．ifconfig  \t\t  C．traceroute   \t\tD．netstat三、补充表格请将nmcli命令的含义列表补充完整。nmcli connection show \t显示所有连接nmcli connection show –active \t显示所有活动的连接状态nmcli connection show “ens33” \t显示网络连接配置nmcli device status \t显示设备状态nmcli device show ens33 \t显示网络接口属性nmcli connection add help \t查看帮助nmcli connection reload \t重新加载配置nmcli connection down test2 \t禁用test2的配置，注意一个网卡可以有多个配置。nmcli connection up test2 \t启用test2的配置nmcli device disconnect ens33 \t禁用ens33网卡，物理网卡nmcli device connect ens33 \t启用ens33网卡\n四、简答题（部分）1．简述Linux的体系结构。2．使用虚拟机安装Linux系统时，为什么要先选择稍后安装操作系统，而不是去选择RHEL 7系统镜像光盘？答：在配置界面中若直接选择了RHEL 7系统镜像，则VMware Workstation虚拟机会使用内置的安装向导自动进行安装，最终安装出来的系统跟我们后续进行实验所需的系统环境会不一样。3．简述RPM与Yum软件仓库的作用。答：RPM是为了简化安装的复杂度，而Yum软件仓库是为了解决软件包之间的依赖关系。4．安装Red Hat Linux系统的基本磁盘分区有哪些?5．Red Hat Linux系统支持的文件类型有哪些？6．丢失root口令如何解决？7．RHEL 7系统采用了systemd作为初始化进程，那么如何查看某个服务的运行状态？答：执行命令“systemctl status 服务名.service”可查看服务的运行状态，其中服务名后的.service可以省略。\n2.7  练习题一、填空题1．在Linux系统中命令　区分　大小写。在命令行中，可以使用 Tab键来自动补齐命令。2．如果要在一个命令行上输入和执行多条命令，可以使用　分号  来分隔命令。3．断开一个长命令行，可以使用　(反斜杠)　，以将一个较长的命令分成多行表达，增强命令的可读性。执行后，Shell自动显示提示符 &gt;　，表示正在输入一个长命令。4．要使程序以后台方式执行，只需在要执行的命令后跟上一个　&amp;　符号。\n二、选择题1．（    ）命令能用来查找在文件TESTFILE中包含4个字符的行。   A．grep ‘???? ‘ TESTFILE\t\t\t\tB．grep ‘…. ‘ TESTFILE   C．grep ‘^????$’ TESTFILE\t\t\tD．grep ‘^….$ ‘ TESTFILE2．（    ）命令用来显示&#x2F;home及其子目录下的文件名。   A．ls -a &#x2F;home\t\tB．ls -R &#x2F;home\tC．ls -l &#x2F;home\tD．ls -d &#x2F;home3．如果忘记了ls命令的用法，可以采用（    ）命令获得帮助。   A．？ls\t\t\tB．help ls\t\tC．man ls\t\tD．get ls4．查看系统当中所有进程的命令是（    ）。   A．ps all\t\t\tB．ps aix\t\t\tC．ps auf\t\t\tD．ps aux5．Linux中有多个查看文件的命令，如果希望在查看文件内容过程中用光标可以上下移动来查看文件内容，则符合要求的那一个命令是（    ）。   A．cat\t\t\tB．more\t\t\tC．less\t\t\tD. head6．（    ）命令可以了解您在当前目录下还有多大空间。   A．df\t\t\t\tB．du   &#x2F;\t\tC．du （目录）\t\t\tD．df 磁盘7．假如需要找出 &#x2F;etc&#x2F;my.conf 文件属于哪个包（package），可以执行（    ）命令。   A．rpm -q &#x2F;etc&#x2F;my.conf\t\t\t\tB．rpm -requires &#x2F;etc&#x2F;my.conf   C．rpm -qf &#x2F;etc&#x2F;my.conf\t\t\t\tD．rpm -q | grep &#x2F;etc&#x2F;my.conf8．在应用程序启动时，（    ）命令设置进程的优先级。   A．priority\t\t\tB．nice\t\t\tC．top\t\t\tD．setpri9．（    ）命令可以把f1.txt复制为f2.txt。   A．cp f1.txt | f2.txt\t\t\t\t\tB．cat f1.txt | f2.txt   C．cat f1.txt &gt; f2.txt\t\t\t\t\tD．copy f1.txt | f2.txt10．使用（    ）命令可以查看Linux的启动信息。    A．mesg –d\t\tB．dmesg\t\tC．cat &#x2F;etc&#x2F;mesg\tD．cat &#x2F;var&#x2F;mesg\n3.3  练  习  题一、填空题1．由于核心在内存中是受保护的区块，因此我们必须通过　shell　　　将我们输入的命令与Kernel沟通，以便让Kernel可以控制硬件正确无误地工作。2．系统合法的shell均写在　　&#x2F;etc&#x2F;shells　　文件中。3．用户默认登录取得的shell记录于　&#x2F;etc&#x2F;passwd　的最后一个字段。4．bash的功能主要有　命令编辑功能；命令与文件补全功能；命令别名设置功能；作业控制、前台与后台控制；程序化脚本；通配符等　等。5．shell变量有其规定的作用范围，可以分为　全局变量　与　　局部变量　　。6．　　set　　可以观察目前bash环境下的所有变量。7．通配符主要有　*　、　?　、　　[]　　等。8．正则表示法就是处理字符串的方法，是以　　行　　为单位来进行字符串的处理的。9．正则表示法通过一些特殊符号的辅助，可以让使用者轻易地　查找　、删除、　替换 个或某些特定的字符串。10．正则表示法与通配符是完全不一样的。　　通配符 的是bash操作接口的一个功能，但　正则表达式 种字符串处理的表示方式。二、简述题1．vim的3种运行模式是什么？如何切换？2．什么是重定向？什么是管道？什么是命令替换？3．Shell变量有哪两种？分别如何定义？　4．如何设置用户自己的工作环境？\n4.8  练习题一、填空题1．Linux操作系统是　多用户多任务 作系统，它允许多个用户同时登录到系统，使用系统资源。2．Linux系统下的用户账户分为两种：普通用户帐户  超级用户帐户（root）。3．root用户的UID为　0　　　，普通用户的UID可以在创建时由管理员指定，如果不指定，用户的UID默认从500开始顺序编号。4．在Linux系统中，创建用户账户的同时也会创建一个与用户同名的组群，该组群是用户的　主组群　。普通组群的GID默认也从　500　开始编号。5．一个用户账户可以同时是多个组群的成员，其中某个组群是该用户的　　主组群　　（私有组群），其他组群为该用户的　附属组群 （标准组群）。6．在Linux系统中，所创建的用户账户及其相关信息（密码除外）均放在　&#x2F;etc&#x2F;passwd　　　配置文件中。7．由于所有用户对&#x2F;etc&#x2F;passwd文件均有　　读取　　权限，为了增强系统的安全性，用户经过加密之后的口令都存放在　&#x2F;etc&#x2F;shadow　　　文件中。8．组群账户的信息存放在　&#x2F;etc&#x2F;group　　　文件中，而关于组群管理的信息（组群口令、组群管理员等）则存放在　&#x2F;etc&#x2F;gshadow　　　文件中。\n二、选择题1．哪个目录存放用户密码信息？（    ）   A．&#x2F;etc\t\t\tB．&#x2F;var\t\t\tC．&#x2F;dev\t\t\tD．&#x2F;boot2．请选出创建用户ID 是200、组ID是1000、用户主目录为&#x2F;home&#x2F;user01的正确命令。（    ）   A．useradd -u:200 -g:1000 -h:&#x2F;home&#x2F;user01 user01   B．useradd -u&#x3D;200 -g&#x3D;1000 -d&#x3D;&#x2F;home&#x2F;user01 user01   C．useradd -u 200 -g 1000 -d &#x2F;home&#x2F;user01 user01   D．useradd -u 200 -g 1000 -h &#x2F;home&#x2F;user01 user013．用户登录系统后首先进入下列哪个目录?（    ）   A．&#x2F;home\t\t\t\t\t\t\tB．&#x2F;root的主目录\t   C．&#x2F;usr\t\t\t\t\t\t\tD．用户自己的家目录4．在使用了shadow口令的系统中，&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow两个文件的权限正确的是（    ）。   A．-rw-r—– , -r——–\t\tB．-rw-r–r– , -r–r–r—   C．-rw-r–r– , -r——–\t\tD．-rw-r–rw- , -r—–r—5．下面哪个参数可以删除一个用户并同时删除用户的主目录？（    ）   A．rmuser –r\t\tB．deluser –r\t\tC．userdel –r\t\tD．usermgr -r6．系统管理员应该采用哪些安全措施?（    ）   A．把root密码告诉每一位用户  \t\t   B．设置telnet服务来提供远程系统维护   C．经常检测账户数量、内存信息和磁盘信息\t   D．当员工辞职后，立即删除该用户账户7．在&#x2F;etc&#x2F;group中有一行students::600:z3,14,w5，表示有多少用户在student组里？（    ）   A．3\t\t\t\tB．4\t\t\tC．5\t\t\tD．不知道8．下列的哪些命令可以用来检测用户lisa的信息？（    ）   A．finger lisa\t\t\t\t\t\tB．grep lisa &#x2F;etc&#x2F;passwd\t   C．find lisa &#x2F;etc&#x2F;passwd\t\t\t\tD．who lisa5.4 练习题一、选择题\n\n假定kernel支持vfat分区，下面哪一个操作是将&#x2F;dev&#x2F;hda1，一个Windows分区加载到&#x2F;win目录？（ D）A. mount  -t  windows  &#x2F;win  &#x2F;dev&#x2F;hda1  B. mount  -fs&#x3D;msdos  &#x2F;dev&#x2F;hda1   &#x2F;winC. mount  -s   win    &#x2F;dev&#x2F;hda1 &#x2F;win   D. mount –t  vfat  &#x2F;dev&#x2F;hda1  &#x2F;win\n请选择关于&#x2F;etc&#x2F;fstab的正确描述。（ B ）A. 启动系统后，由系统自动产生。B. 用于管理文件系统信息。C. 用于设置命名规则，是否使用可以用TAB来命名一个文件。D. 保存硬件信息。   \n存放Linux基本命令的目录是什么（ A）A. &#x2F;bin      B. &#x2F;tmp      C. &#x2F;lib    D. &#x2F;root\n对于普通用户创建的新目录，哪个是缺省的访问权限？（ A ）A. rwxr-xr-x    B. rw-rwxrw-     C. rwxrw-rw-   D. rwxrwxrw-\n如果当前目录是&#x2F;home&#x2F;sea&#x2F;china，那么“china”的父目录是哪个目录？（ A）A. &#x2F;home&#x2F;sea    B. &#x2F;home&#x2F;      C. &#x2F;      D. &#x2F;sea\n系统中有用户user1和user2，同属于users组。在user1用户目录下有一文件file1，它拥有644的权限，如果user2想修改user1用户目录下的file1文件，应拥有（ B）权限？A. 744     B. 664     C. 646     D. 746\n在一个新分区上建立文件系统应该使用命令（ C ）A. fdisk     B. makefs      C. mkfs     D. format\n用ls –al 命令列出下面的文件列表，问哪一个文件是符号连接文件？（ D）A. -rw——-  2 hel-s  users   56  Sep 09 11:05  helloB. -rw——-  2 hel-s  users   56  Sep 09 11:05  goodbeyC. drwx—–  1 hel   users  1024  Sep 10 08:10  zhangD. lrwx—–  1 hel  users  2024    Sep 12 08:12   cheng\nLinux文件系统的目录结构是一棵倒挂的树，文件都按其作用分门别类地放在相关的目录中。现有一个外部设备文件，我们应该将其放在（C  ）目录中。A. &#x2F;bin     B. &#x2F;etc    C. &#x2F;dev    D. lib \n如果umask设置为022，缺省的创建的文件的权限为：（ D ）A. —-w–w-  B.  –rwxr-xr-x  C. r-xr-x—  D. rw-r–r–二、填空题\n文件系统（File System）是磁盘上有特定格式的一片区域，操作系统利用文件系统保存和管理文件。\next文件系统在1992年4月完成。称为扩展文件系统，是第一个专门针对Linux操作系统的文件系统。Linux系统使用ext2&#x2F;ext3&#x2F;ext4文件系统。\nISO 9660是光盘所使用的标准文件系统。\nLinux的文件系统是采用阶层式的树状目录结构，在该结构中的最上层是根目录“&#x2F;”。\n默认的权限可用umask命令修改，用法非常简单，只需执行“umask 777”命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000。\n在Linux系统安装时，可以采用Disk Druid、RAID和LVM等方式进行分区。除此之外，在Linux系统中还有fdisk、cfdisk、parted等分区工具。\nRAID（Redundant Array of Inexpensive Disks），中文全称是独立磁盘冗余阵列，用于将多个廉价的小型磁盘驱动器合并成一个磁盘阵列，以提高存储性能和容错功能。RAID可分为软RAID和硬RAID，软RAID通过软件实现多块硬盘冗余。\nLVM（Logical Volume Manager）的中文全称是逻辑卷管理器，最早应用在IBM AIX系统上。它的主要作用是动态分配磁盘分区及调整磁盘分区大小，并且可以让多个分区或者物理硬盘作为一个逻辑卷（相当于一个逻辑硬盘）来使用。\n可以通过索引节点数和磁盘块区数来限制用户和组群对磁盘空间的使用。\n\n三、简答题1． RAID技术主要是为了解决什么问题呢？答：RAID技术可以解决存储设备的读写速度问题及数据的冗余备份问题。\n2． RAID 0和RAID 5哪个更安全？答：RAID 0没有数据冗余功能，因此RAID 5更安全。\n3．位于LVM最底层的是物理卷还是卷组？答：最底层的是物理卷，然后在通过物理卷组成卷组。\n4． LVM对逻辑卷的扩容和缩容操作有何异同点呢？答：扩容和缩容操作都需要先取消逻辑卷与目录的挂载关联；扩容操作是先扩容后检查文件系统完整性，而缩容操作为了保证数据的安全，需要先检查文件系统完整性再缩容。\n5． LVM的快照卷能使用几次？答：只可使用一次，而且使用后即自动删除。\n6． LVM的删除顺序是怎么样的？答：依次移除逻辑卷、卷组和物理卷。\n6.4 练习题一、选择题1．TCP&#x2F;IP中，（    ）协议是用来进行IP地址自动分配的。A．ARP\tB．NFS\tC．DHCP\tD．DDNS2．DHCP租约文件默认保存在（    ）目录中。A．&#x2F;etc&#x2F;dhcp\tB．&#x2F;var&#x2F;log&#x2F;dhcpd\tC．&#x2F;var&#x2F;log&#x2F;dhcp\tD．&#x2F;var&#x2F;lib&#x2F;dhcp3．配置完DHCP服务器，运行（    ）命令可以启动DHCP服务。A．service dhcpd  start\tB．&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;dhcpd startC．start dhcpd\t\tD．dhcpd on二、填空题1．DHCP工作过程包括DHCP Discover   DHCP offer   DHCP Request   DHCP Acknowledge  4种报文。2．如果DHCP客户端无法获得IP地址，将自动从 169.254.0.0&#x2F;16 地址段中选择一个作为自己的地址。3．在Windows环境下，使用  ipconfig  命令可以查看IP地址配置，使用  ipconfig&#x2F;release  命令可以释放IP地址，使用 ipconfig&#x2F;renew 命令可以续租IP地址。4．DHCP是一个简化主机IP地址分配管理的TCP&#x2F;IP标准协议，英文全称是    Dynamic Host Configuration Protocol    ，中文名称为    动态主机配置协议    。5．当客户端注意到它的租用期到了   50%     以上时，就要更新该租用期。这时它发送一个  DHCP Request 信息包给它所获得原始信息的服务器。6．当租用期达到期满时间的近  87.5%  时，客户端如果在前一次请求中没能更新租用期的话，它会再次试图更新租用期。7．配置Linux客户端需要修改网卡配置文件，将BOOTPROTO项设置为  BOOTPROTO&#x3D;dhcp  。三、实践题架设一台DHCP服务器，并按照下面的要求进行配置：1．为192.168.203.0&#x2F;24建立一个IP作用域，并将192.168.203.60~192.168.203.200范围内的IP地址动态分配给客户机。2．假设子网的DNS服务器的IP地址为192.168.0.9，网关为192.168.203.254，所在的域为jnrp.edu.cn，将这些参数指定给客户机使用。7.7  练  习  题一、填空题1．在Internet中计算机之间直接利用IP地址进行寻址，因而需要将用户提供的主机名转换成IP地址，我们把这个过程称为　域名解析　。2．DNS提供了一个　分级　的命名方案。3．DNS顶级域名中表示商业组织的是　com　。4．　　A　表示主机的资源记录，　CNAME　表示别名的资源记录。5．写出可以用来检测DNS资源创建的是否正确的两个工具　ping　、　oslookeup。6．DNS服务器的查询模式有　递归查询　、转寄查询7．DNS服务器分为四类：　主DNS服务器　、　辅助DNS服务器　、　转发DNS服务器　、　转发DNS服务器　。8．一般在DNS服务器之间的查询请求属于　转寄　查询。二、选择题1．在Linux环境下，能实现域名解析的功能软件模块是（    ）。   A．apache\t\t\tB．dhcpd\t\t\tC．BIND\t\tD．SQUID2．www.163.com是Internet中主机的（    ）。   A．用户名\t\t\tB．密码\t\t\tC．别名\t\t\tD．IP地址\t  E. FQDN3．在 DNS服务器配置文件中A类资源记录是什么意思? （    ）   A．官方信息\t\t\t\t\t\tB．IP地址到名字的映射   C．名字到IP地址的映射\t\t\tD．一个name server的规范4．在Linux DNS系统中，根服务器提示文件是（    ）。   A．&#x2F;etc&#x2F;named.ca\t\t\t\t\tB．&#x2F;var&#x2F;named&#x2F;named.ca   C．&#x2F;var&#x2F;named&#x2F;named.local\t\t\tD．&#x2F;etc&#x2F;named.local5．DNS指针记录的标志是（    ）。   A．A   \t\t\tB．PTR\t\t\tC．CNAME\t\tD．NS6．DNS服务使用的端口是（    ）。   A．TCP 53\t\tB．UDP 54\t\tC．TCP 54\t\tD．UDP 537．以下哪个命令可以测试DNS服务器的工作情况？（    ）。   A．dig\t\t\tB．host\t\t\tC．nslookup\t\tD．named-checkzone8．下列哪个命令可以启动DNS服务？（    ）   A．systemctl start named\t\t\t\tB．systemctl  restart named   C．service dns start\t\t\t\t\tD．&#x2F;etc&#x2F;init.d&#x2F;dns  start9．指定域名服务器位置的文件是（    ）。   A．&#x2F;etc&#x2F;hosts\t\t\t\t\t\tB．&#x2F;etc&#x2F;networks\t   C．&#x2F;etc&#x2F;resolv.conf\t\t\t\t\tD．&#x2F;.profile\n","slug":"linux题库","date":"2022-12-06T10:06:34.000Z","categories_index":"考试","tags_index":"考试","author_index":"Leixng"},{"id":"1e4363102957705e71b03727a248bf78","title":"软件设计2016B","content":"软件设计B选择题（每小题2分，共30分）对于依赖倒转的表述错误的是（  D  ）A. 依赖于抽象而不依赖于具体，也就是针对接口编程。B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道的方法集合。C. 从选项B的角度论述，一个对象可以有多个接口。D. 此题没有正确答案。\n以下意图那个是用来描述桥接模式? （  B  ）A. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。B. 将抽象部分与它的实现部分分离，使它们都可以独立地变化。C. 将一个复杂对象的构建与它的表示分离，使得同样构建过程可以创建不同的表示。D. 动态地给一个对象添加一些额外的职责。\n以下属于属于创建型设计模式的是（  C  ）。A．外观模式           \t\t\t\t  B．中介模式C．抽象工厂           \t\t\t\t  D．命令模式\n对象组合的有点表述不当的是（ D   ）A. 容器类仅能通过被包含对象的接口来对其进行访问。B. “黑盒” 复用，封装性好，因为被包含对象的内部细节对外是不可见。C. 通过获取指向其它的具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合D.造成极其严重的依赖关系。\n在应用程序开发中那种设计模式可以用于分离出算法（  A  ）。A. 策略模式       \t\t\t\t      B. 中介模式C. 组合模式          \t\t\t\t\t  D. 适配器模式\n下列不属于结构型设计模式的是（  A  ）。A．命令模式               \t\t\t  B．适配器模式C．组合模式              \t\t\t\t  D．外观模式\n当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（  A  ）模式。A.创建型  \t\t\t\t\t\t\t  B.结构型C行为型 \t\t\t\t\t\t\t\t  D.以上都可以\n在观察者模式中，表述错误的是（  C  ）A.观察者角色的更新是被动的。B.被观察者可以通知观察者进行更新C.观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进行。D.以上表述全部错误。\n开闭原则的含义是一个软件实体（  A  ）。A．应该对扩展开发，对修改关闭           B．对修改开放，对扩展关闭C．在应用子类的地方可以使用父类代替     D．应该尽可能的使用大粒度的类实现\n关于继承表述错误的是：（  D  ）A.继承是一种通过扩展一个已有对象的实现，从而获得新功能的复用方法。B.泛化类（超类）可以显式地捕获那些公共的属性和方法。特殊类（子类）则通过附加属性和方法来进行实现的扩展。C.破坏了封装性，因为这会将父类的实现细节暴露给子类。D.继承本质上是“白盒复用”，对父类的修改，不会影响到子类。\n设计模式一般是用来解决什么问题的（  A  ）。A．同一问题的不同表象\t\t\t\t     B．测试用例的设计C．编码中如何组织代码               \t D． 需求获取中业务领域知识获取的问题\n以下意图那个是用来描述 ITERATOR(迭代器)? （  C  ）A.使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。B.用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。C.提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。D.运用共享技术有效地支持大量细粒度的对象。\n下图结构图描述的是那种 模式? （A    ）\n  A.\tABSTRACT FACTORY（抽象工厂）  B. FACTORY METHOD（工厂方法）  C. BUILDER（生成器）  D. BRIDGE（桥接）\n下图结构图描述的是那种模式? （  C  ）\n  A.\tSTRATEGY(策略)  B.\tOBSERVER（观察者）  C.\tADAPTER（适配器）  D. BUILDER（生成器）\n下列模式中,属于行为模式的是（ B   ）    A. 工厂模式 \t\t\t\t\t\t B. 观察者    C. 适配器 \t\t\t\t\t\t D. 以上都是\n填空题（每空1分，共20分）  工厂模式分为 简单工厂，工厂模式，抽象工厂 三种类型。\n创立型模式的根本意图是要把  对象的创建 和  使用分离____的责任进行分离，从而降低系统的_耦合度___。\n面向对象的七条基本原则包括：开闭原则，里式代换原则，合成聚合原则，依赖倒转，迪米特法则，单一原则，接口隔离\n在存在继承关系的情况下，方法向   **超类_**方向集中，而数据向   子类_  方向集中。\n适配器模式，分为类的适配器和对象的适配器两种实现。其中类的适配器采用的是   继承   关系，而对象适配器采用的是  组合聚合．\n组合模式模式将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。\n单例模式    模式确保某一个类仅有一个实例，并自行实例化并向整个系统提供这个实例。\n外观模式     模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，为子系统中的一组接口提供一个一致的界面。\n简答题（每小题6分，共30分）​\t设计模式具有哪三大特点？          可重用性，对相同类型问题反复出现，尽管问题的环境有不同，但解决方案有效          可传授性，问题反复出现，解决问题的方案相同，大家都接受该解决方案          名称，每个设计模式都有名称\n​\t为什么面向对象的分析和设计中优先使用组合，而非继承？          继承关系有很多缺点，如果合理使用组合则可以有效的避免这些缺点，使用组合关系将系统对变化的\t\t适应力从静态提升到动态，而且由于组合将已有对象组合到了新对象中，因此新对象可以调用已有对\t\t象的功能。​\t  \t由于组合关系中各个对象的内部实现是隐藏的，我们只能通过接口调用，因此我们完全可以在运行期\t\t用实现了同样接口的另外一个对象来代替原对象，从而灵活实现运行期的行为控制。而且使用合成关\t\t系有助\t于保持每个类的职责的单一性，这样类的层次体系以及类的规模都不太可能增长为不可控\t\t制的庞然大物。​\t单例模式的两种实现方法，并说明优缺点？      懒汉式，在类被加载时，唯一的实例已经被创建。这个模式在java中很容易实现，在其他语言中很难.​\t  饿汉式，在类加载的时候不创建单例实体。只有在第一次请求实例的时候创建，并且只在第一次创建后\t\t不再创佳该类的实例\n​\t简述依赖例转原则的基本思想。请举出一个使用了软件依赖原则的软件设计模式，其中何处体现了依赖原则。  高层模块不应该依赖于低层模块，二者都应该依赖于抽象  抽象不应该依赖于细节，细节应该不依赖于抽象\n​\t列举两个可以使我们在程序中不必使用if…else结构的软件设计模式。使用软件设计模式是如何做到这一点的？   抽象不应该依赖于细节，细节应该不依赖于抽象   策略模式是将不同算法（处理方法）封装到stategy类中，状态模式是将不同状态封装到state类中。\t二者都是通过，类中的子类，实现不同情况的调用，从而有效的替换充满在程序中的 if else 语句。\n综合题（共20分）   1:我们经常碰到这种需求：通过公共场合传递文件，文件是用明文写的，凡是拿到这个文件都能看懂，传递过程中又不希望别人能看懂，于希望对文件内容进行加密。因为信息是不是军事机密，我们仅仅是想不被别人看明白，外传递过程中，传递人几乎不懂计算机的加密算法，那么很简单了，我们选择简单的字符移位的方法来实现加密。   请用外观模式实现这个文件传递过程，分别封装外观类，加密和解密类，文件存取类，客户端类。（Java语言或者类Java语言描述，语法可以不完全正确，但业务逻辑流程必须正确）\n","slug":"软件设计2016B","date":"2022-12-06T07:01:51.000Z","categories_index":"考试","tags_index":"考试","author_index":"Leixng"},{"id":"0f532b7b772da326c49235c97b678ef4","title":"软件设计2016A","content":"软件设计A选择题设计模式一般是用来解决什么问题的（  D  ）。A．需求获取中业务领域知识获取         B．测试用例的设计C．编码中如何组织代码                 D．同一问题的不同表象\n开闭原则的含义是一个软件实体（  A  ）。A．应该对扩展开发，对修改关闭         B．对修改开放，对扩展关闭C．在应用子类的地方可以使用父类代替   D．应该尽可能的使用大粒度的类实现\n以下不属于创建型设计模式的是（  B  ）。A．工厂模式           \t\t\t\t  B．Proxy模式C．抽象工厂           \t\t\t\t  D．Builder模式\n在应用程序开发中那种设计模式可以用于分离出算法（  A  ）。A.策略模式       \t\t\t\t      B.中介模式C.组合模式          \t\t\t\t  D.适配器模式\n下列属于结构型设计模式的是（  C  ）。A．工厂模式               \t\t\t  B．中介模式C．组合模式              \t\t      D．命令模式\n不和陌生人说话（ B    ）是的通俗表示表述。A．接口隔离原则            \t\t\t  B. 迪米特法则C. 开闭原则               \t          D. 依赖倒置原则\n下列属于面向对象基本原则的是（    ）A. 继承\t\t\t\t\t\t\t B. 封装C. 里氏代换           \t\t \t D. 都不是\n要依赖于抽象，不要依赖具体。即针对接口编程，不要针对实现编程,是（    ）的表述。A. 开-闭原则           \t\t\t B. 接口隔离原则C. 里氏代换原则\t\t\t\t\t D. 依赖倒转原则\n设计模式的两大主题是（    ）A. 系统的维护与开发 \t\t\t B. 对象组合与类的继承C. 系统架构与系统开发 \t\t\t D. 系统复用与系统扩展\n以下对”开-闭”原则的一些描述错误的是? （    ）A. “开-闭”原则与”对可变性的封装原则”没有相似性.B. 找到一个系统的可变元素,将它封装起来,叫”开-闭”原则C. 对修改关闭: 是其原则之一D. 从抽象层导出一个或多个新的具体类可以改变系统的行为,是其原则之一\n以下意图那个是用来描述SINGLETON（单例模式）? （    ）A. 将一个类的接口转换成客户希望的另外一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作B. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。C. 定义一系列算法，并把他们分装起来， 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。D. 用一个中介对象来封装一系列的对象交互。\n以下意图那个是用来描述COMPOSITE（组合模式）? （    ）A. 为其他对象提供一种代理以控制对这个对象的访问。B. 运用共享技术有效地支持大量细粒度的对象。C. 将对象组合成树形结构以表示 “部分-整体” 的层次结构。D. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n以下意图那个是用来描述 FACADE（外观模式）?(   )A. 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。B. 定义一个用于创建对象的接口，让子类决定实例化哪一个类。C. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。D. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n以下意图那个是用来描述 VISITOR（访问者模式）?(  )A. 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。B. 表示一个作用于某对象结构中的各元素的操作。C. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。D. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n设计模式的原理? (  )A. 面对实现编程 \t\t\t\t\tB. 面向对象编程C. 面向接口编程\t\t\t\t\t    D. 面向组合编程\n填空题（每空1分，共20分）工厂模式分为（_简单工厂_____）, （工厂模式）, （抽象工厂）三种类型。\n创立型模式的根本意图是要把（对象的创建）和（_使用分离_）的责任进行分离，从而降低系统的（**耦合度**）。\nMVC模型的基本工作原理是基于（观察者）模式，实现是基于（**命令_**）模式。\n设计模式的基本要素有：名字、意图 、问题 、方案、参与者与协作者 、实现、一般性结构。\n接口是可以在整个模型中反复使用的一组行为，是一个没有（属性）而只有（_方法）的类。\n软件体系结构是指一个系统的有目的的设计和规划，这个设计规划既不描述（活动），也不描述（__系统怎么开发），它只描述系统的（_组成元素）及其相互的交互协作。\n简答题（每小题6分，共30分）什么是设计模式？设计模式目标是什么？设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n设计模式中一般都遵循的原则有什么？使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码可靠性。\n在MVC模型中M、V、C分别指什么？简述它们之间的关系？M: 模型(Model), V:视图(View) C:控制Controller)。MVC模式的目的就是实现Web系统的职能分工。 Model层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。 View层用于与用户的交互，通常用JSP来实现。 Controller层是Model与View之间沟通的桥梁，它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。\n面向对象系统中功能复用的两种最常用技术是什么？类继承和对象组合类继承允许你根据其他类的实现来定义一个类的实现。父类的内部细节对子类可见。类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变被复用的实现。对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。\n只根据抽象类中定义的接口来操纵对象有什么好处？客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。**\n客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类**\n应用题（第一小题8分，第二小题12分，共20分）画出工厂方法模式的结构图。什么情况下适合使用工厂方发模式？（8分）\n请用命令设计模式实现下图所示系统（12分）\n","slug":"软件设计2016A","date":"2022-12-06T06:50:31.000Z","categories_index":"考试","tags_index":"考试","author_index":"Leixng"},{"id":"3244bafd4b77bc1eda4a2f2a047e0e05","title":"MybatisPlus","content":"MyBatisPlus今日目标\n\n\n\n\n\n\n\n\n\n基于MyBatisPlus完成标准Dao的增删改查功能\n掌握MyBatisPlus中的分页及条件查询构建\n掌握主键ID的生成策略\n了解MyBatisPlus的代码生成器\n1，MyBatisPlus入门案例与简介这一节我们来学习下MyBatisPlus的入门案例与简介，这个和其他课程都不太一样，其他的课程都是先介绍概念，然后再写入门案例。而对于MyBatisPlus的学习，我们将顺序做了调整，主要的原因MyBatisPlus主要是对MyBatis的简化，所有我们先体会下它简化在哪，然后再学习它是什么，以及它帮我们都做哪些事。\n1.1 入门案例\nMybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。\n\n开发方式\n\n基于MyBatis使用MyBatisPlus\n基于Spring使用MyBatisPlus\n&#x3D;&#x3D;基于SpringBoot使用MyBatisPlus&#x3D;&#x3D;\n\n\n\nSpringBoot刚刚我们学习完成，它能快速构建Spring开发环境用以整合其他技术，使用起来是非常简单，对于MP的学习，我们也基于SpringBoot来构建学习。\n学习之前，我们先来回顾下，SpringBoot整合Mybatis的开发过程:\n\n创建SpringBoot工程\n\n\n勾选配置使用的技术，能够实现自动添加起步依赖包\n\n\n设置dataSource相关属性(JDBC参数)\n\n\n定义数据层接口映射配置\n\n\n\n我们可以参考着上面的这个实现步骤把SpringBoot整合MyBatisPlus来快速实现下，具体的实现步骤为:\n步骤1:创建数据库及表create database if not exists mybatisplus_db character set utf8;\nuse mybatisplus_db;\nCREATE TABLE user (\n    id bigint(20) primary key auto_increment,\n    name varchar(32) not null,\n    password  varchar(32) not null,\n    age int(3) not null ,\n    tel varchar(32) not null\n);\ninsert into user values(1,'Tom','tom',3,'18866668888');\ninsert into user values(2,'Jerry','jerry',4,'16688886666');\ninsert into user values(3,'Jock','123456',41,'18812345678');\ninsert into user values(4,'传智播客','itcast',15,'4006184000');\n\n步骤2:创建SpringBoot工程\n步骤3:勾选配置使用技术\n说明:\n\n由于MP并未被收录到idea的系统内置配置，无法直接选择加入，需要手动在pom.xml中配置添加\n\n步骤4:pom.xml补全依赖&lt;dependency>\n    &lt;groupId>com.baomidou&lt;/groupId>\n    &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n    &lt;version>3.4.1&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>druid&lt;/artifactId>\n    &lt;version>1.1.16&lt;/version>\n&lt;/dependency>\n\n说明:\n\ndruid数据源可以加也可以不加，SpringBoot有内置的数据源，可以配置成使用Druid数据源\n\n从MP的依赖关系可以看出，通过依赖传递已经将MyBatis与MyBatis整合Spring的jar包导入，我们不需要额外在添加MyBatis的相关jar包\n\n\n\n步骤5:添加MP的相关配置信息resources默认生成的是properties配置文件，可以将其替换成yml文件，并在文件中配置数据库连接的相关信息:application.yml\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC \n    username: root\n    password: root\n\n说明:&#x3D;&#x3D;serverTimezone是用来设置时区，UTC是标准时区，和咱们的时间差8小时，所以可以将其修改为Asia/Shanghai&#x3D;&#x3D;\n步骤6:根据数据库表创建实体类public class User &#123;   \n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n    //setter...getter...toString方法略\n&#125;\n\n步骤7:创建Dao接口@Mapper\npublic interface UserDao extends BaseMapper&lt;User>&#123;\n&#125;\n\n步骤8:编写引导类@SpringBootApplication\n//@MapperScan(\"com.itheima.dao\")\npublic class Mybatisplus01QuickstartApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Mybatisplus01QuickstartApplication.class, args);\n    &#125;\n\n&#125;\n\n**说明:**Dao接口要想被容器扫描到，有两种解决方案:\n\n方案一:在Dao接口上添加@Mapper注解，并且确保Dao处在引导类所在包或其子包中\n该方案的缺点是需要在每一Dao接口中添加注解\n\n\n方案二:在引导类上添加@MapperScan注解，其属性为所要扫描的Dao所在包\n该方案的好处是只需要写一次，则指定包下的所有Dao接口都能被扫描到，@Mapper就可以不写。\n\n\n\n步骤9:编写测试类@SpringBootTest\nclass MpDemoApplicationTests &#123;\n\n\t@Autowired\n\tprivate UserDao userDao;\n\t@Test\n\tpublic void testGetAll() &#123;\n\t\tList&lt;User> userList = userDao.selectList(null);\n\t\tSystem.out.println(userList);\n\t&#125;\n&#125;\n\n说明:\nuserDao注入的时候下面有红线提示的原因是什么?\n\nUserDao是一个接口，不能实例化对象\n\n只有在服务器启动IOC容器初始化后，由框架创建DAO接口的代理对象来注入\n\n现在服务器并未启动，所以代理对象也未创建，IDEA查找不到对应的对象注入，所以提示报红\n\n一旦服务启动，就能注入其代理对象，所以该错误提示不影响正常运行。\n\n\n查看运行结果:\n\n跟之前整合MyBatis相比，你会发现我们不需要在DAO接口中编写方法和SQL语句了，只需要继承BaseMapper接口即可。整体来说简化很多。\n1.2 MybatisPlus简介MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在&#x3D;&#x3D;简化开发、提高效率&#x3D;&#x3D;\n通过刚才的案例，相信大家能够体会简化开发和提高效率这两个方面的优点。\nMyBatisPlus的官网为:https://mp.baomidou.com/\n说明:\n\n现在的页面中，这一行已经被删除，现在再去访问https://mybatis.plus会发现访问不到，这个就有很多可能性供我们猜想了，所以大家使用baomidou的网址进行访问即可。\n官方文档中有一张很多小伙伴比较熟悉的图片:\n\n从这张图中我们可以看出MP旨在成为MyBatis的最好搭档，而不是替换MyBatis,所以可以理解为MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。\n对于MP的学习，大家可以参考着官方文档来进行学习，里面都有详细的代码案例。\nMP的特性:\n\n无侵入：只做增强不做改变，不会对现有工程产生影响\n强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作\n支持 Lambda：编写查询条件无需担心字段写错\n支持主键自动生成\n内置分页插件\n……\n\n2，标准数据层开发在这一节中我们重点学习的是数据层标准的CRUD(增删改查)的实现与分页功能。代码比较多，我们一个个来学习。\n2.1 标准CRUD使用对于标准的CRUD功能都有哪些以及MP都提供了哪些方法可以使用呢?\n我们先来看张图:\n\n对于这张图的方法，我们挨个来演示下:\n首先说下，案例中的环境就是咱们入门案例的内容，第一个先来完成新增功能\n2.2 新增在进行新增之前，我们可以分析下新增的方法:\nint insert (T t)\n\n\nT:泛型，新增用来保存新增数据\n\nint:返回值，新增成功后返回1，没有新增成功返回的是0\n\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    void testSave() &#123;\n        User user = new User();\n        user.setName(\"黑马程序员\");\n        user.setPassword(\"itheima\");\n        user.setAge(12);\n        user.setTel(\"4006184000\");\n        userDao.insert(user);\n    &#125;\n&#125;\n\n执行测试后，数据库表中就会添加一条数据。\n\n但是数据中的主键ID，有点长，那这个主键ID是如何来的?我们更想要的是主键自增，应该是5才对，这个是我们后面要学习的主键ID生成策略，这块的这个问题，我们暂时先放放。\n2.3 删除在进行删除之前，我们可以分析下删除的方法:\nint deleteById (Serializable id)\n\n\nSerializable：参数类型\n\n思考:参数类型为什么是一个序列化类?\n\n从这张图可以看出，\n\nString和Number是Serializable的子类，\nNumber又是Float,Double,Integer等类的父类，\n能作为主键的数据类型都已经是Serializable的子类，\nMP使用Serializable作为参数类型，就好比我们可以用Object接收任何数据类型一样。\n\n\n\n\nint:返回值类型，数据删除成功返回1，未删除数据返回0。\n\n\n在测试类中进行新增操作:\n @SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    void testDelete() &#123;\n        userDao.deleteById(1401856123725713409L);\n    &#125;\n&#125;\n\n\n2.4 修改在进行修改之前，我们可以分析下修改的方法:\nint updateById(T t);\n\n\nT:泛型，需要修改的数据内容，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值\n\nint:返回值，修改成功后返回1，未修改数据返回0\n\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    void testUpdate() &#123;\n        User user = new User();\n        user.setId(1L);\n        user.setName(\"Tom888\");\n        user.setPassword(\"tom888\");\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n**说明:**修改的时候，只修改实体对象中有值的字段。\n2.5 根据ID查询在进行根据ID查询之前，我们可以分析下根据ID查询的方法:\nT selectById (Serializable id)\n\n\nSerializable：参数类型,主键ID的值\nT:根据ID查询只会返回一条数据\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetById() &#123;\n        User user = userDao.selectById(2L);\n        System.out.println(user);\n    &#125;\n&#125;\n\n2.6 查询所有在进行查询所有之前，我们可以分析下查询所有的方法:\nList&lt;T> selectList(Wrapper&lt;T> queryWrapper)\n\n\nWrapper：用来构建条件查询的条件，目前我们没有可直接传为Null\nList:因为查询的是所有，所以返回的数据是一个集合\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll() &#123;\n        List&lt;User> userList = userDao.selectList(null);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n我们所调用的方法都是来自于DAO接口继承的BaseMapper类中。里面的方法有很多，我们后面会慢慢去学习里面的内容。\n2.7 Lombok代码写到这，我们会发现DAO接口类的编写现在变成最简单的了，里面什么都不用写。反过来看看模型类的编写都需要哪些内容:\n\n私有属性\nsetter…getter…方法\ntoString方法\n构造函数\n\n虽然这些内容不难，同时也都是通过IDEA工具生成的，但是过程还是必须得走一遍，那么对于模型类的编写有没有什么优化方法?就是我们接下来要学习的Lombok。\n概念\nLombok，一个Java类库，提供了一组注解，简化POJO实体类开发。\n\n使用步骤步骤1:添加lombok依赖&lt;dependency>\n    &lt;groupId>org.projectlombok&lt;/groupId>\n    &lt;artifactId>lombok&lt;/artifactId>\n    &lt;!--&lt;version>1.18.12&lt;/version>-->\n&lt;/dependency>\n\n注意：版本可以不用写，因为SpringBoot中已经管理了lombok的版本。\n步骤2:安装Lombok的插件&#x3D;&#x3D;新版本IDEA已经内置了该插件，如果删除setter和getter方法程序有报红，则需要安装插件&#x3D;&#x3D;\n\n如果在IDEA中找不到lombok插件，可以访问如下网站\nhttps://plugins.jetbrains.com/plugin/6317-lombok/versions\n根据自己IDEA的版本下载对应的lombok插件，下载成功后，在IDEA中采用离线安装的方式进行安装。\n\n步骤3:模型类上添加注解Lombok常见的注解有:\n\n@Setter:为模型类的属性提供setter方法\n@Getter:为模型类的属性提供getter方法\n@ToString:为模型类的属性提供toString方法\n@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法\n&#x3D;&#x3D;@Data:是个组合注解，包含上面的注解的功能&#x3D;&#x3D;\n&#x3D;&#x3D;@NoArgsConstructor:提供一个无参构造函数&#x3D;&#x3D;\n&#x3D;&#x3D;@AllArgsConstructor:提供一个包含所有参数的构造函数&#x3D;&#x3D;\n\nLombok的注解还有很多，上面标红的三个是比较常用的，其他的大家后期用到了，再去补充学习。\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n说明:\nLombok只是简化模型类的编写，我们之前的方法也能用，比如有人会问:我如果只想要有name和password的构造函数，该如何编写?\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n\n    public User(String name, String password) &#123;\n        this.name = name;\n        this.password = password;\n    &#125;\n&#125;\n\n这种方式是被允许的。\n2.8 分页功能基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。\n分页查询使用的方法是:\nIPage&lt;T> selectPage(IPage&lt;T> page, Wrapper&lt;T> queryWrapper)\n\n\nIPage:用来构建分页查询条件\nWrapper：用来构建条件查询的条件，目前我们没有可直接传为Null\nIPage:返回值，你会发现构建分页条件和方法的返回值都是IPage\n\nIPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为Page。\n步骤1:调用方法传入参数获取返回值@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    //分页查询\n    @Test\n    void testSelectPage()&#123;\n        //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数\n        IPage&lt;User> page=new Page&lt;>(1,3);\n        //2 执行分页查询\n        userDao.selectPage(page,null);\n        //3 获取分页结果\n        System.out.println(\"当前页码值：\"+page.getCurrent());\n        System.out.println(\"每页显示数：\"+page.getSize());\n        System.out.println(\"一共多少页：\"+page.getPages());\n        System.out.println(\"一共多少条数据：\"+page.getTotal());\n        System.out.println(\"数据：\"+page.getRecords());\n    &#125;\n&#125;\n\n步骤2:设置分页拦截器这个拦截器MP已经为我们提供好了，我们只需要将其配置成Spring管理的bean对象即可。\n@Configuration\npublic class MybatisPlusConfig &#123;\n    \n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;\n        //1 创建MybatisPlusInterceptor拦截器对象\n        MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor();\n        //2 添加分页拦截器\n        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return mpInterceptor;\n    &#125;\n&#125;\n\n**说明:**上面的代码记不住咋办呢?\n这些内容在MP的官方文档中有详细的说明，我们可以查看官方文档类配置\n\n步骤3:运行测试程序\n如果想查看MP执行的SQL语句，可以修改application.yml配置文件，\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #打印SQL日志到控制台\n\n打开日志后，就可以在控制台打印出对应的SQL语句，开启日志功能性能就会受到影响，调试完后记得关闭。\n\n3，DQL编程控制增删改查四个操作中，查询是非常重要的也是非常复杂的操作，这块需要我们重点学习下，这节我们主要学习的内容有:\n\n条件查询方式\n查询投影\n查询条件设定\n字段映射与表名映射\n\n3.1 条件查询3.1.1 条件查询的类\nMyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合。\n\n这个我们在前面都有见过，比如查询所有和分页查询的时候，都有看到过一个Wrapper类，这个类就是用来构建查询条件的，如下图所示:\n\n那么条件查询如何使用Wrapper来构建呢?\n3.1.2 环境构建在构建条件查询之前，我们先来准备下环境\n\n创建一个SpringBoot项目\n\npom.xml中添加对应的依赖\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.5.0&lt;/version>\n    &lt;/parent>\n    &lt;groupId>com.itheima&lt;/groupId>\n    &lt;artifactId>mybatisplus_02_dql&lt;/artifactId>\n    &lt;version>0.0.1-SNAPSHOT&lt;/version>\n    &lt;properties>\n        &lt;java.version>1.8&lt;/java.version>\n    &lt;/properties>\n    &lt;dependencies>\n\n        &lt;dependency>\n            &lt;groupId>com.baomidou&lt;/groupId>\n            &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n            &lt;version>3.4.1&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.16&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n        &lt;/dependency>\n\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n\n&lt;/project>\n\n\n编写UserDao接口\n@Mapper\npublic interface UserDao extends BaseMapper&lt;User> &#123;\n&#125;\n\n编写模型类\n@Data\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n编写引导类\n@SpringBootApplication\npublic class Mybatisplus02DqlApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Mybatisplus02DqlApplication.class, args);\n    &#125;\n\n&#125;\n\n编写配置文件\n# dataSource\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC\n    username: root\n    password: root\n# mp日志\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n编写测试类\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        List&lt;User> userList = userDao.selectList(null);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n最终创建的项目结构为:\n\n\n测试的时候，控制台打印的日志比较多，速度有点慢而且不利于查看运行结果，所以接下来我们把这个日志处理下:\n\n取消初始化spring日志打印，resources目录下添加logback.xml，名称固定，内容如下:\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration>\n&lt;/configuration>\n\n**说明:**logback.xml的配置内容，不是我们学习的重点，如果有兴趣可以自行百度查询。\n\n取消MybatisPlus启动banner图标\n\napplication.yml添加如下内容:\n# mybatis-plus日志控制台输出\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n  global-config:\n    banner: off # 关闭mybatisplus启动图标\n\n取消SpringBoot的log打印\n\napplication.yml添加如下内容:\nspring:\n  main:\n    banner-mode: off # 关闭SpringBoot启动图标(banner)\n\n\n\n解决控制台打印日志过多的相关操作可以不用去做，一般会被用来方便我们查看程序运行的结果。\n3.1.3 构建条件查询在进行查询的时候，我们的入口是在Wrapper这个类上，因为它是一个接口，所以我们需要去找它对应的实现类，关于实现类也有很多，说明我们有多种构建查询条件对象的方式，\n\n\n先来看第一种:&#x3D;&#x3D;QueryWrapper&#x3D;&#x3D;\n\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        QueryWrapper qw = new QueryWrapper();\n        qw.lt(\"age\",18);\n        List&lt;User> userList = userDao.selectList(qw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nlt: 小于(&lt;) ,最终的sql语句为\nSELECT id,name,password,age,tel FROM user WHERE (age &lt; ?)\n\n第一种方式介绍完后，有个小问题就是在写条件的时候，容易出错，比如age写错，就会导致查询不成功\n\n接着来看第二种:&#x3D;&#x3D;QueryWrapper的基础上使用lambda&#x3D;&#x3D;\n\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        QueryWrapper&lt;User> qw = new QueryWrapper&lt;User>();\n        qw.lambda().lt(User::getAge, 10);//添加条件\n        List&lt;User> userList = userDao.selectList(qw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nUser::getAget,为lambda表达式中的，类名::方法名，最终的sql语句为:\n\nSELECT id,name,password,age,tel FROM user WHERE (age &lt; ?)\n\n**注意:**构建LambdaQueryWrapper的时候泛型不能省。\n此时我们再次编写条件的时候，就不会存在写错名称的情况，但是qw后面多了一层lambda()调用\n\n接着来看第三种:&#x3D;&#x3D;LambdaQueryWrapper&#x3D;&#x3D;\n\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.lt(User::getAge, 10);\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n这种方式就解决了上一种方式所存在的问题。\n3.1.4 多条件构建学完了三种构建查询对象的方式，每一种都有自己的特点，所以用哪一种都行，刚才都是一个条件，那如果有多个条件该如何构建呢?\n\n\n\n\n\n\n\n\n\n需求:查询数据库表中，年龄在10岁到30岁之间的用户信息\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.lt(User::getAge, 30);\n        lqw.gt(User::getAge, 10);\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\ngt：大于(&gt;),最终的SQL语句为\nSELECT id,name,password,age,tel FROM user WHERE (age &lt; ? AND age > ?)\n\n构建多条件的时候，可以支持链式编程\nLambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\nlqw.lt(User::getAge, 30).gt(User::getAge, 10);\nList&lt;User> userList = userDao.selectList(lqw);\nSystem.out.println(userList);\n\n\n\n\n\n\n\n\n\n\n需求:查询数据库表中，年龄小于10或年龄大于30的数据\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.lt(User::getAge, 10).or().gt(User::getAge, 30);\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nor()就相当于我们sql语句中的or关键字,不加默认是and，最终的sql语句为:\nSELECT id,name,password,age,tel FROM user WHERE (age &lt; ? OR age > ?)\n\n3.1.5 null判定先来看一张图，\n\n\n我们在做条件查询的时候，一般会有很多条件可以供用户进行选择查询。\n这些条件用户可以选择使用也可以选择不使用，比如我要查询价格在8000以上的手机\n在输入条件的时候，价格有一个区间范围，按照需求只需要在第一个价格输入框中输入8000\n后台在做价格查询的时候，一般会让 price&gt;值1 and price &lt;值2\n因为前端没有输入值2，所以如果不处理的话，就会出现 price&gt;8000 and price &lt; null问题\n这个时候查询的结果就会出问题，具体该如何解决?\n\n\n\n\n\n\n\n\n\n\n\n需求:查询数据库表中，根据输入年龄范围来查询符合条件的记录\n用户在输入值的时候，\n​\t如果只输入第一个框，说明要查询大于该年龄的用户\n​\t如果只输入第二个框，说明要查询小于该年龄的用户\n​    如果两个框都输入了，说明要查询年龄在两个范围之间的用户\n思考第一个问题：后台如果想接收前端的两个数据，该如何接收?\n我们可以使用两个简单数据类型，也可以使用一个模型类，但是User类中目前只有一个age属性,如:\n@Data\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n使用一个age属性，如何去接收页面上的两个值呢?这个时候我们有两个解决方案\n方案一:添加属性age2,这种做法可以但是会影响到原模型类的属性内容\n@Data\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n    private Integer age2;\n&#125;\n\n方案二:新建一个模型类,让其继承User类，并在其中添加age2属性，UserQuery在拥有User属性后同时添加了age2属性。\n@Data\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n@Data\npublic class UserQuery extends User &#123;\n    private Integer age2;\n&#125;\n\n环境准备好后，我们来实现下刚才的需求：\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        //模拟页面传递过来的查询数据\n        UserQuery uq = new UserQuery();\n        uq.setAge(10);\n        uq.setAge2(30);\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        if(null != uq.getAge2())&#123;\n            lqw.lt(User::getAge, uq.getAge2());\n        &#125;\n        if( null != uq.getAge()) &#123;\n            lqw.gt(User::getAge, uq.getAge());\n        &#125;\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n上面的写法可以完成条件为非空的判断，但是问题很明显，如果条件多的话，每个条件都需要判断，代码量就比较大，来看MP给我们提供的简化方式：\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        //模拟页面传递过来的查询数据\n        UserQuery uq = new UserQuery();\n        uq.setAge(10);\n        uq.setAge2(30);\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.lt(null!=uq.getAge2(),User::getAge, uq.getAge2());\n        lqw.gt(null!=uq.getAge(),User::getAge, uq.getAge());\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nlt()方法\n\ncondition为boolean类型，返回true，则添加条件，返回false则不添加条件\n\n\n3.2 查询投影3.2.1 查询指定字段目前我们在查询数据的时候，什么都没有做默认就是查询表中所有字段的内容，我们所说的查询投影即不查询所有字段，只查询出指定内容的数据。\n具体如何来实现?\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.select(User::getId,User::getName,User::getAge);\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nselect(…)方法用来设置查询的字段列，可以设置多个，最终的sql语句为:\nSELECT id,name,age FROM user\n\n如果使用的不是lambda，就需要手动指定字段\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        QueryWrapper&lt;User> lqw = new QueryWrapper&lt;User>();\n        lqw.select(\"id\",\"name\",\"age\",\"tel\");\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\n最终的sql语句为:SELECT id,name,age,tel FROM user\n\n\n\n3.2.2 聚合查询\n\n\n\n\n\n\n\n\n需求:聚合函数查询，完成count、max、min、avg、sum的使用\ncount:总记录数\nmax:最大值\nmin:最小值\navg:平均值\nsum:求和\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        QueryWrapper&lt;User> lqw = new QueryWrapper&lt;User>();\n        //lqw.select(\"count(*) as count\");\n        //SELECT count(*) as count FROM user\n        //lqw.select(\"max(age) as maxAge\");\n        //SELECT max(age) as maxAge FROM user\n        //lqw.select(\"min(age) as minAge\");\n        //SELECT min(age) as minAge FROM user\n        //lqw.select(\"sum(age) as sumAge\");\n        //SELECT sum(age) as sumAge FROM user\n        lqw.select(\"avg(age) as avgAge\");\n        //SELECT avg(age) as avgAge FROM user\n        List&lt;Map&lt;String, Object>> userList = userDao.selectMaps(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n为了在做结果封装的时候能够更简单，我们将上面的聚合函数都起了个名称，方面后期来获取这些数据\n3.2.3 分组查询\n\n\n\n\n\n\n\n\n需求:分组查询，完成 group by的查询使用\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        QueryWrapper&lt;User> lqw = new QueryWrapper&lt;User>();\n        lqw.select(\"count(*) as count,tel\");\n        lqw.groupBy(\"tel\");\n        List&lt;Map&lt;String, Object>> list = userDao.selectMaps(lqw);\n        System.out.println(list);\n    &#125;\n&#125;\n\n\ngroupBy为分组，最终的sql语句为\nSELECT count(*) as count,tel FROM user GROUP BY tel\n\n注意:\n\n聚合与分组查询，无法使用lambda表达式来完成\nMP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现\n\n3.3 查询条件前面我们只使用了lt()和gt(),除了这两个方法外，MP还封装了很多条件对应的方法，这一节我们重点把MP提供的查询条件方法进行学习下。\nMP的查询条件有很多:\n\n范围匹配（&gt; 、 &#x3D; 、between）\n模糊匹配（like）\n空判定（null）\n包含性匹配（in）\n分组（group）\n排序（order）\n……\n\n3.3.1 等值查询\n\n\n\n\n\n\n\n\n需求:根据用户名和密码查询用户信息\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.eq(User::getName, \"Jerry\").eq(User::getPassword, \"jerry\");\n        User loginUser = userDao.selectOne(lqw);\n        System.out.println(loginUser);\n    &#125;\n&#125;\n\n\neq()： 相当于 =,对应的sql语句为\nSELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?)\n\nselectList：查询结果为多个或者单个\n\nselectOne:查询结果为单个\n\n\n3.3.2 范围查询\n\n\n\n\n\n\n\n\n需求:对年龄进行范围查询，使用lt()、le()、gt()、ge()、between()进行范围查询\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.between(User::getAge, 10, 30);\n        //SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\ngt():大于(&gt;)\nge():大于等于(&gt;&#x3D;)\nlt():小于(&lt;)\nlte():小于等于(&lt;&#x3D;)\nbetween():between ? and ?\n\n3.3.3 模糊查询\n\n\n\n\n\n\n\n\n需求:查询表中name属性的值以J开头的用户信息,使用like进行模糊查询\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lqw = new LambdaQueryWrapper&lt;User>();\n        lqw.likeLeft(User::getName, \"J\");\n        //SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?)\n        List&lt;User> userList = userDao.selectList(lqw);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n\nlike():前后加百分号,如 %J%\nlikeLeft():前面加百分号,如 %J\nlikeRight():后面加百分号,如 J%\n\n3.3.4 排序查询\n\n\n\n\n\n\n\n\n需求:查询所有数据，然后按照id降序\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        LambdaQueryWrapper&lt;User> lwq = new LambdaQueryWrapper&lt;>();\n        /**\n         * condition ：条件，返回boolean，\n         \t\t当condition为true，进行排序，如果为false，则不排序\n         * isAsc:是否为升序，true为升序，false为降序\n         * columns：需要操作的列\n         */\n        lwq.orderBy(true,false, User::getId);\n\n        userDao.selectList(lw\n    &#125;\n&#125;\n\n除了上面演示的这种实现方式，还有很多其他的排序方法可以被调用，如图:\n\n\norderBy排序\ncondition:条件，true则添加排序，false则不添加排序\nisAsc:是否为升序，true升序，false降序\ncolumns:排序字段，可以有多个\n\n\norderByAsc&#x2F;Desc(单个column):按照指定字段进行升序&#x2F;降序\norderByAsc&#x2F;Desc(多个column):按照多个字段进行升序&#x2F;降序\norderByAsc&#x2F;Desc\ncondition:条件，true添加排序，false不添加排序\n多个columns：按照多个字段进行排序\n\n\n\n除了上面介绍的这几种查询条件构建方法以外还会有很多其他的方法，比如isNull,isNotNull,in,notIn等等方法可供选择，具体参考官方文档的条件构造器来学习使用，具体的网址为:\nhttps://mp.baomidou.com/guide/wrapper.html#abstractwrapper\n3.4 映射匹配兼容性前面我们已经能从表中查询出数据，并将数据封装到模型类中，这整个过程涉及到一张表和一个模型类:\n\n之所以数据能够成功的从表中获取并封装到模型对象中，原因是表的字段列名和模型类的属性名一样。\n那么问题就来了:\n问题1:表字段与编码属性设计不同步当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象，这个时候就需要其中一方做出修改，那如果前提是两边都不能改又该如何解决?\nMP给我们提供了一个注解@TableField,使用该注解可以实现模型类属性名和表的列名之间的映射关系\n\n问题2:编码中添加了数据库中未定义的属性当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:\n&#x3D;&#x3D;Unknown column ‘多出来的字段名称’ in ‘field list’&#x3D;&#x3D;\n具体的解决方案用到的还是@TableField注解，它有一个属性叫exist，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。\n\n问题3：采用默认查询开放了更多的字段查看权限查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要限制哪些字段默认不要进行查询。解决方案是@TableField注解的一个属性叫select，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。\n\n知识点1：@TableField\n\n\n名称\n@TableField\n\n\n\n类型\n&#x3D;&#x3D;属性注解&#x3D;&#x3D;\n\n\n位置\n模型类属性定义上方\n\n\n作用\n设置当前属性对应的数据库表中的字段关系\n\n\n相关属性\nvalue(默认)：设置数据库表字段名称exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用select:设置属性是否参与查询，此属性与select()映射配置不冲突\n\n\n问题4:表名与编码开发设计不同步该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:\n&#x3D;&#x3D;Table ‘databaseName.tableNaem’ doesn’t exist&#x3D;&#x3D;,翻译过来就是数据库中的表不存在。\n\n解决方案是使用MP提供的另外一个注解@TableName来设置表与模型类之间的对应关系。\n\n知识点2：@TableName\n\n\n名称\n@TableName\n\n\n\n类型\n&#x3D;&#x3D;类注解&#x3D;&#x3D;\n\n\n位置\n模型类定义上方\n\n\n作用\n设置当前类对应于数据库表关系\n\n\n相关属性\nvalue(默认)：设置数据库表名称\n\n\n代码演示接下来我们使用案例的方式把刚才的知识演示下:\n步骤1:修改数据库表user为tbl_user直接查询会报错，原因是MP默认情况下会使用模型类的类名首字母小写当表名使用。\n\n步骤2:模型类添加@TableName注解@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n步骤3:将字段password修改成pwd直接查询会报错，原因是MP默认情况下会使用模型类的属性名当做表的列名使用\n\n步骤4：使用@TableField映射关系@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\")\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n步骤5:添加一个数据库表不存在的字段@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\")\n    private String password;\n    private Integer age;\n    private String tel;\n    private Integer online;\n&#125;\n\n直接查询会报错，原因是MP默认情况下会查询模型类的所有属性对应的数据库表的列，而online不存在\n\n步骤6：使用@TableField排除字段@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\")\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n步骤7:查询时将pwd隐藏@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n4，DML编程控制查询相关的操作我们已经介绍完了，紧接着我们需要对另外三个，增删改进行内容的讲解。挨个来说明下，首先是新增(insert)中的内容。\n4.1 id生成策略控制前面我们在新增的时候留了一个问题，就是新增成功后，主键ID是一个很长串的内容，我们更想要的是按照数据库表字段进行自增长，在解决这个问题之前，我们先来分析下ID该如何选择:\n\n不同的表应用不同的id生成策略\n日志：自增（1,2,3,4，……）\n购物订单：特殊规则（FQ23948AK3843）\n外卖单：关联地区日期等信息（10 04 20200314 34 91）\n关系表：可省略id\n……\n\n\n\n不同的业务采用的ID生成方式应该是不一样的，那么在MP中都提供了哪些主键生成策略，以及我们该如何进行选择?\n在这里我们又需要用到MP的一个注解叫@TableId\n知识点1：@TableId\n\n\n名称\n@TableId\n\n\n\n类型\n&#x3D;&#x3D;属性注解&#x3D;&#x3D;\n\n\n位置\n模型类中用于表示主键的属性定义上方\n\n\n作用\n设置当前类中主键属性的生成策略\n\n\n相关属性\nvalue(默认)：设置数据库表主键名称type:设置主键属性的生成策略，值查照IdType的枚举值\n\n\n4.1.1 环境构建在构建条件查询之前，我们先来准备下环境\n\n创建一个SpringBoot项目\n\npom.xml中添加对应的依赖\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.5.0&lt;/version>\n        &lt;relativePath/> &lt;!-- lookup parent from repository -->\n    &lt;/parent>\n    &lt;groupId>com.itheima&lt;/groupId>\n    &lt;artifactId>mybatisplus_03_dml&lt;/artifactId>\n    &lt;version>0.0.1-SNAPSHOT&lt;/version>\n    &lt;properties>\n        &lt;java.version>1.8&lt;/java.version>\n    &lt;/properties>\n    &lt;dependencies>\n\n        &lt;dependency>\n            &lt;groupId>com.baomidou&lt;/groupId>\n            &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n            &lt;version>3.4.1&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.16&lt;/version>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.12&lt;/version>\n        &lt;/dependency>\n\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n\n&lt;/project>\n\n\n编写UserDao接口\n@Mapper\npublic interface UserDao extends BaseMapper&lt;User> &#123;\n&#125;\n\n编写模型类\n@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n编写引导类\n@SpringBootApplication\npublic class Mybatisplus03DqlApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Mybatisplus03DqlApplication.class, args);\n    &#125;\n\n&#125;\n\n编写配置文件\n# dataSource\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC\n    username: root\n    password: root\n# mp日志\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n编写测试类\n@SpringBootTest\nclass Mybatisplus02DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll()&#123;\n        List&lt;User> userList = userDao.selectList(null);\n        System.out.println(userList);\n    &#125;\n&#125;\n\n测试\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testSave()&#123;\n        User user = new User();\n        user.setName(\"黑马程序员\");\n        user.setPassword(\"itheima\");\n        user.setAge(12);\n        user.setTel(\"4006184000\");\n        userDao.insert(user);\n    &#125;\n    @Test\n    void testDelete()&#123;\n        userDao.deleteById(1401856123925713409L)\n    &#125;\n    @Test\n    void testUpdate()&#123;\n        User user = new User();\n        user.setId(3L);\n        user.setName(\"Jock666\");\n        user.setVersion(1);\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n最终创建的项目结构为:\n\n\n\n4.1.2 代码演示AUTO策略步骤1:设置生成策略为AUTO@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    @TableId(type = IdType.AUTO)\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n步骤2:删除测试数据并修改自增值\n删除测试数据\n\n\n因为之前生成主键ID的值比较长，会把MySQL的自动增长的值变的很大，所以需要将其调整为目前最新的id值。\n\n\n\n步骤3:运行新增方法会发现，新增成功，并且主键id也是从5开始\n\n经过这三步的演示，会发现AUTO的作用是&#x3D;&#x3D;使用数据库ID自增&#x3D;&#x3D;，在使用该策略的时候一定要确保对应的数据库表设置了ID主键自增，否则无效。\n接下来，我们可以进入源码查看下ID的生成策略有哪些?\n打开源码后，你会发现并没有看到中文注释，这就需要我们点击右上角的Download Sources,会自动帮你把这个类的java文件下载下来，我们就能看到具体的注释内容。因为这个技术是国人制作的，所以他代码中的注释还是比较容易看懂的。\n\n当把源码下载完后，就可以看到如下内容:\n\n从源码中可以看到，除了AUTO这个策略以外，还有如下几种生成策略:\n\nNONE: 不设置id生成策略\nINPUT:用户手工输入id\nASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)\nASSIGN_UUID:以UUID生成算法作为id生成策略\n其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。\n\n拓展:\n分布式ID是什么?\n\n当数据量足够大的时候，一台数据库服务器存储不下，这个时候就需要多台数据库服务器进行存储\n比如订单表就有可能被存储在不同的服务器上\n如果用数据库表的自增主键，因为在两台服务器上所以会出现冲突\n这个时候就需要一个全局唯一ID,这个ID就是分布式ID。\n\nINPUT策略步骤1:设置生成策略为INPUT@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    @TableId(type = IdType.INPUT)\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n**注意:**这种ID生成策略，需要将表的自增策略删除掉\n\n步骤2:添加数据手动设置ID@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testSave()&#123;\n        User user = new User();\n        //设置主键ID的值\n        user.setId(666L);\n        user.setName(\"黑马程序员\");\n        user.setPassword(\"itheima\");\n        user.setAge(12);\n        user.setTel(\"4006184000\");\n        userDao.insert(user);\n    &#125;\n&#125;\n\n步骤3:运行新增方法如果没有设置主键ID的值，则会报错，错误提示就是主键ID没有给值:\n\n如果设置了主键ID,则数据添加成功，如下:\n\nASSIGN_ID策略步骤1:设置生成策略为ASSIGN_ID@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    @TableId(type = IdType.ASSIGN_ID)\n    private Long id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n步骤2:添加数据不设置ID@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testSave()&#123;\n        User user = new User();\n        user.setName(\"黑马程序员\");\n        user.setPassword(\"itheima\");\n        user.setAge(12);\n        user.setTel(\"4006184000\");\n        userDao.insert(user);\n    &#125;\n&#125;\n\n**注意:**这种生成策略，不需要手动设置ID，如果手动设置ID，则会使用自己设置的值。\n步骤3:运行新增方法\n生成的ID就是一个Long类型的数据。\nASSIGN_UUID策略步骤1:设置生成策略为ASSIGN_UUID使用uuid需要注意的是，主键的类型不能是Long，而应该改成String类型\n@Data\n@TableName(\"tbl_user\")\npublic class User &#123;\n    @TableId(type = IdType.ASSIGN_UUID)\n    private String id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n&#125;\n\n步骤2:修改表的主键类型\n主键类型设置为varchar，长度要大于32，因为UUID生成的主键为32位，如果长度小的话就会导致插入失败。\n步骤3:添加数据不设置ID@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testSave()&#123;\n        User user = new User();\n        user.setName(\"黑马程序员\");\n        user.setPassword(\"itheima\");\n        user.setAge(12);\n        user.setTel(\"4006184000\");\n        userDao.insert(user);\n    &#125;\n&#125;\n\n步骤4:运行新增方法\n接下来我们来聊一聊雪花算法:\n雪花算法(SnowFlake),是Twitter官方给出的算法实现 是用Scala写的。其生成的结果是一个64bit大小整数，它的结构如下图:\n\n\n1bit,不用,因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。\n41bit-时间戳，用来记录时间戳，毫秒级\n10bit-工作机器id，用来记录工作机器id,其中高位5bit是数据中心ID其取值范围0-31，低位5bit是工作节点ID其取值范围0-31，两个组合起来最多可以容纳1024个节点\n序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID\n\n4.1.3 ID生成策略对比介绍了这些主键ID的生成策略，我们以后该用哪个呢?\n\nNONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂\nAUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用\nASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢\nASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键\n综上所述，每一种主键策略都有自己的优缺点，根据自己项目业务的实际情况来选择使用才是最明智的选择。\n\n4.1.4 简化配置前面我们已经完成了表关系映射、数据库主键策略的设置，接下来对于这两个内容的使用，我们再讲下他们的简化配置:\n模型类主键策略设置对于主键ID的策略已经介绍完，但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，如:\n确实是稍微有点繁琐，我们能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?\n答案是肯定有，我们只需要在配置文件中添加如下内容:\nmybatis-plus:\n  global-config:\n    db-config:\n    \tid-type: assign_id\n\n配置完成后，每个模型类的主键ID策略都将成为assign_id.\n数据库表与模型类的映射关系MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以tbl_开头，那么我们就需要将所有的模型类上添加@TableName，如:\n\n配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:\nmybatis-plus:\n  global-config:\n    db-config:\n    \ttable-prefix: tbl_\n\n设置表的前缀内容，这样MP就会拿 tbl_加上模型类的首字母小写，就刚好组装成数据库的表名。\n4.2 多记录操作先来看下问题:\n\n之前添加了很多商品到购物车，过了几天发现这些东西又不想要了，该怎么办呢?\n很简单删除掉，但是一个个删除的话还是比较慢和费事的，所以一般会给用户一个批量操作，也就是前面有一个复选框，用户一次可以勾选多个也可以进行全选，然后删一次就可以将购物车清空，这个就需要用到批量删除的操作了。\n具体该如何实现多条删除，我们找找对应的API方法\nint deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable> idList);\n\n翻译方法的字面意思为:删除（根据ID 批量删除）,参数是一个集合，可以存放多个id值。\n\n\n\n\n\n\n\n\n\n需求:根据传入的id集合将数据库表中的数据删除掉。\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testDelete()&#123;\n        //删除指定多条数据\n        List&lt;Long> list = new ArrayList&lt;>();\n        list.add(1402551342481838081L);\n        list.add(1402553134049501186L);\n        list.add(1402553619611430913L);\n        userDao.deleteBatchIds(list);\n    &#125;\n&#125;\n\n执行成功后，数据库表中的数据就会按照指定的id进行删除。\n除了按照id集合进行批量删除，也可以按照id集合进行批量查询，还是先来看下API\nList&lt;T> selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable> idList);\n\n方法名称翻译为:查询（根据ID 批量查询），参数是一个集合，可以存放多个id值。\n\n\n\n\n\n\n\n\n\n需求：根据传入的ID集合查询用户信息\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testGetByIds()&#123;\n        //查询指定多条数据\n        List&lt;Long> list = new ArrayList&lt;>();\n        list.add(1L);\n        list.add(3L);\n        list.add(4L);\n        userDao.selectBatchIds(list);\n    &#125;\n&#125;\n\n查询结果就会按照指定传入的id值进行查询\n\n4.3 逻辑删除接下来要讲解是删除中比较重要的一个操作，逻辑删除，先来分析下问题:\n\n\n这是一个员工和其所签的合同表，关系是一个员工可以签多个合同，是一个一(员工)对多(合同)的表\n\n员工ID为1的张业绩，总共签了三个合同，如果此时他离职了，我们需要将员工表中的数据进行删除，会执行delete操作\n\n如果表在设计的时候有主外键关系，那么同时也得将合同表中的前三条数据也删除掉\n\n\n后期要统计所签合同的总金额，就会发现对不上，原因是已经将员工1签的合同信息删除掉了\n\n如果只删除员工不删除合同表数据，那么合同的员工编号对应的员工信息不存在，那么就会出现垃圾数据，就会出现无主合同，根本不知道有张业绩这个人的存在\n\n所以经过分析，我们不应该将表中的数据删除掉，而是需要进行保留，但是又得把离职的人和在职的人进行区分，这样就解决了上述问题，如:\n\n\n区分的方式，就是在员工表中添加一列数据deleted，如果为0说明在职员工，如果离职则将其改完1，（0和1所代表的含义是可以自定义的）\n\n\n所以对于删除操作业务问题来说有:\n\n物理删除:业务数据从数据库中丢弃，执行的是delete操作\n逻辑删除:为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中，执行的是update操作\n\nMP中逻辑删除具体该如何实现?\n步骤1:修改数据库表添加deleted列字段名可以任意，内容也可以自定义，比如0代表正常，1代表删除，可以在添加列的同时设置其默认值为0正常。\n\n步骤2:实体类添加属性(1)添加与数据库表的列对应的一个属性名，名称可以任意，如果和数据表列名对不上，可以使用@TableField进行关系映射，如果一致，则会自动对应。\n(2)标识新增的字段为逻辑删除字段，使用@TableLogic\n@Data\n//@TableName(\"tbl_user\") 可以不写是因为配置了全局配置\npublic class User &#123;\n    @TableId(type = IdType.ASSIGN_UUID)\n    private String id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n    @TableLogic(value=\"0\",delval=\"1\")\n    //value为正常数据的值，delval为删除数据的值\n    private Integer deleted;\n&#125;\n\n步骤3:运行删除方法@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testDelete()&#123;\n       userDao.deleteById(1L);\n    &#125;\n&#125;\n\n\n从测试结果来看，逻辑删除最后走的是update操作，会将指定的字段修改成删除状态对应的值。\n思考\n逻辑删除，对查询有没有影响呢?\n\n执行查询操作\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testFind()&#123;\n       System.out.println(userDao.selectList(null));\n    &#125;\n&#125;\n\n运行测试，会发现打印出来的sql语句中会多一个查询条件，如:\n\n可想而知，MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。\n\n如果还是想把已经删除的数据都查询出来该如何实现呢?\n@Mapper\npublic interface UserDao extends BaseMapper&lt;User> &#123;\n    //查询所有数据包含已经被删除的数据\n    @Select(\"select * from tbl_user\")\n    public List&lt;User> selectAll();\n&#125;\n\n如果每个表都要有逻辑删除，那么就需要在每个模型类的属性上添加@TableLogic注解，如何优化?\n在配置文件中添加全局配置，如下:\nmybatis-plus:\n  global-config:\n    db-config:\n      # 逻辑删除字段名\n      logic-delete-field: deleted\n      # 逻辑删除字面值：未删除为0\n      logic-not-delete-value: 0\n      # 逻辑删除字面值：删除为1\n      logic-delete-value: 1\n\n介绍完逻辑删除，逻辑删除的本质为:\n逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。\n执行的SQL语句为:\nUPDATE tbl_user SET &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;1 where id &#x3D; ? AND &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;0\n执行数据结果为:\n\n知识点1：@TableLogic\n\n\n名称\n@TableLogic\n\n\n\n类型\n&#x3D;&#x3D;属性注解&#x3D;&#x3D;\n\n\n位置\n模型类中用于表示删除字段的属性定义上方\n\n\n作用\n标识该字段为进行逻辑删除的字段\n\n\n相关属性\nvalue：逻辑未删除值delval:逻辑删除值\n\n\n4.4 乐观锁4.4.1 概念在讲解乐观锁之前，我们还是先来分析下问题:\n业务并发现象带来的问题:&#x3D;&#x3D;秒杀&#x3D;&#x3D;\n\n假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖\n对于这一类问题，其实有很多的解决方案可以使用\n第一个最先想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题\n我们接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。\n\n简单来说，乐观锁主要解决的问题是当要更新一条记录的时候，希望这条记录没有被别人更新。\n4.4.2 实现思路乐观锁的实现方式:\n\n\n\n\n\n\n\n\n\n\n数据库表中添加version列，比如默认值给1\n第一个线程要修改数据之前，取出记录时，获取当前数据库中的version&#x3D;1\n第二个线程要修改数据之前，取出记录时，获取当前数据库中的version&#x3D;1\n第一个线程执行更新时，set version &#x3D; newVersion where version &#x3D; oldVersion\nnewVersion &#x3D; version+1  [2]\noldVersion &#x3D; version  [1]\n\n\n第二个线程执行更新时，set version &#x3D; newVersion where version &#x3D; oldVersion\nnewVersion &#x3D; version+1  [2]\noldVersion &#x3D; version  [1]\n\n\n假如这两个线程都来更新数据，第一个和第二个线程都可能先执行\n假如第一个线程先执行更新，会把version改为2，\n第二个线程再更新的时候，set version &#x3D; 2 where version &#x3D; 1,此时数据库表的数据version已经为2，所以第二个线程会修改失败\n假如第二个线程先执行更新，会把version改为2，\n第一个线程再更新的时候，set version &#x3D; 2 where version &#x3D; 1,此时数据库表的数据version已经为2，所以第一个线程会修改失败\n不管谁先执行都会确保只能有一个线程更新数据，这就是MP提供的乐观锁的实现原理分析。\n\n\n\n上面所说的步骤具体该如何实现呢?\n4.4.3 实现步骤分析完步骤后，具体的实现步骤如下:\n步骤1:数据库表添加列列名可以任意，比如使用version,给列设置默认值为1\n\n步骤2:在模型类中添加对应的属性根据添加的字段列名，在模型类中添加对应的属性值\n@Data\n//@TableName(\"tbl_user\") 可以不写是因为配置了全局配置\npublic class User &#123;\n    @TableId(type = IdType.ASSIGN_UUID)\n    private String id;\n    private String name;\n    @TableField(value=\"pwd\",select=false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist=false)\n    private Integer online;\n    private Integer deleted;\n    @Version\n    private Integer version;\n&#125;\n\n步骤3:添加乐观锁的拦截器@Configuration\npublic class MpConfig &#123;\n    @Bean\n    public MybatisPlusInterceptor mpInterceptor() &#123;\n        //1.定义Mp拦截器\n        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();\n        //2.添加乐观锁拦截器\n        mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n        return mpInterceptor;\n    &#125;\n&#125;\n\n步骤4:执行更新操作@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testUpdate()&#123;\n       User user = new User();\n        user.setId(3L);\n        user.setName(\"Jock666\");\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n\n你会发现，这次修改并没有更新version字段，原因是没有携带version数据。\n添加version数据\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testUpdate()&#123;\n        User user = new User();\n        user.setId(3L);\n        user.setName(\"Jock666\");\n        user.setVersion(1);\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n\n你会发现，我们传递的是1，MP会将1进行加1，然后，更新回到数据库表中。\n所以要想实现乐观锁，首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中，所以我们在查询的时候，需要对其进行查询\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testUpdate()&#123;\n        //1.先通过要修改的数据id将当前数据查询出来\n        User user = userDao.selectById(3L);\n        //2.将要修改的属性逐一设置进去\n        user.setName(\"Jock888\");\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n\n大概分析完乐观锁的实现步骤以后，我们来模拟一种加锁的情况，看看能不能实现多个人修改同一个数据的时候，只能有一个人修改成功。\n@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testUpdate()&#123;\n       //1.先通过要修改的数据id将当前数据查询出来\n        User user = userDao.selectById(3L);     //version=3\n        User user2 = userDao.selectById(3L);    //version=3\n        user2.setName(\"Jock aaa\");\n        userDao.updateById(user2);              //version=>4\n        user.setName(\"Jock bbb\");\n        userDao.updateById(user);               //verion=3?条件还成立吗？\n    &#125;\n&#125;\n\n运行程序，分析结果：\n\n乐观锁就已经实现完成了，如果对于上面的这些步骤记不住咋办呢?\n参考官方文档来实现:\nhttps://mp.baomidou.com/guide/interceptor-optimistic-locker.html#optimisticlockerinnerinterceptor\n\n5，快速开发5.1 代码生成器原理分析造句:\n我们可以往空白内容进行填词造句，比如:\n在比如:\n观察我们之前写的代码，会发现其中也会有很多重复内容，比如:\n\n那我们就想，如果我想做一个Book模块的开发，是不是只需要将红色部分的内容全部更换成Book即可，如：\n\n所以我们会发现，做任何模块的开发，对于这段代码，基本上都是对红色部分的调整，所以我们把去掉红色内容的东西称之为&#x3D;&#x3D;模板&#x3D;&#x3D;，红色部分称之为&#x3D;&#x3D;参数&#x3D;&#x3D;，以后只需要传入不同的参数，就可以根据模板创建出不同模块的dao代码。\n除了Dao可以抽取模块，其实我们常见的类都可以进行抽取，只要他们有公共部分即可。再来看下模型类的模板：\n\n\n① 可以根据数据库表的表名来填充\n② 可以根据用户的配置来生成ID生成策略\n③到⑨可以根据数据库表字段名称来填充\n\n所以只要我们知道是对哪张表进行代码生成，这些内容我们都可以进行填充。\n分析完后，我们会发现，要想完成代码自动生成，我们需要有以下内容:\n\n模板: MyBatisPlus提供，可以自己提供，但是麻烦，不建议\n数据库相关配置:读取数据库获取表和字段信息\n开发者自定义配置:手工配置，比如ID生成策略\n\n5.2 代码生成器实现步骤1:创建一个Maven项目代码2:导入对应的jar包&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.5.1&lt;/version>\n    &lt;/parent>\n    &lt;groupId>com.itheima&lt;/groupId>\n    &lt;artifactId>mybatisplus_04_generator&lt;/artifactId>\n    &lt;version>0.0.1-SNAPSHOT&lt;/version>\n    &lt;properties>\n        &lt;java.version>1.8&lt;/java.version>\n    &lt;/properties>\n    &lt;dependencies>\n        &lt;!--spring webmvc-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;!--mybatisplus-->\n        &lt;dependency>\n            &lt;groupId>com.baomidou&lt;/groupId>\n            &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n            &lt;version>3.4.1&lt;/version>\n        &lt;/dependency>\n\n        &lt;!--druid-->\n        &lt;dependency>\n            &lt;groupId>com.alibaba&lt;/groupId>\n            &lt;artifactId>druid&lt;/artifactId>\n            &lt;version>1.1.16&lt;/version>\n        &lt;/dependency>\n\n        &lt;!--mysql-->\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n        &lt;/dependency>\n\n        &lt;!--test-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n\n        &lt;!--lombok-->\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.12&lt;/version>\n        &lt;/dependency>\n\n        &lt;!--代码生成器-->\n        &lt;dependency>\n            &lt;groupId>com.baomidou&lt;/groupId>\n            &lt;artifactId>mybatis-plus-generator&lt;/artifactId>\n            &lt;version>3.4.1&lt;/version>\n        &lt;/dependency>\n\n        &lt;!--velocity模板引擎-->\n        &lt;dependency>\n            &lt;groupId>org.apache.velocity&lt;/groupId>\n            &lt;artifactId>velocity-engine-core&lt;/artifactId>\n            &lt;version>2.3&lt;/version>\n        &lt;/dependency>\n\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n\n&lt;/project>\n\n\n步骤3:编写引导类@SpringBootApplication\npublic class Mybatisplus04GeneratorApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Mybatisplus04GeneratorApplication.class, args);\n    &#125;\n\n&#125;\n\n步骤4:创建代码生成类public class CodeGenerator &#123;\n    public static void main(String[] args) &#123;\n        //1.获取代码生成器的对象\n        AutoGenerator autoGenerator = new AutoGenerator();\n\n        //设置数据库相关配置\n        DataSourceConfig dataSource = new DataSourceConfig();\n        dataSource.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/\"数据库\"?serverTimezone=UTC\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n        autoGenerator.setDataSource(dataSource);\n\n        //设置全局配置\n        GlobalConfig globalConfig = new GlobalConfig();\n        globalConfig.setOutputDir(System.getProperty(\"user.dir\")+\"/src/main/java\");    //设置代码生成位置\n        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录\n        globalConfig.setAuthor(\"wzh\");    //设置作者\n        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件\n        globalConfig.setMapperName(\"%sDao\");    //设置数据层接口名，%s为占位符，指代模块名称\n        globalConfig.setMapperName(\"%sService\");    //设置服务层接口名，%s为占位符，指代模块名称\n        globalConfig.setMapperName(\"%sController\");    //设置控制层接口名，%s为占位符，指代模块名称\n        globalConfig.setIdType(IdType.ASSIGN_ID);   //设置Id生成策略\n        autoGenerator.setGlobalConfig(globalConfig);\n\n        //设置包名相关配置\n        PackageConfig packageInfo = new PackageConfig();\n        packageInfo.setParent(\"com.wzh.system\");   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径\n        packageInfo.setEntity(\"domain\");    //设置实体类包名\n        packageInfo.setMapper(\"dao\");   //设置数据层包名\n        packageInfo.setMapper(\"service\");   //设置服务层包名\n        packageInfo.setMapper(\"controller\");   //设置控制层包名\n        autoGenerator.setPackageInfo(packageInfo);\n\n        //策略设置\n        StrategyConfig strategyConfig = new StrategyConfig();\n        strategyConfig.setInclude(\"参与的数据库表名\");  //设置当前参与生成的表名，参数为可变参数\n        strategyConfig.setTablePrefix(\"tbl_\");  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_\n        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格\n        strategyConfig.setVersionFieldName(\"version\");  //设置乐观锁字段名\n        strategyConfig.setLogicDeleteFieldName(\"deleted\");  //设置逻辑删除字段名\n        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok\n        autoGenerator.setStrategy(strategyConfig);\n        //2.执行生成操作\n        autoGenerator.execute();\n    &#125;\n&#125;\n\n对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改，\nhttps://mp.baomidou.com/guide/generator.html\n步骤5:运行程序运行成功后，会在当前项目中生成很多代码，代码包含controller,service，mapper和entity\n\n至此代码生成器就已经完成工作，我们能快速根据数据库表来创建对应的类，简化我们的代码开发。\n5.3 MP中Service的CRUD回顾我们之前业务层代码的编写，编写接口和对应的实现类:\npublic interface UserService&#123;\n\t\n&#125;\n\n@Service\npublic class UserServiceImpl implements UserService&#123;\n\n&#125;\n\n接口和实现类有了以后，需要在接口和实现类中声明方法\npublic interface UserService&#123;\n\tpublic List&lt;User> findAll();\n&#125;\n\n@Service\npublic class UserServiceImpl implements UserService&#123;\n    @Autowired\n    private UserDao userDao;\n    \n\tpublic List&lt;User> findAll()&#123;\n        return userDao.selectList(null);\n    &#125;\n&#125;\n\nMP看到上面的代码以后就说这些方法也是比较固定和通用的，那我来帮你抽取下，所以MP提供了一个Service接口和实现类，分别是:IService和ServiceImpl,后者是对前者的一个具体实现。\n以后我们自己写的Service就可以进行如下修改:\npublic interface UserService extends IService&lt;User>&#123;\n\t\n&#125;\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserDao, User> implements UserService&#123;\n\n&#125;\n\n修改以后的好处是，MP已经帮我们把业务层的一些基础的增删改查都已经实现了，可以直接进行使用。\n编写测试类进行测试:\n@SpringBootTest\nclass Mybatisplus04GeneratorApplicationTests &#123;\n\n    private IUserService userService;\n\n    @Test\n    void testFindAll() &#123;\n        List&lt;User> list = userService.list();\n        System.out.println(list);\n    &#125;\n\n&#125;\n\n**注意:**mybatisplus_04_generator项目中对于MyBatis的环境是没有进行配置，如果想要运行，需要提取将配置文件中的内容进行完善后在运行。\n思考:在MP封装的Service层都有哪些方法可以用?\n查看官方文档:https://mp.baomidou.com/guide/crud-interface.html,这些提供的方法大家可以参考官方文档进行学习使用，方法的名称可能有些变化，但是方法对应的参数和返回值基本类似。\n","slug":"MybatisPlus","date":"2022-10-15T03:10:00.000Z","categories_index":"java,框架","tags_index":"java,框架","author_index":"Leixng"},{"id":"37b10ae4f552cd04066b4c670e2ed751","title":"Mybatis框架","content":"MyBatis教程一、了解MyBatis1、历史（百度百科）\nMyBatis 本是apache的一个开源项目【iBatis】, 2010年这个项目由apache software foundation（Apache软件基金会） 迁移到了google code（谷歌的代码托管平台），并且改名为MyBatis ，2013年11月迁移到Github。\n\n2、作用 （百度百科）\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。\n\n3、说说持久化​\t\t持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）。\n\n程序产生的数据首先都是在内存。\n内存是不可靠的，他丫的一断电数据就没了。\n那可靠的存储地方是哪里？硬盘、U盘、光盘等。\n我们的程序在运行时说的持久化通常就是指将内存的数据存在硬盘。\n\n4、说说持久层其实分层的概念已经谈到过：\n\n业务是需要操作数据的\n数据是在磁盘上的\n具体业务调用具体的数据库操作，耦合度太高，复用性太差\n将操作数据库的代码统一抽离出来，自然就形成了介于业务层和数据库中间的独立的层\n\n5、聊聊ORM​\t\tORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。\n\njpa（Java Persistence API）是java持久化规范，是orm框架的标准，主流orm框架都实现了这个标准。\n\nhibernate：全自动的框架，强大、复杂、笨重、学习成本较高，不够灵活，实现了jpa规范。Java Persistence API（Java 持久层 API）\n\nMyBatis：半自动的框架(懂数据库的人 才能操作) 必须要自己写sql，不是依照的jpa规范实现的。\n\n\n很多人青睐 MyBatis ，原因是其提供了便利的 SQL 操作，自由度高，封装性好…… JPA对复杂 SQL 的支持不好，没有实体关联的两个表要做 join ，的确要花不少功夫。\n6、MyBatis的优点和缺点\nsql语句与代码分离，存放于xml配置文件中：\n优点：便于维护管理，不用在java代码中找这些语句；\n缺点： JDBC方式可以用打断点的方式调试，但是MyBatis调试比较复杂，一般要通过log4j日志输出日志信息帮助调试，然后在配置文件中修改。\n\n用逻辑标签控制动态SQL的拼接：\n优点：用标签代替编写逻辑代码；\n缺点：拼接复杂SQL语句时，没有代码灵活，拼写比较复杂。不要使用变通的手段来应对这种复杂的语句。\n\n查询的结果集与java对象自动映射：\n优点：保证名称相同，配置好映射关系即可自动映射或者，不配置映射关系，通过配置列名&#x3D;字段名也可完成自动映射。\n 缺点：对开发人员所写的SQL依赖很强。\n\n编写原生SQL：\n优点：接近JDBC，比较灵活。\n缺点：对SQL语句依赖程度很高；并且属于半自动，数据库移植比较麻烦，比如MySQL数据库编程Oracle数据库，部分的SQL语句需要调整。\n\n最重要的一点，使用的人多！公司需要！\n\n\n二、搭建个环境1、建立数据库CREATE DATABASE `ssm`;\nUSE `ssm`;\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n`id` int(20) NOT NULL,\n`username` varchar(30) DEFAULT NULL,\n`password` varchar(30) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert  into `user`(`id`,`username`,`password`) values (1,'itnanls','123456'),(2,'itlils','abcdef'),(3,'ydlclass','987654');\n\n\n\n2、构建一个父工程尝试学习聚合工程的规范，当然可以搭建独立的工程，我们选择一个比较新的jdk版本11：\n\n\n将父工程的打包方式修改成pom，表示一个聚合工程：\n&lt;packaging>pom&lt;/packaging>\n\n\n\n3、父工程的maven配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;groupId>com.ydlclass&lt;/groupId>\n    &lt;artifactId>ssm&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;packaging>pom&lt;/packaging>\n\n    &lt;!-- 父模块用于约束版本信息 -->\n    &lt;properties>\n        &lt;maven.compiler.source>11&lt;/maven.compiler.source>\n        &lt;maven.compiler.target>11&lt;/maven.compiler.target>\n        &lt;junit.version>4.13.1&lt;/junit.version>\n        &lt;mybatis.version>3.5.7&lt;/mybatis.version>\n        &lt;mysql-connector-java.version>8.0.26&lt;/mysql-connector-java.version>\n        &lt;lombok.version>1.18.22&lt;/lombok.version>\n    &lt;/properties>\n\n    &lt;dependencyManagement>\n        &lt;dependencies>\n            &lt;!-- 单元测试 -->\n            &lt;dependency>\n                &lt;groupId>junit&lt;/groupId>\n                &lt;artifactId>junit&lt;/artifactId>\n                &lt;version>$&#123;junit.version&#125;&lt;/version>\n                &lt;scope>test&lt;/scope>\n            &lt;/dependency>\n            &lt;!-- mybatis 核心 -->\n            &lt;dependency>\n                &lt;groupId>org.mybatis&lt;/groupId>\n                &lt;artifactId>mybatis&lt;/artifactId>\n                &lt;version>$&#123;mybatis.version&#125;&lt;/version>\n            &lt;/dependency>\n            &lt;!-- 数据库确定 -->\n            &lt;dependency>\n                &lt;groupId>mysql&lt;/groupId>\n                &lt;artifactId>mysql-connector-java&lt;/artifactId>\n                &lt;version>$&#123;mysql-connector-java.version&#125;&lt;/version>\n                &lt;scope>runtime&lt;/scope>\n            &lt;/dependency>\n            &lt;dependency>\n                &lt;groupId>org.projectlombok&lt;/groupId>\n                &lt;artifactId>lombok&lt;/artifactId>\n                &lt;version>$&#123;lombok.version&#125;&lt;/version>\n                &lt;scope>provided&lt;/scope>\n            &lt;/dependency>\n        &lt;/dependencies>\n    &lt;/dependencyManagement>\n\n&lt;/project>\n\n\n\n\n\n4、创建子模块\npom\n&lt;properties>\n    &lt;maven.compiler.source>11&lt;/maven.compiler.source>\n    &lt;maven.compiler.target>11&lt;/maven.compiler.target>\n&lt;/properties>\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;scope>runtime&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.projectlombok&lt;/groupId>\n        &lt;artifactId>lombok&lt;/artifactId>\n        &lt;scope>provided&lt;/scope>\n    &lt;/dependency>\n&lt;/dependencies>\n\n&lt;!-- 处理资源被过滤问题 -->\n&lt;build>\n    &lt;plugins>\n        &lt;plugin>\n            &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n            &lt;artifactId>maven-compiler-plugin&lt;/artifactId>\n            &lt;version>3.1&lt;/version>\n            &lt;configuration>\n                &lt;source>$&#123;maven.compiler.target&#125;&lt;/source> &lt;!-- 源代码使用的JDK版本 -->\n                &lt;target>$&#123;maven.compiler.target&#125;&lt;/target> &lt;!-- 需要生成的目标class文件的编译版本 -->\n                &lt;encoding>UTF-8&lt;/encoding>&lt;!-- 字符集编码 -->\n            &lt;/configuration>\n        &lt;/plugin>\n    &lt;/plugins>\n    &lt;resources>\n        &lt;resource>\n            &lt;directory>src/main/java&lt;/directory>\n            &lt;includes>\n                &lt;include>**/*.properties&lt;/include>\n                &lt;include>**/*.xml&lt;/include>\n            &lt;/includes>\n            &lt;filtering>false&lt;/filtering>\n        &lt;/resource>\n        &lt;resource>\n            &lt;directory>src/main/resources&lt;/directory>\n            &lt;includes>\n                &lt;include>**/*.properties&lt;/include>\n                &lt;include>**/*.xml&lt;/include>\n            &lt;/includes>\n            &lt;filtering>false&lt;/filtering>\n        &lt;/resource>\n    &lt;/resources>\n&lt;/build>\n\n\n\n5、回顾我们的jdbc代码@Test\npublic void testConnection1() throws Exception&#123;\n    //1.数据库连接的4个基本要素：\n    String url = \"jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\";\n    String username = \"root\";\n    String password = \"root\";\n    //8.0之后名字改了  com.mysql.cj.jdbc.Driver\n    String driverName = \"com.mysql.cj.jdbc.Driver\";\n\n    //2.实例化Driver\n    Class clazz = Class.forName(driverName);\n    Driver driver = (Driver) clazz.newInstance();\n    //3.注册驱动\n    DriverManager.registerDriver(driver);\n    //4.获取连接\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    PreparedStatement preparedStatement = conn.prepareStatement(\"select * from user where id = ?\");\n    preparedStatement.setInt(1,1);\n    ResultSet resultSet = preparedStatement.executeQuery();\n\n    // 处理结果集\n    while (resultSet.next())&#123;\n        User user = new User();\n        user.setId(resultSet.getInt(\"id\"));\n        user.setUsername(resultSet.getString(\"username\"));\n        user.setPassword(resultSet.getString(\"password\"));\n        System.out.println(user);\n    &#125;\n&#125;\n\n\n\n\n\n6、编写MyBatis核心配置文件，mybatis-config.xml\n\n\n\n\n\n\n\n\n有兴趣的自行深入研究。\n\nUNPOOLED：不使用连接池的数据源\nPOOLED：使用连接池的数据源\nJNDI：使用JNDI实现的数据源，我们在学习JavaEE的时候学习过了\n\n配置文件我们从官网复制：https://mybatis.org/mybatis-3/zh/getting-started.html\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;properties>\n        &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai\"/>\n        &lt;property name=\"username\" value=\"root\"/>\n        &lt;property name=\"password\" value=\"root\"/>\n    &lt;/properties>\n\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n                &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n                &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n                &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n&lt;/configuration>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小知识：\n（1）DTD：DTD(Document Type Definition)即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制\n如下所示是公共DTD示例。\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n关于DTD的声明解释如下：\n1、DTD声明始终以!DOCTYPE开头，空一格后跟着文档根元素的名称。\n2、根元素名：configuration。所以每一个标签库定义文件都是以taglib为根元素的，否则就不会验证通过。\n3、PUBLIC “-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN，这是一个公共DTD的名称（私有的使用SYSTEM表示）。这个东西命名是有些讲究的。首先它是以”-“开头的，表示这个DTD不是一个标准组织制定的。（如果是ISO标准化组织批准的，以“ISO”开头）。接着就是双斜杠“&#x2F;&#x2F;”，跟着的是DTD所有者的名字，很明显这个DTD是MyBatis公司定的。接着又是双斜杠“&#x2F;&#x2F;”，然后跟着的是DTD描述的文档类型，可以看出这份DTD描述的是DTD Config 3.0的格式。再跟着的就是“&#x2F;&#x2F;”和ISO 639语言标识符。\n4、绿色的字”http://mybatis.org/dtd/mybatis-3-config.dtd&quot;，表示这个DTD的位置。\n疑问：是不是xml分析器都会到java.sun.com上去找这个dtd呢？答案是否定的，xml分析器首先会以某种机制查找公共DTD的名称，查到了，则以此为标准，如果查不到，再到DTD位置上去找。\n（2）XSD​\t\t文档结构描述XML Schema Definition 缩写，这种文件同样可以用来定义我们xml文件的结构！\n我们看看pom文件的xml头部：\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\n\">\n\n1、第一行的xmlns代表了一个xml文件中的一个命名空间，通常是一个唯一的字符串，一般使用一个url，因为不会重复嘛。\n它的语法如下：\nxmlns:namespace-prefix&#x3D;&quot;namespaceURI&quot;\n\n后边什么也不加，代表默认命名空间，我们在书写标签的时候不需要加任何前缀。\n如果我将其改为：\nxmlns:c&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n\n\n2、xmlns:xsi 定义了一个命名空间前缀 xsi 对应的唯一字符串 http://www.w3.org/2001/XMLSchema-instance。但这个 xmlns:xsi 在不同的 xml 文档中似乎都会出现。 这是因为， xsi 已经成为了一个业界默认的用于 XSD(（XML Schema Definition) 文件的命名空间。 而 XSD 文件（也常常称为 Schema 文件）是用来定义 xml 文档结构的。剩余两行的目的在于为我们的命名空间指定对应的xsd文件。\n事实上我们这么写也是可以的：\n\n上面这行的语法其实是， xsi:schemaLocation &#x3D; “ns1url  xsd1  ns2url xsd2”   \nXML Schema相对于DTD的优点在于:\n\nXML Schema基于XML，没有专门的语法。\nXML Schema可以像其他XML文件一样解析和处理。\nXML Schema比DTD提供了更丰富的数据类型。\nXML Schema提供可扩充的数据模型。\nXML Schema支持综合命名空间。\nXML Schema支持属性组。\n\nmapper配置\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;&quot;&gt;\n\n\n\n\n\n&lt;&#x2F;mapper&gt;\n\n7、编写实体类\n\n\n\n\n\n\n\n\nlombok\n平时的工作中写setter和getter以及toString方法是不是已经烦了，每次添加一个字段都要重新添加这些方法。\n今天我们学习一个神器，从此再也不用写这些重复的代码了，它们在编译的时候动态的帮我们生成这些代码。\n\njavac对源代码进行分析，生成了一棵抽象语法树（AST）\n\n运行过程中调用实现了“JSR 269 API”的Lombok程序\n\n此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点\n\njavac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）\n\n\n1，首先，我们必须安装一个插件，否则编译的时候会报错，你没有写setter方法，又去调用它当然不能编译：\n\n2、引入依赖，lombok在编译的时候，会根据我们的注解动态生成我们需要的构造方法，setter和getter等，运行的时候就没用了。所以scope选择provided。\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n&lt;dependency>\n    &lt;groupId>org.projectlombok&lt;/groupId>\n    &lt;artifactId>lombok&lt;/artifactId>\n    &lt;version>1.18.16&lt;/version>\n    &lt;scope>provided&lt;/scope>\n&lt;/dependency>\n\n\n\n从今往后，只需要在对应的类上加上这几个注解，就能完成对应的编译工作\n\n@AllArgsConstructor：生成全参构造器。\n@NoArgsConstructor：生成无参构造器。\n@Getter&#x2F;@Setter： 作用类上，生成所有成员变量的getter&#x2F;setter方法；作用于成员变量上，生成该成员变量的getter&#x2F;setter方法。可以设定访问权限及是否懒加载等。\n@Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor\n@Log：作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解。\n\n注解还有很多，自行学习。\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable &#123;\n\n    private static final Long serialVersionUID = 1L;\n\n    private int id;\n    private String username;\n    private String password;\n&#125;\n\n此时我们的User是不是变得很简洁呢？\n我们随便写一个main方法，然后编译一下：\n编译后的结果是这个样子的：\npublic class User implements Serializable &#123;\n    private static final Long serialVersionUID = 1L;\n    private int id;\n    private String username;\n    private String password;\n\n    public static void main(String[] args) &#123;\n    &#125;\n\n    public int getId() &#123;\n        return this.id;\n    &#125;\n\n    public String getUsername() &#123;\n        return this.username;\n    &#125;\n\n    public String getPassword() &#123;\n        return this.password;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public boolean equals(Object o) &#123;\n        if (o == this) &#123;\n            return true;\n        &#125; else if (!(o instanceof User)) &#123;\n            return false;\n        &#125; else &#123;\n            User other = (User)o;\n            if (!other.canEqual(this)) &#123;\n                return false;\n            &#125; else if (this.getId() != other.getId()) &#123;\n                return false;\n            &#125; else &#123;\n                Object this$username = this.getUsername();\n                Object other$username = other.getUsername();\n                if (this$username == null) &#123;\n                    if (other$username != null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this$username.equals(other$username)) &#123;\n                    return false;\n                &#125;\n\n                Object this$password = this.getPassword();\n                Object other$password = other.getPassword();\n                if (this$password == null) &#123;\n                    if (other$password != null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this$password.equals(other$password)) &#123;\n                    return false;\n                &#125;\n\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    protected boolean canEqual(Object other) &#123;\n        return other instanceof User;\n    &#125;\n\n    public int hashCode() &#123;\n        int PRIME = true;\n        int result = 1;\n        int result = result * 59 + this.getId();\n        Object $username = this.getUsername();\n        result = result * 59 + ($username == null ? 43 : $username.hashCode());\n        Object $password = this.getPassword();\n        result = result * 59 + ($password == null ? 43 : $password.hashCode());\n        return result;\n    &#125;\n\n    public String toString() &#123;\n        int var10000 = this.getId();\n        return \"User(id=\" + var10000 + \", username=\" + this.getUsername() + \", password=\" + this.getPassword() + \")\";\n    &#125;\n\n    public User(int id, String username, String password) &#123;\n        this.id = id;\n        this.username = username;\n        this.password = password;\n    &#125;\n\n    public User() &#123;\n    &#125;\n&#125;\n\n我们发现，编译后注解没了，其他的都有了，自然运行时就能调用了呀！\n三、日志配置\n\n\n\n\n\n\n\n\n配置日志的一个重要原因是想在调试的时候能观察到sql语句的输出，能查看中间过程\n1、标准日志实现指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。\nSTD：standard    out：输出 \nSTDOUT_LOGGING：标准输出日志\n&lt;settings>\n    &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n&lt;/settings>\n\n这就好了，执行一下看看。\n2、组合logback完成日志功能（扩展）使用步骤：\n1、导入log4j的包\n&lt;dependency>\n    &lt;groupId>ch.qos.logback&lt;/groupId>\n    &lt;artifactId>logback-classic&lt;/artifactId>\n    &lt;version>$&#123;logback.version&#125;&lt;/version>\n&lt;/dependency>\n\n2、配置文件编写 log4j.properties\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration>\n\n    &lt;property name=\"pattern\" value=\"%d&#123;yyyy-MM-dd HH:mm:ss&#125; %c [%thread] %-5level %msg%n\"/>\n    &lt;property name=\"log_dir\" value=\"d:/logs\" />\n\n    &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        &lt;target>System.out&lt;/target>\n        &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            &lt;pattern>$&#123;pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n\n    &lt;appender name=\"file\" class=\"ch.qos.logback.core.FileAppender\">\n        &lt;!--日志格式配置-->\n        &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            &lt;pattern>$&#123;pattern&#125;&lt;/pattern>\n        &lt;/encoder>\n        &lt;!--日志输出路径-->\n        &lt;file>$&#123;log_dir&#125;/sql.log&lt;/file>\n    &lt;/appender>\n\n    &lt;root level=\"ALL\">\n        &lt;appender-ref ref=\"console\"/>\n    &lt;/root>\n\n    &lt;logger name=\"mybatis.sql\" level=\"debug\" additivity=\"false\">\n        &lt;appender-ref ref=\"console\"/>\n        &lt;appender-ref ref=\"file\"/>\n    &lt;/logger>\n\n&lt;/configuration>\n\n3、setting设置日志实现\n&lt;settings>\n   &lt;setting name=\"logImpl\" value=\"SLF4J\"/>\n&lt;/settings>\n\n\n\n\n\n\n\n\n\n四、CRUD来一套1、基本流程：// 1、创建一个SqlSessionFactory的 建造者 ，用于创建SqlSessionFactory\n// SqlSessionFactoryBuilder中有大量的重载的build方法，可以根据不同的入参，进行构建\n// 极大的提高了灵活性，此处使用【创建者设计模式】\nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n// 2、使用builder构建一个sqlSessionFactory，此处我们基于一个xml配置文件\n// 此过程会进行xml文件的解析，过程相对比较复杂\nSqlSessionFactory sqlSessionFactory = builder.build(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\"));\n// 3、通过sqlSessionFactory获取另一个session，此处使用【工厂设计模式】\nSqlSession sqlSession = sqlSessionFactory.openSession();\n\n1、创建一个SqlSessionFactory的 建造者 ，用于创建SqlSessionFactory\n2、使用builder构建一个sqlSessionFactory，此处我们基于一个xml配置文件\n3、通过sqlSessionFactory获取另一个session，此处使用【工厂设计模式】\n4、一个sqlsession就是一个会话，可以使用sqlsession对数据库进行操作，原理后边会讲。\n其实第一次使用sqlsession我们可能会这么操作：\ntry (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n    List&lt;Object> objects = sqlSession.selectList(\"select * from user\");\n&#125;\n\n\n\n（1）SqlSessionFactory​\t\t每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。\n​\t\tSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式。\n（2）SqlSession​\t\t每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：\ntry (SqlSession session = sqlSessionFactory.openSession()) &#123;\n  // 你的应用逻辑代码\n&#125;\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n（3）测试private SqlSessionFactory sqlSessionFactory = null;\nprivate static final Logger LOGGER = LoggerFactory.getLogger(TestMybatis.class);\n\n@Before\npublic void build() &#123;\n    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n    sqlSessionFactory = builder.build(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\"));\n&#125;\n\n\n\n当我们看到sqlSession有selectList，delete，update等方法时，我们会忍不住这样去使用。\n@Test\npublic void testSession()&#123;\n    try (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n        List&lt;Object> objects = sqlSession.selectList(\"select * from user\");\n        System.out.println(objects);\n    &#125;\n&#125;\n\n但是这样确实是错误的。\norg.apache.ibatis.exceptions.PersistenceException: \n### Error querying database.  Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for select * from user\n### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for select * from user\n\n错误消息中显示Mapped Statements collection does not contain value for select * from user，说是mapper的申明中没有“select * from user”，其实这里让你填的是一个申明。我们在源码注释中可以看到：】\n/**\n* Retrieve a list of mapped objects from the statement key.\n* @param &lt;E> the returned list element type\n* @param statement Unique identifier matching the statement to use.//与要使用的语句匹配的唯一标识符。  \n* @return List of mapped object\n*/\n&lt;E> List&lt;E> selectList(String statement);\n\n说明这个还需要通过使用sql的一个标识符。在MyBatis中我们还需要一个sql的映射文件来给每一个sql语句定义一个唯一标识符，我们起名UserMapper.xml，将这个文件放在resources文件夹下的mapper文件夹下：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"UserMapper\">\n    &lt;select id=\"selectOne\" resultType=\"com.ydlclass.User\">\n        select * from user where id = #&#123;id&#125;\n    &lt;/select>\n&lt;/mapper>\n\n还需要讲这个配置文件注册到主配置文件中，在最后边添加如下代码：\n&lt;mappers>\n    &lt;mapper resource=\"mapper/UserMapper.xml\"/>\n&lt;/mappers>\n\n我们会发现每一个mapper映射文件都有一个命名空间，从下边的用法来看我们能大致明白命名空间的作用。就如同我们国家可以有相同名字的县，但是加上市以后我们就能很轻松的区别两个县，这个市就是县的命名空间。\ntry (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n    List&lt;Object> users = sqlSession.selectList(\"UserMapper.selectAll\");\n    LOGGER.debug(\"result is [&#123;&#125;]\",objects);\n&#125;\n\n我们得到了正确的结果：\n\n当然不加命名空间也可，因为我们并没有其他重复的标识符，这个selectOne就是这条语句的标识符。\ntry (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n    List&lt;Object> users = sqlSession.selectList(\"selectAll\");\n    LOGGER.debug(\"result is [&#123;&#125;]\",objects);\n&#125;\n\n\n\n（4）动态代理实现但是MyBatis给我们提供了更好的解决方案，这种方案使用动态代理的技术实现，后边会详细讲。我们可以这样：\n1、定义一个接口：\npublic interface UserMapper &#123;\n    List&lt;User&gt; selectAll();\n&#125;\n\n2、修改映射文件，让命名空间改为接口的权限定名，id改为方法的名字\n&lt;mapper namespace=\"com.ydlclass.mapper.UserMapper\">\n    &lt;select id=\"selectAll\" resultType=\"com.ydlclass.entity.User\">\n        select * from user\n    &lt;/select>\n&lt;/mapper>\n\n3、我们可以很简单的使用如下的方法操作：\ntry (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    List&lt;User> list = mapper.selectAll();\n    LOGGER.debug(\"result is [&#123;&#125;]\",list);\n&#125;\n\n这样写起来简直不要太舒服，也确实拿到了对应的结果：\n\n​\t\t这里很明显使用了动态代理的方式，sqlSession.getMapper(UserMapper.class);帮我们生成一个代理对象，该对象实现了这个接口的方法，具体的数据库操作比如建立连接，创建statment等重复性的工作交给框架来处理，唯一需要额外补充的就是sql语句了，xml文件就是在补充这个描述信息，比如具体的sql，返回值的类型等，框架会根据命名空间自动匹配对应的接口，根据id自动匹配接口的方法，不需要我们再做额外的操作。\n接下来我们就把增删改查全部写一下，感受一下：\n2、select（查询）\n\n\n\n\n\n\n\n\nselect标签是mybatis中最常用的标签\n1、在UserMapper中添加对应方法\n/**\n     * 根据id查询用户\n     * @param id\n     * @return\n     */\nUser selectUserById(int id);\n\n2、在UserMapper.xml中添加Select语句\n&lt;select id=\"selectUserById\" resultType=\"com.ydlclass.entity.User\"  parameterType=\"int\">\n    select id,username,password from user where id = #&#123;id&#125;\n&lt;/select>\n\n\n\n\n\n\n\n\n\n\n\n\n新的知识点，在映射文件中有一些属性：\n\nresultType：指定返回类型，查询是有结果的，结果啥类型，你得告诉我\nparameterType：指定参数类型，查询是有参数的，参数啥类型，你得告诉我\nid：指定对应的方法映射关系，就是你得告诉我你这sql对应的是哪个方法\n#{id}：sql中的变量，要保证大括号的变量必须在User对象里有\n#{}：占位符，其实就是咱们的【PreparedStatement】处理这个变量，mybatis会将它替换成?\n\n\n\n\n\n\n\n\n\n\n除了#{}还有${}，看看有啥区别，面试常问\n\n#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】\nINSERT INTO user (username) VALUES (#&#123;username&#125;);\nINSERT INTO user (username) VALUES (?);\n\n${} 的作用是直接进行字符串替换\nINSERT INTO user (username) VALUES ('$&#123;username&#125;');\nINSERT INTO user (username) VALUES ('楠哥');\n\n3、测试类中测试\ntry (SqlSession sqlSession = sqlSessionFactory.openSession();)&#123;\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    User user = mapper.selectUserById(1);\n    LOGGER.debug(\"the user is [&#123;&#125;]\",user);\n&#125;\n\n结果正确：\n\n我们不妨把session的创建定义成一个方法：\nprivate static SqlSession open()&#123;\n    // 1、创建一个SqlSessionFactory的 建造者 ，用于创建SqlSessionFactory\n    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n    // 2、使用builder构建一个sqlSessionFactory，此处我们基于一个xml配置文件\n    SqlSessionFactory sqlSessionFactory = builder.build(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\"));\n    // 3、通过sqlSessionFactory获取另一个session，此处使用【工厂设计模式】\n    return sqlSessionFactory.openSession();\n&#125;\n\n\n\n\n\n3、insert（插入）\n\n\n\n\n\n\n\n\ninsert标签被用作插入操作\n1、接口中添加方法\n/**\n     * 新增user\n     * @param user\n     * @return\n     */\nint addUser(User user);\n\n2、xml中加入insert语句\n&lt;insert id=\"addUser\" parameterType=\"com.ydlclass.entity.User\">\n    insert into user (id,username,password) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)\n&lt;/insert>\n\n3、测试\n@Test\npublic void testAdd()&#123;\n    SqlSession sqlSession = open();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int rows = mapper.addUser(new User(10, \"lucy\", \"123\"));\n    LOGGER.debug(\"Affected rows: [&#123;&#125;]\",rows);\n&#125;\n\n返回值是1，你欣喜若狂，总以为就是这么简单，但事实是，数据库压根没有存进去：\n\n注：增、删、改操作需要提交事务！在默认情况下MySQL的事务是自动提交的，而框架却默认设置成了手动提交，我们开启了事务，又没有去提交事务，结束后自然会回滚啊:\n第一种方式，在openSession方法传入true，就变成自动提交了：\nsqlSessionFactory.openSession(true);\n\n第二种方式，我们手动提交，事实上我们肯定要手动提交事务：\n@Test\npublic void testAdd()&#123;\n    SqlSession sqlSession = open();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int rows = mapper.addUser(new User(10, \"lucy\", \"123\"));\n    LOGGER.debug(\"Affected rows: [&#123;&#125;]\",rows);\n    sqlSession.commit();\n    sqlSession.close();\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n思考，如果参数没有传实体类而是传了多个参数，，能不能执行\n比如数据库为id，方式传入userId\n1、在UserMapper中添加对应方法\n/**\n     * 新增用户\n     * @param id\n     * @param name\n     * @param pws\n     * @return\n     */\nint insertUser(int id,String name,String pws);\n\n2、在UserMapper.xml中添加Select语句\n&lt;insert id=\"insertUser\" parameterType=\"com.ydlclass.entity.User\">\n    insert into user (id,username,password) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)\n&lt;/insert>\n\n3、测试\n@Test\n    public void testInsert()&#123;\n        SqlSession sqlSession = open();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int rows = mapper.insertUser(10, \"lucy\", \"123\");\n        LOGGER.debug(\"Affected rows: [&#123;&#125;]\",rows);\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n\n出问题了\nCause: org.apache.ibatis.binding.BindingException: Parameter &#39;id&#39; not found. Available parameters are [arg2, arg1, arg0, param3, param1, param2]\n\n这就无法映射了。\n这就需要注解@Param了，这其实就是在做映射关系，xml里的${username}和方法中的name做映射：\nint insertUser(@Param(\"id\") int id, @Param(\"username\") String name,@Param(\"password\") String pws);\n\n\n\n此时又一次成功了：\n@Test\npublic void testInsert()&#123;\n    SqlSession sqlSession = open();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int rows = mapper.insertUser(11, \"lucy\", \"123\");\n    LOGGER.debug(\"Affected rows: [&#123;&#125;]\",rows);\n    sqlSession.commit();\n    sqlSession.close();\n&#125;\n\n所以我们遇到mapper中有多个参数时，一定要使用@Param注解，建立映射关系。\n4、update（修改）\n\n\n\n\n\n\n\n\nupdate标签用于更新操作\n1、写接口\n/**\n * 修改用户\n * @param user\n * @return\n */\nint updateUser(User user);\n\n2、写SQL\n&lt;update id=\"updateUser\" parameterType=\"com.ydlclass.entity.User\">\n    update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id = #&#123;id&#125;\n&lt;/update>\n\n3、测试\n@Test\npublic void testUpdate()&#123;\n    SqlSession sqlSession = open();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int rows = mapper.updateUser(new User(11, \"小微微\", \"123\"));\n    LOGGER.debug(\"Affected rows: [&#123;&#125;]\",rows);\n    sqlSession.commit();\n    sqlSession.close();\n&#125;\n\n\n\n5、delete（删除）\n\n\n\n\n\n\n\n\ndelete标签用于做删除操作\n1、写接口\n/**\n* 删除一个用户\n* @param id\n* @return\n*/\nint deleteUser(int id);\n\n2、写SQL\n&lt;delete id=\"deleteUser\" parameterType=\"int\">\n  delete from user where id = #&#123;id&#125;\n&lt;/delete>\n\n3、测试\n @Test\npublic void testDeleteUser()&#123;\n    SqlSession sqlSession = open();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int affectedRows = mapper.deleteUser(5);\n    LOGGER.debug(\"Affected rows: [&#123;&#125;]\",affectedRows);\n    sqlSession.commit();\n    sqlSession.close();\n&#125;\n\n\n\n6、模糊查询\n\n\n\n\n\n\n\n\n方案一：在Java代码中拼串\nstring name = “%IT%”;\nlist&lt;name> names = mapper.getUserByName(name);\n\n&lt;select id=”getUsersByName”>\n\tselect * from user where name like #&#123;name&#125;\n&lt;/select>\n\n\n\n\n\n\n\n\n\n\n方案二：在配置文件中拼接\nstring name = “IT”;\nlist&lt;User> users = mapper.getUserByName(name);\n\n&lt;select id=”getUsersByName”>\n    select * from user where name like \"%\"#&#123;name&#125;\"%\"\n&lt;/select>\n\n为什么必须用双引号？\n\n\n\n\n\n\n\n\n\n方案三：在配置文件中拼接\n&lt;select id&#x3D;”getUsersByName”&gt;\n    select * from user where name like &quot;%$&#123;name&#125;%&quot;\n&lt;&#x2F;select&gt;\n\n\n\n7、map的使用\n\n\n\n\n\n\n\n\nmap可以代替任何的实体类，所以当我们数据比较复杂时，可以适当考虑使用map来完成相关工作\n1、写sql\n&lt;select id=\"getUsersByParams\" parameterType=\"java.util.HashMapmap\">\n    select id,username,password from user where username = #&#123;name&#125;\n&lt;/select>\n\n2、写方法\n/**\n* 根据一些参数查询\n* @param map\n* @return\n*/\nList&lt;User> getUsersByParams(Map&lt;String,String> map);\n\n3、测试\n@Test\npublic void findByParams() &#123;\n    UserMapper mapper = session.getMapper(UserMapper.class);\n    Map&lt;String,String> map = new HashMap&lt;String, String>();\n    map.put(\"name\",\"磊磊哥\");\n    List&lt;User> users = mapper.getUsersByParams(map);\n    for (User user: users)&#123;\n        System.out.println(user.getUsername());\n    &#125;\n&#125;\n\n\n\n\n\n五、使用注解开发DROP TABLE IF EXISTS `admin`;\nCREATE TABLE `admin` (\n`id` int(20) NOT NULL,\n`username` varchar(30) DEFAULT NULL,\n`password` varchar(30) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert  into `admin`(`id`,`username`,`password`) values (1,'itnanls','123456'),(2,'itlils','abcdef'),(3,'小微','987654');\n\n​\t\tMyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建，所以这里我们作为了解。\n\nsql 类型主要分成 :\n@select ()\n@update ()\n@Insert ()\n@delete ()\n\n注意：利用注解开发就不需要mapper.xml映射文件了 .\n1、接口中添加注解@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Admin &#123;\n\n    private static final Long serialVersionUID = 1L;\n\n    private int id;\n    private String username;\n    private String password;\n&#125;\n\n\n\npublic interface AdminMapper &#123;\n\n    /**\n     * 保存管理员\n     * @param admin\n     * @return\n     */\n    @Insert(\"insert into admin (username,password) values (#&#123;username&#125;,#&#123;password&#125;)\")\n    int saveAdmin(Admin admin);\n\n    /**\n     * 跟新管理员\n     * @param admin\n     * @return\n     */\n    @Update(\"update admin set username=#&#123;username&#125; , password=#&#123;password&#125; where id = #&#123;id&#125;\")\n    int updateAdmin(Admin admin);\n\n    /**\n     * 删除管理员\n     * @param admin\n     * @return\n     */\n    @Delete(\"delete from admin where id=#&#123;id&#125;\")\n    int deleteAdmin(int id);\n\n    /**\n     * 根据id查找管理员\n     * @param id\n     * @return\n     */\n    @Select(\"select id,username,password from admin where id=#&#123;id&#125;\")\n    Admin findAdminById(@Param(\"id\") int id);\n\n    /**\n     * 查询所有的管理员\n     * @return\n     */\n    @Select(\"select id,username,password from admin\")\n    List&lt;Admin> findAllAdmins();\n\n&#125;\n\n2、核心配置文件中配置添加一个mapper的配置：\n&lt;mapper class=\"com.ydlclass.mapper.AdminMapper\"/>\n\n3、进行测试public class TestAdminMapper &#123;\n\n    @Test\n    public void testSaveAdmin() &#123;\n        SqlSession session = open();\n        AdminMapper mapper = session.getMapper(AdminMapper.class);\n        Admin admin = new Admin(1,\"微微姐\",\"12345678\");\n        int affectedRows = mapper.saveAdmin(admin);\n         LOGGER.debug(\"Affected rows: [&#123;&#125;]\",affectedRows);\n        session.commit();\n        session.close();\n    &#125;\n\n    @Test\n    public void testUpdateAdmin() &#123;\n        SqlSession session = open();\n        AdminMapper mapper = session.getMapper(AdminMapper.class);\n        Admin user = new Admin(1,\"磊磊哥\",\"12345678\");\n        int affectedRows = mapper.updateAdmin(user);\n        LOGGER.debug(\"Affected rows: [&#123;&#125;]\",affectedRows);\n        session.commit();\n        session.close();\n    &#125;\n\n    @Test\n    public void testDeleteAdmin()&#123;\n        SqlSession session = open();\n        AdminMapper mapper = session.getMapper(AdminMapper.class);\n        int affectedRows = mapper.deleteAdmin(2);\n        LOGGER.debug(\"Affected rows: [&#123;&#125;]\",affectedRows);\n        session.commit();\n        session.close();\n    &#125;\n\n    @Test\n    public void testGetAdminById()&#123;\n        SqlSession session = open();\n        AdminMapper mapper = session.getMapper(AdminMapper.class);\n        Admin admin = mapper.findAdminById(1);\n        LOGGER.debug(\"The admin is: [&#123;&#125;]\",admin);\n        session.commit();\n        session.close();\n    &#125;\n\n    @Test\n    public void testGetAllAdmins()&#123;\n        SqlSession session = open();\n        AdminMapper mapper = session.getMapper(AdminMapper.class);\n        List&lt;Admin> admins = mapper.findAllAdmins();\n        LOGGER.debug(\"The admins is: [&#123;&#125;]\",admin);\n        session.commit();\n        session.close();\n    &#125;\n\n    private static SqlSession open()&#123;\n        // 1、创建一个SqlSessionFactory的 建造者 ，用于创建SqlSessionFactory\n        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n        // 2、使用builder构建一个sqlSessionFactory，此处我们基于一个xml配置文件\n        SqlSessionFactory sqlSessionFactory = builder.build(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\"));\n        // 3、通过sqlSessionFactory获取另一个session，此处使用【工厂设计模式】\n        return sqlSessionFactory.openSession();\n    &#125;\n\n&#125;\n\n\n\n\n\n\n\n六、架构源码解析（选学）1、架构讲解Mybatis的功能架构分为三层：\n\nAPI接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。\n数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。\n基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。\n2、核心成员：\nConfiguration：MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中\nSqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能\nExecutor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护\nStatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等\nParameterHandler：负责对用户传递的参数转换成JDBC Statement 所对应的数据类型\nResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合\nTypeHandler：负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换\nMappedStatement：MappedStatement维护一条&lt;select|update|delete|insert&gt;节点的封装\nSqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回\nBoundSql：表示动态生成的SQL语句以及相应的参数信息\n\n\n\n3、源码解读（1）构建session工厂// 1、创建一个SqlSessionFactory的 建造者 ，用于创建SqlSessionFactory\n// SqlSessionFactoryBuilder中有大量的重载的build方法，可以根据不同的入参，进行构建\n// 极大的提高了灵活性，此处使用【创建者设计模式】\nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n\n这是一个创建者设计模式的经典应用：\n// 使用builder构建一个sqlSessionFactory，此处我们基于一个xml配置文件\n// 此过程会进行xml文件的解析，过程相对比较复杂\nSqlSessionFactory sqlSessionFactory = builder.build(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatis-config.xml\"));\n\n\n\n\n\n\n\n\n\n\n源码部分：这里有众多的重载build方法，我们调用的build方法，会是如下大流程\npublic SqlSessionFactory build(InputStream inputStream) &#123;\n    return build(inputStream, null, null);\n&#125;\n\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;\n    try &#123;\n        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        return build(parser.parse());\n    &#125; catch (Exception e) &#123;\n    ....\n&#125;\n\n从上边的return看，其实核心的代码又回归到了build(parser.parse())这个构造器。\npublic SqlSessionFactory build(Configuration config) &#123;\n    return new DefaultSqlSessionFactory(config);\n&#125;\n\n​\t\t其实，本质上，无论你做了多少工作，你使用xml也好，不使用xml也好，最终都是需要一个Configuration实例，这里保存了所有的配置项。\n​\t\t当然我们可以独立去使用Configuration类构造实例，不使用xml。\n例如：\nConfiguration configuration = new Configuration();\n// 创建一个数据源\nPooledDataSource pooledDataSource = new PooledDataSource();\npooledDataSource.setDriver(\"com.mysql.cj.jdbc.Driver\");\npooledDataSource.setUrl(\"jdbc:mysql://127.0.0.1:3306/ydlclass?characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai\");\npooledDataSource.setUsername(\"root\");\npooledDataSource.setPassword(\"root\");\nEnvironment environment = new Environment(\"env\",new JdbcTransactionFactory(),new PooledDataSource());\nconfiguration.setEnvironment(environment);\n\n等同于：\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/ydlclass?characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n&lt;/configuration>\n\n\n\n​\t\txml的解析过程就是将xml文件转化为Configuration对象，它在启动的时候执行，也就意味着修改配置文件就要重启。所以本环节的重点就到了。\n（2）配置文件的解析parser.parse()这个方法了，这就是在解析xml配置文件。\n在build方法中我们看到了如下代码：\nXMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n\n这一步就是构造一个解析器，根据我们的入参构建一个文档解析器。使用了sax进行xml的解析，我们在讲JavaEE的时候讲过。\n当然，我们要把重点放在parse()方法上：\npublic Configuration parse() &#123;\n    ...省略不重要的代码\n    //此处就是解析的核心代码\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n&#125;\n\n咱们进入这个方法，慢慢分析，其中的内容很多，很明显看到这个方法就是在解析每一个标签。\nprivate void parseConfiguration(XNode root) &#123;\n    try &#123;\n        // 处理properties标签\n        propertiesElement(root.evalNode(\"properties\"));\n        Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n        loadCustomVfs(settings);\n        loadCustomLogImpl(settings);\n\t\t// 处理别名的标签\n        typeAliasesElement(root.evalNode(\"typeAliases\"));\n        pluginElement(root.evalNode(\"plugins\"));\n        objectFactoryElement(root.evalNode(\"objectFactory\"));\n        objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n        reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n        settingsElement(settings);\n        // read it after objectFactory and objectWrapperFactory issue #631\n        // 处理environments标签\n        environmentsElement(root.evalNode(\"environments\"));\n        databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n        typeHandlerElement(root.evalNode(\"typeHandlers\"));\n        // 处理mappers标签\n        mapperElement(root.evalNode(\"mappers\"));\n    &#125; catch (Exception e) &#123;\n        throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    &#125;\n&#125;\n\n​\t\t其实我们看到这里就大致明白了MyBatis解析xml的时机和方法了。从这里我们也能基本看出来一个配置文件内能使用的标签，以及书写标签的顺序，因为这个解析过程也是有顺序的，我们随便列出几个标签看看配置文件长什么样子：\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;properties>\n        &lt;property name=\"username\" value=\"root\"/>\n    &lt;/properties>\n\n    &lt;settings>\n        &lt;setting name=\"\" value=\"\"/>\n    &lt;/settings>\n    &lt;typeAliases>\n        &lt;typeAlias type=\"com.ydlclass.User\" alias=\"user\"/>\n    &lt;/typeAliases>\n\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/ydlclass?characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;mappers>\n        &lt;mapper resource=\"userMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n（3）mapper文件的解析过程我们暂且忽略掉其他标签的处理，以mappers标签为例继续深入探索：\nprivate void mapperElement(XNode parent) throws Exception &#123;\n    if (parent != null) &#123;\n        // 循环遍历他的孩子节点\n        for (XNode child : parent.getChildren()) &#123;\n            if (\"package\".equals(child.getName())) &#123;\n                // &lt;package name=\"com.ydlclass\"/>\n                String mapperPackage = child.getStringAttribute(\"name\");\n                // 直接将包名加入配置项\n                configuration.addMappers(mapperPackage);\n            &#125; else &#123;\n         \n                String resource = child.getStringAttribute(\"resource\");\n                String url = child.getStringAttribute(\"url\");\n                String mapperClass = child.getStringAttribute(\"class\");\n                // 如果是resource属性,就通过resource获取资源并解析&lt;mapper resource=\"userMapper.xml\"/>\n                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;\n                    ErrorContext.instance().resource(resource);\n                    InputStream inputStream = Resources.getResourceAsStream(resource);\n                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n                    mapperParser.parse();\n                // 如果是url属性,就通过url获取资源并解析 &lt;mapper url=\"http://www.ydlclass.com/UserMapper.xml\"/>\n                &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;\n                    ErrorContext.instance().resource(url);\n                    InputStream inputStream = Resources.getUrlAsStream(url);\n                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n                    mapperParser.parse();\n                // 如果是url属性,就通过url获取资源并解析 &lt;mapper class=\"com.ydlclass.UserMapper\"/>\n                &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;\n                    Class&lt;?> mapperInterface = Resources.classForName(mapperClass);\n                    // 注册一个mapper\n                    configuration.addMapper(mapperInterface);\n                &#125; else &#123;\n                    throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n​\t\t这里就是想尽办法，获取mapper的配置信息，然后做下一步处理，其实无论是哪一种方式都是会在Configuration的mapperRegistry （mapper注册器中）中注册一个mapper。其实就是将mapper的class信息放在一个名为knownMappers的hashmap中，以便后续使用。当然他的值一个一个代理工厂，这玩意能帮我们获取一个mapper的代理对象，更详细的后续说。\nprivate final Map&lt;Class&lt;?>, MapperProxyFactory&lt;?>> knownMappers = new HashMap&lt;>();\n\n\n\n\n\n\n\n\n\n\n\n\n对于package属性\n直接将包名注册到配置中，然后调用MapperRegistry的addMappers方法，通过扫描文件的方式将这个包底下的class添加进kownMappers中。\npublic void addMappers(String packageName) &#123;\n   mapperRegistry.addMappers(packageName);\n &#125;\n\npublic void addMappers(String packageName) &#123;\n    addMappers(packageName, Object.class);\n&#125;\n\npublic void addMappers(String packageName, Class&lt;?> superType) &#123;\n    ResolverUtil&lt;Class&lt;?>> resolverUtil = new ResolverUtil&lt;>();\n    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);\n    Set&lt;Class&lt;? extends Class&lt;?>>> mapperSet = resolverUtil.getClasses();\n    for (Class&lt;?> mapperClass : mapperSet) &#123;\n        addMapper(mapperClass);\n    &#125;\n&#125;\n\npublic &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;\n    mapperRegistry.addMapper(type);\n  &#125;\n\n我们可以从MapperRegistry中看到，addMapper的整个过程。\npublic &lt;T> void addMapper(Class&lt;T> type) &#123;\n   if (type.isInterface()) &#123;\n     if (hasMapper(type)) &#123;\n       throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\");\n     &#125;\n     boolean loadCompleted = false;\n     try &#123;\n       knownMappers.put(type, new MapperProxyFactory&lt;>(type));\n      ...省略不重要的代码\n   &#125;\n &#125;\n\n​\t\t我们不妨把MapperProxyFactory的代码粘贴出来看看，里边维护了一个接口和方法缓存（这个后边会讲，目前他是一个空的Map），这个代理工厂确实有方法帮我们生成代理对象（newInstance）。我们看到了代理设计模式。\npublic class MapperProxyFactory&lt;T> &#123;\n\n  private final Class&lt;T> mapperInterface;\n  private final Map&lt;Method, MapperMethodInvoker> methodCache = new ConcurrentHashMap&lt;>();\n\n  public MapperProxyFactory(Class&lt;T> mapperInterface) &#123;\n    this.mapperInterface = mapperInterface;\n  &#125;\n\n  public Class&lt;T> getMapperInterface() &#123;\n    return mapperInterface;\n  &#125;\n\n  public Map&lt;Method, MapperMethodInvoker> getMethodCache() &#123;\n    return methodCache;\n  &#125;\n\n  @SuppressWarnings(\"unchecked\")\n  protected T newInstance(MapperProxy&lt;T> mapperProxy) &#123;\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);\n  &#125;\n\n  public T newInstance(SqlSession sqlSession) &#123;\n    final MapperProxy&lt;T> mapperProxy = new MapperProxy&lt;>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n  &#125;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n对与class属性的处理\n​\t\t这个属性我们配置的是一个class，&lt;mapper class=&quot;com.ydlclass.UserMapper&quot;/&gt;，对一class将来肯定要从注解中解析信息，直接把他的class信息注册进去就好了。\n\n\n\n\n\n\n\n\n\nresource属性以及url属性的处理\n​\t\t在resource属性以及url属性中没有看到configuration.addMapper()这个方法的影子，这两个属性都是以配置文件的方式加载，自然要解析mapper配置文件了。\n我们看到了XMLMapperBuilder这个类的parse()方法。很明显这个方法configurationElement是用来解析配置文件的。\npublic void parse() &#123;\n    if (!configuration.isResourceLoaded(resource)) &#123;\n        configurationElement(parser.evalNode(\"/mapper\"));\n        configuration.addLoadedResource(resource);\n        bindMapperForNamespace();\n    &#125;\n\n    parsePendingResultMaps();\n    parsePendingCacheRefs();\n    parsePendingStatements();\n&#125;\n\n而在这个方法中bindMapperForNamespace我们看到了注册mapper的代码：\nprivate void bindMapperForNamespace() &#123;\n       ...其他代码省略\n            configuration.addLoadedResource(\"namespace:\" + namespace);\n            configuration.addMapper(boundType);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nmapper的具体解析\n创建一个解析器：\nXMLMapperBuilder mapperParser &#x3D; new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n\n这个方法就是对每一个标签的解析：\nprivate void configurationElement(XNode context) &#123;\n    try &#123;\n        String namespace = context.getStringAttribute(\"namespace\");\n        if (namespace == null || namespace.isEmpty()) &#123;\n            throw new BuilderException(\"Mapper's namespace cannot be empty\");\n        &#125;\n        builderAssistant.setCurrentNamespace(namespace);\n        cacheRefElement(context.evalNode(\"cache-ref\"));\n        cacheElement(context.evalNode(\"cache\"));\n        parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n        resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n        sqlElement(context.evalNodes(\"/mapper/sql\"));\n        buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    &#125; catch (Exception e) &#123;\n        throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    &#125;\n&#125;\n\n\n\n\n\n（4）通过sqlSession获取一个代理对象通过sqlSessionFactory获取另一个session，此处使用【工厂设计模式】\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n\n\n\n\n\n\n\n\n\n接下来就要研究mapper的代理对象生成的过程了，此处使用【代理设计模式】\n// 4、通过sqlSession获取一个代理对象，此处使用【代理设计模式】\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n\n\n我们可以走到DefaultSqlSession，这是SqlSession的一个子类，从open方法中我们能看到默认创建的sqlSession是他的子类DefaultSqlSession\nprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;\n    ...省略不重要的代码\n    return new DefaultSqlSession(configuration, executor, autoCommit);\n&#125;\n\n从实现类的getMapper中得知：\npublic &lt;T> T getMapper(Class&lt;T> type) &#123;\n    return configuration.getMapper(type, this);\n&#125;\n\npublic &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;\n    return mapperRegistry.getMapper(type, sqlSession);\n  &#125;\n\n从注册器中获取mapper工厂，并创建代理对象：\npublic &lt;T> T getMapper(Class&lt;T> type, SqlSession sqlSession) &#123;\n    final MapperProxyFactory&lt;T> mapperProxyFactory = (MapperProxyFactory&lt;T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) &#123;\n        throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    &#125;\n    try &#123;\n        // 创建代理对象：\n        return mapperProxyFactory.newInstance(sqlSession);\n    &#125; catch (Exception e) &#123;\n        throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    &#125;\n&#125;\n\n\n\n那我们可以聊一聊MapperProxyFactory这个类了，它持有一个接口和一个methodCache，这个接口当然是为了生成代理对象使用的类。\npublic class MapperProxyFactory&lt;T> &#123;\n    private final Class&lt;T> mapperInterface;\n    private final Map&lt;Method, MapperMethodInvoker> methodCache = new ConcurrentHashMap&lt;>();\n&#125;\n\n在创建对象的时候创建了一个MapperProxy：\npublic T newInstance(SqlSession sqlSession) &#123;\n    final MapperProxy&lt;T> mapperProxy = new MapperProxy&lt;>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n&#125;\n\n\n\nMapperProxy就是我们的InvocationHandler，也是创建代理对象必须的，其中的核心方法是invoke，会在调用代理对象的方法时调用：\npublic class MapperProxy&lt;T> implements InvocationHandler, Serializable &#123;\n\n    private static final long serialVersionUID = -4724728412955527868L;\n    private static final int ALLOWED_MODES = MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED\n        | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;\n    private static final Constructor&lt;Lookup> lookupConstructor;\n    private static final Method privateLookupInMethod;\n    private final SqlSession sqlSession;\n    private final Class&lt;T> mapperInterface;\n    private final Map&lt;Method, MapperMethodInvoker> methodCache;\n\n    public MapperProxy(SqlSession sqlSession, Class&lt;T> mapperInterface, Map&lt;Method, MapperMethodInvoker> methodCache) &#123;\n        this.sqlSession = sqlSession;\n        this.mapperInterface = mapperInterface;\n        this.methodCache = methodCache;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        try &#123;\n            if (Object.class.equals(method.getDeclaringClass())) &#123;\n                return method.invoke(this, args);\n            &#125; else &#123;\n                return cachedInvoker(method).invoke(proxy, method, args, sqlSession);\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            throw ExceptionUtil.unwrapThrowable(t);\n        &#125;\n    &#125;\n\n核心方法当然是invoke了，将来调用代理对象的方法，其实就是在执行此方法。\n（5）方法调用当我们执行代理的对象的方法时：\nList&lt;User&gt; allUser &#x3D; mapper.findAllUser(12);\n\ninvoke方法会被调用，这里会判断它调用的是继承自Object的方法还是实现的接口的方法，我们的重点放在：\ncachedInvoker(method).invoke(proxy, method, args, sqlSession);\n\n\n\nprivate MapperMethodInvoker cachedInvoker(Method method) throws Throwable &#123;\n    try &#123;\n      // 这里就知道了methodCache的左右了，方法存在缓存里避免频繁的创建\n      MapperMethodInvoker invoker = methodCache.get(method);\n      if (invoker != null) &#123;\n        return invoker;\n      &#125;\n\n        // 缓存没有就创建一个\n      return methodCache.computeIfAbsent(method, m -> &#123;\n          // 这里是处理接口的默认方法\n        if (m.isDefault()) &#123;\n          try &#123;\n            if (privateLookupInMethod == null) &#123;\n              return new DefaultMethodInvoker(getMethodHandleJava8(method));\n            &#125; else &#123;\n              return new DefaultMethodInvoker(getMethodHandleJava9(method));\n            &#125;\n          &#125; catch (IllegalAccessException | InstantiationException | InvocationTargetException\n              | NoSuchMethodException e) &#123;\n            throw new RuntimeException(e);\n          &#125;\n            // 核心代码在这里\n        &#125; else &#123;\n          return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));\n        &#125;\n      &#125;);\n    &#125; catch (RuntimeException re) &#123;\n      Throwable cause = re.getCause();\n      throw cause == null ? re : cause;\n    &#125;\n  &#125;\n\n核心是（普通的方法调用者）：\nnew PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));\n\n在PlainMethodInvoker传入了一个MapperMethod（方法的包装类），根据接口、方法签名和我们的配置生成一个方法的包装，这里有SqlCommand（用来执行sql），还有我们的方法签名。\npublic class MapperMethod &#123;\n\n  private final SqlCommand command;\n  private final MethodSignature method;\n\n  public MapperMethod(Class&lt;?> mapperInterface, Method method, Configuration config) &#123;\n    this.command = new SqlCommand(config, mapperInterface, method);\n    this.method = new MethodSignature(config, mapperInterface, method);\n  &#125;\n&#125;\n\n\n\n它还有个核心方法，就是执行具体的sql啦！\npublic Object execute(SqlSession sqlSession, Object[] args) &#123;\n    Object result;\n    switch (command.getType()) &#123;\n      case INSERT: &#123;\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(), param));\n        break;\n      &#125;\n      case UPDATE: &#123;\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(), param));\n        break;\n      &#125;\n      case DELETE: &#123;\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(), param));\n        break;\n      &#125;\n      case SELECT:\n        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;\n          executeWithResultHandler(sqlSession, args);\n          result = null;\n        &#125; else if (method.returnsMany()) &#123;\n          result = executeForMany(sqlSession, args);\n\t// 一下部分省略\n    return result;\n  &#125;\n\n\n\n回头看：\ncachedInvoker(method).invoke(proxy, method, args, sqlSession);\n\n本质调用的就是PlainMethodInvoker这个子类的invoke方法，而它确实调用mapperMethod.execute方法。到此就明白了整个流程\nprivate static class PlainMethodInvoker implements MapperMethodInvoker &#123;\n  private final MapperMethod mapperMethod;\n\n  public PlainMethodInvoker(MapperMethod mapperMethod) &#123;\n    super();\n    this.mapperMethod = mapperMethod;\n  &#125;\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable &#123;\n    return mapperMethod.execute(sqlSession, args);\n  &#125;\n&#125;\n\n\n\n（6）继续了解\n\n\n\n\n\n\n\n\n一级缓存\n我们不妨在excute方法中随机找一个select语句深入挖掘：\nresult &#x3D; executeForMany(sqlSession, args);executeForMany(sqlSession, args);\n\n看方法：\nprivate &lt;E> Object executeForMany(SqlSession sqlSession, Object[] args) &#123;\n    List&lt;E> result;\n    ...省略其他代码\n        result = sqlSession.selectList(command.getName(), param);\n   \n    return result;\n&#125;\n\n这里就能看到本质上使用的是sqlSession.selectList(command.getName(), param);这距离我们熟悉的越来越近了：\n@Override\npublic &lt;E> List&lt;E> selectList(String statement, Object parameter, RowBounds rowBounds) &#123;\n    try &#123;\n        // MappedStatement，使用执行器执行sql\n        MappedStatement ms = configuration.getMappedStatement(statement);\n        return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    &#125; catch (Exception e) &#123;\n        throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n&#125;\n\nMappedStatement其实就是我们mapper.xml的解析结果，放了很多的信息：\npublic final class MappedStatement &#123;\n\n  private String resource;\n  private Configuration configuration;\n  private String id;\n  private Integer fetchSize;\n  private Integer timeout;\n  private StatementType statementType;\n  private ResultSetType resultSetType;\n  private SqlSource sqlSource;\n  private Cache cache;\n  private ParameterMap parameterMap;\n  private List&lt;ResultMap> resultMaps;\n  private boolean flushCacheRequired;\n  private boolean useCache;\n  private boolean resultOrdered;\n  private SqlCommandType sqlCommandType;\n  ...省略\n\nexecutor是真正执行sql的一个执行器，它是一个接口，有具体的实现比如抽象类BaseExecutor，实现SimpleExecutor：\npublic interface Executor &#123;\n\n\n    int update(MappedStatement ms, Object parameter) throws SQLException;\n\n    &lt;E> List&lt;E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;\n\n    &lt;E> List&lt;E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;\n\n    &lt;E> Cursor&lt;E> queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException;\n\n    List&lt;BatchResult> flushStatements() throws SQLException;\n\n    void commit(boolean required) throws SQLException;\n\n    void rollback(boolean required) throws SQLException;\n\n    ...省略\n\n&#125;\n\n\n\n我们继续看 executor.query，在抽象类BaseExecutor它是这么实现的：\npublic abstract class BaseExecutor implements Executor\n\n@Override\npublic &lt;E> List&lt;E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    // 请注意这里创建了key\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n&#125;\n\n这里有一个核心方法queryFromDatabase\n@Override\npublic &lt;E> List&lt;E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;\n  ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId());\n  if (closed) &#123;\n    throw new ExecutorException(\"Executor was closed.\");\n  &#125;\n  if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;\n    clearLocalCache();\n  &#125;\n  List&lt;E> list;\n  try &#123;\n    queryStack++;\n     // 这里有【一级缓存】的影子，优先去缓存中取\n    list = resultHandler == null ? (List&lt;E>) localCache.getObject(key) : null;\n    if (list != null) &#123;\n      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n    &#125; else &#123;\n      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n    &#125;\n  &#125; finally &#123;\n    queryStack--;\n  &#125;\n  if (queryStack == 0) &#123;\n    for (DeferredLoad deferredLoad : deferredLoads) &#123;\n      deferredLoad.load();\n    &#125;\n    // issue #601\n    deferredLoads.clear();\n    if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;\n      // issue #482\n      clearLocalCache();\n    &#125;\n  &#125;\n  return list;\n&#125;\n\n从这里我们能看到【以及缓存的影子了】localCache，通过doQuery查询的结果，会放在localCache中。\nprivate &lt;E> List&lt;E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;\n    List&lt;E> list;\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try &#123;\n        // 核心方法\n        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    &#125; finally &#123;\n        localCache.removeObject(key);\n    &#125;\n    localCache.putObject(key, list);\n    if (ms.getStatementType() == StatementType.CALLABLE) &#123;\n        localOutputParameterCache.putObject(key, parameter);\n    &#125;\n    return list;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n原生的jdbc\n我们继续看实现：\npublic class SimpleExecutor extends BaseExecutor\n\n我们进入上边提及的doQuery，这里看到一下原生jdbc的影子了，比如stmt；\n@Override\npublic &lt;E> List&lt;E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;\n    Statement stmt = null;\n    try &#123;\n        Configuration configuration = ms.getConfiguration();\n        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n        // 获取prepareStatement\n        stmt = prepareStatement(handler, ms.getStatementLog());\n        return handler.query(stmt, resultHandler);\n    &#125; finally &#123;\n        closeStatement(stmt);\n    &#125;\n&#125;\n\n这里有几个方法：\n获取prepareStatement，这里看到了Connection：\nprivate Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;\n    Statement stmt;\n    Connection connection = getConnection(statementLog);\n    // 创建PreparedStatement\n    stmt = handler.prepare(connection, transaction.getTimeout());\n    // 填充占位符\n    handler.parameterize(stmt);\n    return stmt;\n&#125;\n\n继续深入：\npublic abstract class BaseStatementHandler implements StatementHandler\n\n@Override\npublic Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException &#123;\n    ErrorContext.instance().sql(boundSql.getSql());\n    Statement statement = null;\n    try &#123;\n        // 创建PreparedStatement\n        statement = instantiateStatement(connection);\n        setStatementTimeout(statement, transactionTimeout);\n        setFetchSize(statement);\n        return statement;\n    &#125; catch (SQLException e) &#123;\n        closeStatement(statement);\n        throw e;\n    &#125; catch (Exception e) &#123;\n        closeStatement(statement);\n        throw new ExecutorException(\"Error preparing statement.  Cause: \" + e, e);\n    &#125;\n&#125;\n\n继续深入，我们看到了熟悉的connection.prepareStatement(sql)：\npublic class PreparedStatementHandler extends BaseStatementHandler \n\n\n\n@Override\nprotected Statement instantiateStatement(Connection connection) throws SQLException &#123;\n    String sql = boundSql.getSql();\n    ... 省略\n&#125; else if (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;\n    return connection.prepareStatement(sql);\n&#125; else &#123;\n    return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);\n&#125;\n&#125;\n\n\n\n这里就是对占位符进行替换\n@Override\npublic void parameterize(Statement statement) throws SQLException &#123;\n    parameterHandler.setParameters((PreparedStatement) statement);\n&#125;\n\n@Override\n public void setParameters(PreparedStatement ps) &#123;\n   ErrorContext.instance().activity(\"setting parameters\").object(mappedStatement.getParameterMap().getId());\n   List&lt;ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n   if (parameterMappings != null) &#123;\n     for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;\n       ParameterMapping parameterMapping = parameterMappings.get(i);\n       if (parameterMapping.getMode() != ParameterMode.OUT) &#123;\n         Object value;\n         String propertyName = parameterMapping.getProperty();\n         if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params\n           value = boundSql.getAdditionalParameter(propertyName);\n         &#125; else if (parameterObject == null) &#123;\n           value = null;\n         &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;\n           value = parameterObject;\n         &#125; else &#123;\n           MetaObject metaObject = configuration.newMetaObject(parameterObject);\n           value = metaObject.getValue(propertyName);\n         &#125;\n         TypeHandler typeHandler = parameterMapping.getTypeHandler();\n         JdbcType jdbcType = parameterMapping.getJdbcType();\n         if (value == null &amp;&amp; jdbcType == null) &#123;\n           jdbcType = configuration.getJdbcTypeForNull();\n         &#125;\n         try &#123;\n           typeHandler.setParameter(ps, i + 1, value, jdbcType);\n         &#125; catch (TypeException | SQLException e) &#123;\n           throw new TypeException(\"Could not set parameters for mapping: \" + parameterMapping + \". Cause: \" + e, e);\n         &#125;\n       &#125;\n     &#125;\n   &#125;\n &#125;\n\n\n\n当前位置我们已经从头对MyBatis的源码撸了一遍，有帮助三连。\n4、别名系统\n\n\n\n\n\n\n\n\n思考：\n&lt;select id=\"getUsersByParams\" parameterType=\"java.util.HashMap\">\n    select id,username,password from user where username = #&#123;name&#125;\n&lt;/select>\n\nresultType写成java.util.HashMap也行，写成map也行，说明MyBatis内置很多别名，包括我们的配置中：\n&lt;environment id=\"development\">\n    &lt;transactionManager type=\"JDBC\"/>\n    &lt;dataSource type=\"POOLED\">\n        &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n        &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n        &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n    &lt;/dataSource>\n&lt;/environment>\n\n​\t\t其中为什么写一个POOLED就能代表我们使用了什么数据库连接池，其实这也是别名，简单理解就是可以用一个简单的短小的名字替代很长的类的权限定名称。\n其实：在构造Configuration类时，注册了如下的别名。\npublic Configuration() &#123;\n    typeAliasRegistry.registerAlias(\"JDBC\", JdbcTransactionFactory.class);\n    typeAliasRegistry.registerAlias(\"MANAGED\", ManagedTransactionFactory.class);\n\n    typeAliasRegistry.registerAlias(\"JNDI\", JndiDataSourceFactory.class);\n    typeAliasRegistry.registerAlias(\"POOLED\", PooledDataSourceFactory.class);\n    typeAliasRegistry.registerAlias(\"UNPOOLED\", UnpooledDataSourceFactory.class);\n\n    typeAliasRegistry.registerAlias(\"PERPETUAL\", PerpetualCache.class);\n    typeAliasRegistry.registerAlias(\"FIFO\", FifoCache.class);\n    typeAliasRegistry.registerAlias(\"LRU\", LruCache.class);\n    typeAliasRegistry.registerAlias(\"SOFT\", SoftCache.class);\n    typeAliasRegistry.registerAlias(\"WEAK\", WeakCache.class);\n\n    typeAliasRegistry.registerAlias(\"DB_VENDOR\", VendorDatabaseIdProvider.class);\n\n    typeAliasRegistry.registerAlias(\"XML\", XMLLanguageDriver.class);\n    typeAliasRegistry.registerAlias(\"RAW\", RawLanguageDriver.class);\n\n    typeAliasRegistry.registerAlias(\"SLF4J\", Slf4jImpl.class);\n    typeAliasRegistry.registerAlias(\"COMMONS_LOGGING\", JakartaCommonsLoggingImpl.class);\n    typeAliasRegistry.registerAlias(\"LOG4J\", Log4jImpl.class);\n    typeAliasRegistry.registerAlias(\"LOG4J2\", Log4j2Impl.class);\n    typeAliasRegistry.registerAlias(\"JDK_LOGGING\", Jdk14LoggingImpl.class);\n    typeAliasRegistry.registerAlias(\"STDOUT_LOGGING\", StdOutImpl.class);\n    typeAliasRegistry.registerAlias(\"NO_LOGGING\", NoLoggingImpl.class);\n\n    typeAliasRegistry.registerAlias(\"CGLIB\", CglibProxyFactory.class);\n    typeAliasRegistry.registerAlias(\"JAVASSIST\", JavassistProxyFactory.class);\n\n    languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);\n    languageRegistry.register(RawLanguageDriver.class);\n  &#125;\n\n在构造TypeAliasRegistry注册了如下的别名，我们可以在配置文件中使用以下的别名来代替这些类的权限定名。\npublic class TypeAliasRegistry &#123;\n\n  private final Map&lt;String, Class&lt;?>> typeAliases = new HashMap&lt;>();\n\n  public TypeAliasRegistry() &#123;\n    registerAlias(\"string\", String.class);\n\n    registerAlias(\"byte\", Byte.class);\n    registerAlias(\"long\", Long.class);\n    registerAlias(\"short\", Short.class);\n    registerAlias(\"int\", Integer.class);\n    registerAlias(\"integer\", Integer.class);\n    registerAlias(\"double\", Double.class);\n    registerAlias(\"float\", Float.class);\n    registerAlias(\"boolean\", Boolean.class);\n\n    registerAlias(\"byte[]\", Byte[].class);\n    registerAlias(\"long[]\", Long[].class);\n    registerAlias(\"short[]\", Short[].class);\n    registerAlias(\"int[]\", Integer[].class);\n    registerAlias(\"integer[]\", Integer[].class);\n    registerAlias(\"double[]\", Double[].class);\n    registerAlias(\"float[]\", Float[].class);\n    registerAlias(\"boolean[]\", Boolean[].class);\n\n    registerAlias(\"_byte\", byte.class);\n    registerAlias(\"_long\", long.class);\n    registerAlias(\"_short\", short.class);\n    registerAlias(\"_int\", int.class);\n    registerAlias(\"_integer\", int.class);\n    registerAlias(\"_double\", double.class);\n    registerAlias(\"_float\", float.class);\n    registerAlias(\"_boolean\", boolean.class);\n\n    registerAlias(\"_byte[]\", byte[].class);\n    registerAlias(\"_long[]\", long[].class);\n    registerAlias(\"_short[]\", short[].class);\n    registerAlias(\"_int[]\", int[].class);\n    registerAlias(\"_integer[]\", int[].class);\n    registerAlias(\"_double[]\", double[].class);\n    registerAlias(\"_float[]\", float[].class);\n    registerAlias(\"_boolean[]\", boolean[].class);\n\n    registerAlias(\"date\", Date.class);\n    registerAlias(\"decimal\", BigDecimal.class);\n    registerAlias(\"bigdecimal\", BigDecimal.class);\n    registerAlias(\"biginteger\", BigInteger.class);\n    registerAlias(\"object\", Object.class);\n\n    registerAlias(\"date[]\", Date[].class);\n    registerAlias(\"decimal[]\", BigDecimal[].class);\n    registerAlias(\"bigdecimal[]\", BigDecimal[].class);\n    registerAlias(\"biginteger[]\", BigInteger[].class);\n    registerAlias(\"object[]\", Object[].class);\n\n    registerAlias(\"map\", Map.class);\n    registerAlias(\"hashmap\", HashMap.class);\n    registerAlias(\"list\", List.class);\n    registerAlias(\"arraylist\", ArrayList.class);\n    registerAlias(\"collection\", Collection.class);\n    registerAlias(\"iterator\", Iterator.class);\n\n    registerAlias(\"ResultSet\", ResultSet.class);\n  &#125;\n\n\n\n\n\n当然我们可以给写的类定义别名：\n\n\n\n\n\n\n\n\n\n给自己类设定别名\n在核心配置文件中加入\n&lt;typeAliases>\n    &lt;typeAlias type=\"com.ydlclass.entity.User\"  alias=\"user\"/>\n&lt;/typeAliases>\n\n&lt;typeAlias&gt; 标签中 有 type 和 alias 两个属性\ntype 填写 实体类的全类名，alias 可以不填，不填的话，默认是类名，不区分大小写，\nalias 填了的话就以 alias里的值为准。\n&lt;typeAiases>\n    &lt;package name=\"\"/>\n&lt;/typeAliases>\n\n&lt;package&gt; 标签 为某个包下的所有类起别名； name 属性填写包名。 别名默认是类名，不区分大小写。\n@Alias&#96; 注解   加在实体类上，为某个类起别名；例：&#96;@Alias(&quot;User&quot;)\n\n\n\n七、resultMap详解如果数据库字段和实体的字段是一一对应，那么MyBatis会【自动映射】，但是如果不一致，比如一个叫user一个叫username，那么就需要我们手动的建立一一映射的关系了。\n有时候我们的数据库和字段和实例的字段可能不是一一对应，\n1、Java中的实体类设计\npublic class User &#123;\n\n   private int id;  \t\t    //id\n   private String name;   \t\t//姓名，数据库为username\n   private String password;     //密码，一致\n   \n   //构造\n   //set/get\n   //toString()\n&#125;\n\n3、mapper\n//根据id查询用户\nUser selectUserById(int id);\n\n4、mapper映射文件\n&lt;select id=\"selectUserById\" resultType=\"user\">\n  select * from user where id = #&#123;id&#125;\n&lt;/select>\n\n5、测试\n@Test\npublic void testSelectUserById() &#123;\n   UserMapper mapper = session.getMapper(UserMapper.class);\n   User user = mapper.selectUserById(1);\n   System.out.println(user);\n   session.close();\n&#125;\n\n\n结果:\n\nUser{id&#x3D;1, name&#x3D;’null’, password&#x3D;’123’}\n查询出来发现 name为空 . 说明出现了问题！\n\n分析：\n\nselect * from user where id &#x3D; #{id} 可以看做\nselect  id,username,password from user where id &#x3D; #{id}\n\nmybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 利用反射去对应的实体类中查找相应列名的set方法设值 ，当然找不到username\n\n\n\n\n\n\n\n\n\n\n\n解决方案\n方案一：为列名指定别名 , 别名和java实体类的属性名一致 .\n&lt;select id=\"selectUserById\" resultType=\"User\">\n  select id , username as name ,password from user where id = #&#123;id&#125;\n&lt;/select>\n\n方案二：使用结果集映射-&gt;ResultMap 【推荐】\n&lt;resultMap id=\"UserMap\" type=\"User\">\n   &lt;!-- id为主键 -->\n   &lt;id column=\"id\" property=\"id\"/>\n   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 -->\n   &lt;result column=\"username\" property=\"name\"/>\n   &lt;result column=\"password\" property=\"password\"/>\n&lt;/resultMap>\n\n&lt;select id=\"selectUserById\" resultMap=\"UserMap\">\n  select id , username , password from user where id = #&#123;id&#125;\n&lt;/select>\n\n\n\n\n\n\n\n\n\n\n结论：\n这个地方我们手动调整了映射关系，称之为【手动映射】。\n但如果不调整呢？\tMyBatis当然会按照约定自动映射。\n有了映射这种牛逼的事情之后：\n我们的：\nprepareStatement.setInt(1,21);\nprepareStatement.setString(2,\"IT楠老师\");\n\n还用写吗？两个字【牛逼】！\n\n\n\n\n\n\n\n\n\n当然约定的最基本的操作就是全部都一样，还有就是下划线和驼峰命名的自动转化\n&lt;settings>\n    &lt;!--开启驼峰命名规则-->\n    &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n&lt;/settings>\n\n\n\n\n\n\n\n\n\n\n\n\n自定义数据源\npublic class MyDataSource implements DataSourceFactory &#123;\n    private Properties properties;\n\n    @Override\n    public void setProperties(Properties properties) &#123;\n        this.properties = properties;\n    &#125;\n\n    @Override\n    public DataSource getDataSource() &#123;\n\n        HikariConfig hikariConfig = new HikariConfig(properties);\n        return new HikariDataSource(hikariConfig);\n    &#125;\n&#125;\n\n\n\nusername=root\npassword=root\njdbcUrl=jdbc:mysql://127.0.0.1:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&amp;useSSL=false\ndriverClassName=com.mysql.cj.jdbc.Driver\n\n\n\n\n\n八、动态sql-很重要1、 概述MyBatis提供了对SQL语句动态的组装能力，大量的判断都可以在 MyBatis的映射XML文件里面配置，以达到许多我们需要大量代码才能实现的功能，大大减少了我们编写代码的工作量。\n\n\n\n\n\n\n\n\n\n动态SQL的元素\n\n\n\n元素\n作用\n备注\n\n\n\nif\n判断语句\n单条件分支判断\n\n\nchoose、when、otherwise\n相当于Java中的 case when语句\n多条件分支判断\n\n\ntrim、where、set\n辅助元素\n用于处理一些SQL拼装问题\n\n\nforeach\n循环语句\n在in语句等列举条件常用\n\n\n2、if元素（非常常用）if元素相当于Java中的if语句，它常常与test属性联合使用。现在我们要根据name去查找学生，但是name是可选的，如下所示：\n&lt;select id=\"findUserById\" resultType=\"com.ydlclass.entity.User\">\n    select id,username,password from user\n    where 1 =1\n    &lt;if test=\"id != null\">\n        AND id = #&#123;id&#125;\n    &lt;/if>\n    &lt;if test=\"username != null and username != ''\">\n        AND username = #&#123;username&#125;\n    &lt;/if>\n    &lt;if test=\"password != null and password != ''\">\n        AND password = #&#123;password&#125;\n    &lt;/if>\n&lt;/select>\n\n\n\n3、where元素上面的select语句我们加了一个1=1的绝对true的语句，目的是为了防止语句错误，变成SELECT * FROM student WHERE这样where后没有内容的错误语句。这样会有点奇怪，此时可以使用&lt;where&gt;元素。\n&lt;select id=\"findUserById\" resultType=\"com.ydlclass.entity.User\">\n    select id,username,password from user\n    &lt;where>\n        &lt;if test=\"id != null\">\n            AND id = #&#123;id&#125;\n        &lt;/if>\n        &lt;if test=\"username != null and username != ''\">\n            AND username = #&#123;username&#125;\n        &lt;/if>\n        &lt;if test=\"password != null and password != ''\">\n            AND password = #&#123;password&#125;\n        &lt;/if>\n    &lt;/where>\n&lt;/select>\n\n\n\n4、trim元素有时候我们要去掉一些特殊的SQL语法，比如常见的and、or，此时可以使用trim元素。trim元素意味着我们需要去掉一些特殊的字符串，prefix代表的是语句的前缀，而prefixOverrides代表的是你需要去掉的那种字符串，suffix表示语句的后缀，suffixOverrides代表去掉的后缀字符串。\n&lt;select id=\"select\" resultType=\"com.ydlclass.entity.User\">\n    SELECT * FROM user\n    &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND\">\n        &lt;if test=\"username != null and username != ''\">\n            AND username LIKE concat('%', #&#123;username&#125;, '%')\n        &lt;/if>\n        &lt;if test=\"id != null\">\n            AND id = #&#123;id&#125;\n        &lt;/if>\n    &lt;/trim>\n&lt;/select>\n\n\n\n5、choose、when、otherwise元素\n\n\n\n\n\n\n\n\n选一个\n有些时候我们还需要多种条件的选择，在Java中我们可以使用switch、case、default语句，而在映射器的动态语句中可以使用choose、when、otherwise元素。\n&lt;!-- 有name的时候使用name搜索，没有的时候使用id搜索 -->\n&lt;select id=\"select\" resultType=\"com.ydlclass.entity.User\">\n    SELECT * FROM user\n    WHERE 1=1\n    &lt;choose>\n        &lt;when test=\"name != null and name != ''\">\n            AND username LIKE concat('%', #&#123;username&#125;, '%')\n        &lt;/when>\n        &lt;when test=\"id != null\">\n            AND id = #&#123;id&#125;\n        &lt;/when>\n    &lt;/choose>\n&lt;/select>\n\n\n\n6、set元素在update语句中，如果我们只想更新某几个字段的值，这个时候可以使用set元素配合if元素来完成。注意：set元素遇到,会自动把,去掉。\n&lt;update id=\"update\">\n    UPDATE user\n    &lt;set>\n        &lt;if test=\"username != null and username != ''\">\n            username = #&#123;username&#125;,\n        &lt;/if>\n        &lt;if test=\"password != null and password != ''\">\n            password = #&#123;password&#125;\n        &lt;/if>\n    &lt;/set>\n    WHERE id = #&#123;id&#125;\n&lt;/update>\n\n\n\n7、foreach元素foreach元素是一个循环语句，它的作用是遍历集合，可以支持数组、List、Set接口。\n&lt;select id=\"select\" resultType=\"com.ydlclass.entity.User\">\n    SELECT * FROM user\n    WHERE id IN\n    &lt;foreach collection=\"ids\" open=\"(\" close=\")\" separator=\",\" item=\"id\">\n        #&#123;id&#125;\n    &lt;/foreach>\n&lt;/select>\n\n\ncollection配置的是传递进来的参数名称。\nitem配置的是循环中当前的元素。\nindex配置的是当前元素在集合的位置下标。\nopen和 close配置的是以什么符号将这些集合元素包装起来。\nseparator是各个元素的间隔符。\n\n8、foreach批量插入&lt;insert id=\"batchInsert\" parameterType=\"list\">\n    insert into `user`( user_name, pass)\n    values\n    &lt;foreach collection=\"users\" item=\"user\" separator=\",\">\n        (#&#123;user.username&#125;, #&#123;user.password&#125;)\n    &lt;/foreach>\n\n&lt;/insert>\n\n\n\n\n9、SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n&lt;sql id=\"if-title-author\">\n   &lt;if test=\"title != null\">\n      title = #&#123;title&#125;\n   &lt;/if>\n   &lt;if test=\"author != null\">\n      and author = #&#123;author&#125;\n   &lt;/if>\n&lt;/sql>\n\n引用SQL片段：\n&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\">\n  select * from blog\n   &lt;where>\n       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace -->\n       &lt;include refid=\"if-title-author\">&lt;/include>\n       &lt;!-- 在这里还可以引用其他的 sql 片段 -->\n   &lt;/where>\n&lt;/select>\n\n\n\n\n\n九、数据关系处理\n部门和员工的关系，一个部门多个员工，一个员工属于一个部门\n那我们可以采取两种方式来维护关系，一种在一的一方，一种在多的一方！\n\n\n\n\n\n\n\n\n\n\n数据库设计\nCREATE TABLE `dept` (\n`id` INT(10) NOT NULL,\n`name` VARCHAR(30) DEFAULT NULL,\nPRIMARY KEY (`id`)\n);\n\nINSERT INTO dept VALUES (1, '元动力学习一组'),(2, '元动力学习二组');\n\nCREATE TABLE `employee` (\n`id` INT(10) NOT NULL,\n`name` VARCHAR(30) DEFAULT NULL,\n`did` INT(10) DEFAULT NULL,\nPRIMARY KEY (`id`),\nCONSTRAINT `fk_did` FOREIGN KEY (`did`) REFERENCES `dept` (`id`)\n) ;\n\n\nINSERT INTO employee VALUES (1, '邸智伟', 1),(2, '成虹', 2),(3, '康永亮', 1),(4, '杨春旺', 2),(5, '陈建强', 1);\n\n\n\n1、通过员工级联部门1、编写实体类\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Dept  implements Serializable&#123;\n    \n    private static final Long serialVersionUID = 1L;\n    \n    private int id;\n    private String name;\n    \n&#125;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Employee  implements Serializable &#123;\n    \n    private static final Long serialVersionUID = 1L;\n    \n    private int id;\n    private String name;\n    //维护关系\n    private Dept dept;\n&#125;\n\n2、编写实体类对应的Mapper接口 \npublic interface DeptMapper &#123;\n&#125;\npublic interface EmployeeMapper &#123;\n&#125;\n\n3、编写Mapper接口对应的 mapper.xml配置文件 \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.dao.DeptMapper\">\n\n&lt;/mapper>\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.dao.EmployeeMapper\">\n\n&lt;/mapper>\n\n4、将mapper进行注册、去mybatis-config文件中配置\n&lt;mapper resource=\"com/ydlclass/dao/DeptMapper.xml\"/>\n&lt;mapper resource=\"com/ydlclass/dao/EmployeeMapper.xml\"/>\n\n\n\n\n\n（1）按查询嵌套这种方式是一种级联查询的方式，会产生多个sql语句，第一个sql的查询语句结果会触发第二个查询语句。\n1、写方法\nList&lt;Employee> select(Employee employee);\n\n2、mapper处理\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.EmployeeMapper\">\n\n    &lt;resultMap id=\"employeeMap\" type=\"employee\">\n        &lt;id column=\"id\" property=\"id\" />\n        &lt;result column=\"name\" property=\"name\"/>\n        &lt;association property=\"dept\" column=\"did\" javaType=\"dept\"\n                     select=\"com.ydlclass.mapper.DeptMapper.select\">\n            &lt;id column=\"id\" property=\"id\"/>\n            &lt;result column=\"name\" property=\"name\"/>\n\n        &lt;/association>\n    &lt;/resultMap>\n\n    &lt;sql id=\"sql\">\n        `id`,`name`,`did`\n    &lt;/sql>\n\n\n    &lt;select id=\"select\" resultMap=\"employeeMap\">\n        select &lt;include refid=\"sql\" />\n        from employee\n    &lt;/select>\n\n&lt;/mapper>\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.DeptMapper\">\n\n    &lt;resultMap id=\"deptMap\" type=\"dept\">\n        &lt;id column=\"id\" property=\"id\"/>\n        &lt;result column=\"name\" property=\"name\"/>\n        &lt;collection property=\"employees\" javaType=\"list\" ofType=\"employee\"\n                    column=\"id\" select=\"com.ydlclass.mapper.EmployeeMapper.selectByDid\">\n            &lt;id column=\"eid\" property=\"id\"/>\n            &lt;result column=\"ename\" property=\"name\"/>\n        &lt;/collection>\n    &lt;/resultMap>\n\n    &lt;sql id=\"sql\">\n        `id`\n        ,`name`\n    &lt;/sql>\n\n    &lt;select id=\"select\" resultMap=\"deptMap\">\n        select\n        &lt;include refid=\"sql\"/>\n        from dept where id = #&#123;id&#125;\n    &lt;/select>\n\n&lt;/mapper>\n\n\n\n3、编写完毕去Mybatis配置文件中，注册Mapper\n4、测试\n@Test\npublic void testSelect() &#123;\n    try (SqlSession session = sqlSessionFactory.openSession(true)) &#123;\n        // statement是sql的申明\n        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);\n        List&lt;Employee> employees = mapper.select(new Employee());\n\n        log.debug(\"The employees are [&#123;&#125;]\",employees);\n    &#125;\n&#125;\n\n结果：\n\n（2）按结果嵌套结果嵌套是使用复杂查询，在根据结果的字段进行对象的封装，本质只会发送一个sql。\n1、接口方法编写\nList&lt;Employee> select2(Employee employee);\n\n2、编写对应的mapper文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.EmployeeMapper\">\n\n    &lt;resultMap id=\"employeeMap2\" type=\"employee\">\n        &lt;id column=\"eid\" property=\"id\" />\n        &lt;result column=\"ename\" property=\"name\"/>\n        &lt;association property=\"dept\" javaType=\"dept\" >\n            &lt;id column=\"did\" property=\"id\"/>\n            &lt;result column=\"dname\" property=\"name\"/>\n        &lt;/association>\n    &lt;/resultMap>\n\n    &lt;select id=\"select2\" resultMap=\"employeeMap2\" >\n        select e.id eid,e.name ename, d.id did,d.name dname\n        from employee e left join dept d\n                                  on d.id = e.did\n    &lt;/select>\n\n&lt;/mapper>\n\n4、测试\n@Test\npublic void testFindAllEmployees2() &#123;\n    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);\n    List&lt;Employee> allEmployees = mapper.findAllEmployees2();\n    for (Employee allEmployee : allEmployees) &#123;\n        System.out.println(allEmployee);\n    &#125;\n&#125;\n\n\n\n2、通过部门级联用户在部门处维护关系，此处可以联想订单和订单详情。\n修改实体类：\n@Data\npublic class Dept &#123;\n    private int id;\n    private String name;\n    //用于关系维护\n    List&lt;Employee> employees;\n&#125;\n\n@Data\npublic class Employee &#123;\n    private int id;\n    private String name;\n&#125;\n\n\n\n（1）按结果嵌套处理1、写方法\npublic interface DeptMapper &#123;\n    List&lt;Dept> select(Dept dept);\n&#125;\n\n2、写配置文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.DeptMapper\">\n\n    &lt;resultMap id=\"deptMap\" type=\"dept\">\n        &lt;id column=\"id\" property=\"id\"/>\n        &lt;result column=\"name\" property=\"name\"/>\n        &lt;collection property=\"employees\" javaType=\"list\" ofType=\"employee\"\n                    column=\"id\" select=\"com.ydlclass.mapper.EmployeeMapper.selectByDid\">\n            &lt;id column=\"eid\" property=\"id\"/>\n            &lt;result column=\"ename\" property=\"name\"/>\n        &lt;/collection>\n    &lt;/resultMap>\n\n    &lt;sql id=\"sql\">\n        `id`,`name`\n    &lt;/sql>\n\n    &lt;select id=\"select\" resultMap=\"deptMap\">\n        select\n        &lt;include refid=\"sql\"/>\n        from dept where id = #&#123;id&#125;\n    &lt;/select>\n\n&lt;/mapper>\n\n在EmployeeMapper中添加select进行级联查询\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.EmployeeMapper\">\n\n    &lt;resultMap id=\"employeeMap\" type=\"employee\">\n        &lt;id column=\"id\" property=\"id\" />\n        &lt;result column=\"name\" property=\"name\"/>\n        &lt;association property=\"dept\" column=\"did\" javaType=\"dept\"\n                     select=\"com.ydlclass.mapper.DeptMapper.select\">\n            &lt;id column=\"id\" property=\"id\"/>\n            &lt;result column=\"name\" property=\"name\"/>\n\n        &lt;/association>\n    &lt;/resultMap>\n\n    &lt;resultMap id=\"employeeMap2\" type=\"employee\">\n        &lt;id column=\"eid\" property=\"id\" />\n        &lt;result column=\"ename\" property=\"name\"/>\n        &lt;association property=\"dept\" javaType=\"dept\" >\n            &lt;id column=\"did\" property=\"id\"/>\n            &lt;result column=\"dname\" property=\"name\"/>\n        &lt;/association>\n    &lt;/resultMap>\n\n    &lt;select id=\"selectByDid\" resultMap=\"employeeMap2\" >\n        select id eid,name ename from employee where did=#&#123;did&#125;\n    &lt;/select>\n\n&lt;/mapper>\n\n3、测试\n@Test\npublic void testSelect() &#123;\n    try (SqlSession session = sqlSessionFactory.openSession(true)) &#123;\n        // statement是sql的申明\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        List&lt;Dept> depts = mapper.select(null);\n        log.debug(\"The depts are [&#123;&#125;]\", depts);\n    &#125;\n&#125;\n\n\n\n\n（2）按查询嵌套处理1、TeacherMapper接口编写方法\nList&lt;Dept> select2(Dept dept);\n\n2、编写接口对应的Mapper配置文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.DeptMapper\">\n    &lt;resultMap id=\"deptMap2\" type=\"dept\">\n        &lt;id column=\"did\" property=\"id\"/>\n        &lt;result column=\"dname\" property=\"name\"/>\n        &lt;collection property=\"employees\" javaType=\"list\" ofType=\"employee\">\n            &lt;id column=\"eid\" property=\"id\"/>\n            &lt;result column=\"ename\" property=\"name\"/>\n\n        &lt;/collection>\n    &lt;/resultMap>\n\n    &lt;sql id=\"sql\">\n        `id`,`name`\n    &lt;/sql>\n\n\n    &lt;select id=\"select2\" resultMap=\"deptMap2\">\n        select d.id did, d.name dname, e.id eid, e.name ename\n        from dept d\n                 left join employee e on d.id = e.did\n    &lt;/select>\n&lt;/mapper>\n\n3、测试\n@Test\npublic void testSelect2() &#123;\n    try (SqlSession session = sqlSessionFactory.openSession(true)) &#123;\n        // statement是sql的申明\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        List&lt;Dept> depts = mapper.select2(null);\n        log.debug(\"The depts are [&#123;&#125;]\", depts);\n    &#125;\n&#125;\n\n结果：\n\n3、小知识：（1）懒加载​\t\t通俗的讲就是按需加载，我们需要什么的时候再去进行什么操作。而且先从单表查询，需要时再从关联表去关联查询，能大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。\n　　在mybatis中，resultMap可以实现高级映射(使用association、collection实现一对一及一对多映射)，association、collection具备延迟加载功能。\n&lt;!-- 开启懒加载配置 -->\n&lt;settings>\n  &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 -->\n  &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n  &lt;!-- 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载 -->\n  &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n&lt;/settings>\n\n\n\n（2）Mybatis 获取自增主键的方式\n\n\n\n\n\n\n\n\n使用 xml\n直接在标签属性上添加 useGeneratedKeys（是否是自增长，必须设置 true） 和 keyProperty（实体类主键属性名称） 、keyColumn（数据库主键字段名称）\n&lt;insert id=\"insert\" useGeneratedKeys=\"true\" keyColumn=\"id\" keyProperty=\"id\">\n    insert into `user`(id, username, password)\n    values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)\n&lt;/insert>\n\n\n\n\n\n\n\n\n\n\n\n注解方式useGeneratedKeys（是否是自增长，必须设置 true） 和 keyProperty（实体类主键属性名称） 、keyColumn（数据库主键字段名称）\n@Insert(\"INSERT INTO user(name,age) VALUES(#&#123;user.name&#125;,#&#123;user.age&#125;)\")\n@Options(useGeneratedKeys=true, keyProperty=\"user.id\",keyColumn=\"id\"  )\npublic int insert(@Param(\"user\")User user);\n\n\n\n也可以全局设置\n&lt;setting name=\"useGeneratedKeys\" value=\"true\"/>\n\n\n\n\n\n十、Mybatis缓存1、为什么要用缓存？\n如果缓存中有数据，就不用从数据库获取，大大提高系统性能。\n\nMyBatis提供一级缓存和二级缓存\n\n\n2、一级缓存：\n\n\n\n\n\n\n\n\n一级缓存是sqlsession级别的缓存\n\n在操作数据库时，需要构造sqlsession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据\n不同的sqlsession之间的缓存区域是互相不影响的。\n\n\n\n\n\n\n\n\n\n\n一级缓存工作原理：\n图解：\n\n\n第一次发起查询sql查询用户id为1的用户，先去找缓存中是否有id为1的用户，如果没有，再去数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。\n\n如果sqlsession执行了commit操作（插入，更新，删除），会清空sqlsession中的一级缓存，避免脏读\n\n第二次发起查询id为1的用户，缓存中如果找到了，直接从缓存中获取用户信息\n\nMyBatis默认支持并开启一级缓存。\n\n\n\n\n\n\n\n\n\n\n\n一级缓存演示\n1、必须配置日志，要不看不见\n2、编写接口方法\n//根据id查询用户\nUser findUserById(@Param(\"id\") int id);\n\n3、接口对应的Mapper文件\n&lt;select id=\"findUserById\" resultType=\"com.ydlclass.entity.User\">\n  select * from user where id = #&#123;id&#125;\n&lt;/select>\n\n4、测试\n@Test\npublic void testFindUserById()&#123;\n    UserMapper mapper = session.getMapper(UserMapper.class);\n    User user1 = mapper.findUserById(1);\n    System.out.println(user1);\n    User user2 = mapper.findUserById(3);\n    System.out.println(user2);\n    User user3 = mapper.findUserById(1);\n    System.out.println(user3);\n&#125;\n\n5、通过日志分析\n[com.ydlclass.dao.UserMapper.findUserById]-==>  Preparing: select id,username,password from user where id = ? \n[com.ydlclass.dao.UserMapper.findUserById]-==> Parameters: 1(Integer)\n[com.ydlclass.dao.UserMapper.findUserById]-&lt;==      Total: 1\nUser&#123;id=1, username='楠哥', password='123456'&#125;         ---->ID为1，第一次有sql\n[com.ydlclass.dao.UserMapper.findUserById]-==>  Preparing: select id,username,password from user where id = ? \n[com.ydlclass.dao.UserMapper.findUserById]-==> Parameters: 3(Integer)\n[com.ydlclass.dao.UserMapper.findUserById]-&lt;==      Total: 1\nUser&#123;id=3, username='磊哥', password='987654'&#125;         ---->ID为3，第一次有sql\nUser&#123;id=1, username='楠哥', password='123456'&#125;         ---->ID为1，第二次无sql，走缓存\n\n\n\n\n\n\n\n\n\n\n\n\n一级缓存失效\n\nsqlSession不同\n当sqlSession对象相同的时候，查询的条件不同，原因是第一次查询时候，一级缓存中没有第二次查询所需要的数据\n当sqlSession对象相同，两次查询之间进行了插入的操作\n当sqlSession对象相同，手动清除了一级缓存中的数据\n\n\n\n\n\n\n\n\n\n\n一级缓存生命周期\n\nMyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。\n\n如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。\n\n如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。\n\nSqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用。\n\n\n3、二级缓存：\n\n\n\n\n\n\n\n\n二级缓存是mapper级别的缓存\n\n多个sqlsession去操作同一个mapper的sql语句，多个sqlsession可以共用二级缓存，所得到的数据会存在二级缓存区域\n二级缓存是跨sqlsession的\n二级缓存相比一级缓存的范围更大（按namespace来划分），多个sqlsession可以共享一个二级缓存\n\n\n\n\n\n\n\n\n\n\n\n二级缓存实现原理\n\n首先要手动开启MyBatis二级缓存。\n在config.xml设置二级缓存开关 ， 还要在具体的mapper.xml开启二级缓存\n&lt;settings>\n    &lt;!--开启二级缓存-->\n    &lt;setting name=\"cacheEnabled\" value=\"true\"/>       \n&lt;/settings>\n&lt;!-- 需要将映射的javabean类实现序列化 -->\n\n​          class Student implements Serializable{}\n&lt;!--开启本Mapper的namespace下的二级缓存-->\n&lt;cache eviction=\"LRU\" flushInterval=\"100000\"/>\n\n\n\n（1）cache属性的简介：\n\n\n\n\n\n\n\n\neviction回收策略（缓存满了的淘汰机制），目前MyBatis提供以下策略。\n\nLRU（Least Recently Used），最近最少使用的，最长时间不用的对象\nFIFO（First In First Out），先进先出，按对象进入缓存的顺序来移除他们\nSOFT，软引用，移除基于垃圾回收器状态和软引用规则的对象，当内存不足，会触发JVM的GC，如果GC后，内存还是不足，就会把软引用的包裹的对象给干掉，也就是只有内存不足，JVM才会回收该对象。\nWEAK，弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。弱引用的特点是不管内存是否足够，只要发生GC，都会被回收。\n\n\n\n\n\n\n\n\n\n\nflushInterval:刷新间隔时间，单位为毫秒，\n\n这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存。\n\n\n\n\n\n\n\n\n\n\nsize:引用数目，\n\n一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。\n这里配置的是1024个对象\n\n\n\n\n\n\n\n\n\n\n\n**readOnly:**只读，\n\n意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有\n办法修改缓存，它的默认值是false，不允许我们修改\n\n\n（2）操作过程：sqlsession1查询用户id为1的信息，查询到之后，会将查询数据存储到二级缓存中。\n如果sqlsession3去执行相同mapper下sql，执行commit提交，会清空该mapper下的二级缓存区域的数据\nsqlsession2查询用户id为1的信息， 去缓存找是否存在缓存，如果存在直接从缓存中取数据\n\n\n\n\n\n\n\n\n\n禁用二级缓存：\n在statement中可以设置useCache&#x3D;false，禁用当前select语句的二级缓存，默认情况为true\n&lt;select id=\"getStudentById\" parameterType=\"java.lang.Integer\" resultType=\"Student\" useCache=\"false\">\n\n在实际开发中，针对每次查询都需要最新的数据sql，要设置为useCache&#x3D;”false” ，禁用二级缓存\n\n\n\n\n\n\n\n\n\nflushCache标签：刷新缓存（清空缓存）\n&lt;select id=\"getStudentById\" parameterType=\"java.lang.Integer\" resultType=\"Student\" flushCache=\"true\">\n\n一般下执行完commit操作都需要刷新缓存，flushCache&#x3D;”true 表示刷新缓存，可以避免脏读\n\n\n\n\n\n\n\n\n\n二级缓存应用场景\n对于访问多的查询请求并且用户对查询结果实时性要求不高的情况下，可采用MyBatis二级缓存，降低数据库访问量，提高访问速度，如电话账单查询\n根据需求设置相应的flushInterval：刷新间隔时间，比如三十分钟，24小时等。\n\n\n\n\n\n\n\n\n\n二级缓存局限性：\n MyBatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用MyBatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为MyBatis的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。\n\n\n\n\n\n\n\n\n\n二级缓存演示\n先不进行配置\n@Test\npublic void testFindUserCache() throws Exception &#123;\n\n    //使用不同的mapper\n    UserMapper mapper1 = session.getMapper(UserMapper.class);\n    User user1 = mapper1.findUserById(1);\n    System.out.println(user1);\n    //提交了就会刷到二级缓存，要不还在一级缓存，一定要注意\n    session.commit();\n    UserMapper mapper2 = session.getMapper(UserMapper.class);\n    User user2 = mapper2.findUserById(1);\n    System.out.println(user2);\n    System.out.println(user1 == user2);\n&#125;\n\n结果：\n[com.ydlclass.dao.UserMapper.findUserById]-==>  Preparing: select id,username,password from user where id = ? \n[com.ydlclass.dao.UserMapper.findUserById]-==> Parameters: 1(Integer)\n[com.ydlclass.dao.UserMapper.findUserById]-&lt;==      Total: 1\nUser&#123;id=1, username='楠哥', password='123456'&#125;\n[com.ydlclass.dao.UserMapper.findUserById]-==>  Preparing: select id,username,password from user where id = ? \n[com.ydlclass.dao.UserMapper.findUserById]-==> Parameters: 1(Integer)\n[com.ydlclass.dao.UserMapper.findUserById]-&lt;==      Total: 1\nUser&#123;id=1, username='楠哥', password='123456'&#125;\nfalse               ---->两个对象不是一个，发了两个sql，说明缓存没有起作用\n\n可以看见两次同样的sql，却都进库进行了查询。说明二级缓存没开。\n\n\n\n\n\n\n\n\n\n配置二级缓存\n1、开启全局缓存\n&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n\n2、使用二级缓存，这个写在mapper里\n&lt;!--开启本Mapper的namespace下的二级缓存-->\n&lt;cache eviction=\"LRU\" flushInterval=\"100000\" size=\"512\" readOnly=\"true\">&lt;/cache>\n&lt;!--\n创建了一个 LRU 最少使用清除缓存，每隔 100 秒刷新，最多可以存储 512 个对象，返回的对象是只读的。\n-->\n\n3、测试执行\n[com.ydlclass.dao.UserMapper.findUserById]-==>  Preparing: select id,username,password from user where id = ? \n[com.ydlclass.dao.UserMapper.findUserById]-==> Parameters: 1(Integer)\n[com.ydlclass.dao.UserMapper.findUserById]-&lt;==      Total: 1\nUser&#123;id=1, username='楠哥', password='123456'&#125;\n[com.ydlclass.dao.UserMapper]-Cache Hit Ratio [com.ydlclass.dao.UserMapper]: 0.5\nUser&#123;id=1, username='楠哥', password='123456'&#125;\ntrue                  ---->两个对象一样了，就发了一个sql，说明缓存起了作用\n\n\n\n\n\n4、第三方缓存–EhCache充当二级缓存\n\n\n\n\n\n\n\n\n此外还有很多第三方缓存组件，最常用的比如ehcache，Memcached、redis等，我们以比较简单的ehcache为例。\n1、引入依赖\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache -->\n&lt;dependency>\n   &lt;groupId>org.mybatis.caches&lt;/groupId>\n   &lt;artifactId>mybatis-ehcache&lt;/artifactId>\n   &lt;version>1.2.1&lt;/version>\n&lt;/dependency>\n\n2、修改mapper.xml中使用对应的缓存\n&lt;mapper namespace = “com.ydlclass.entity.User” > \n       &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\" eviction=\"LRU\" flushInterval=\"10000\" size=\"1024\" readOnly=\"true\"/>\n&lt;/mapper>\n\n3、添加ehcache.xml文件，ehcache配置文件，具体配置自行百度\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n        updateCheck=\"false\">\n   &lt;!--\n      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n      user.home – 用户主目录\n      user.dir – 用户当前工作目录\n      java.io.tmpdir – 默认临时文件路径\n    -->\n   &lt;diskStore path=\"./tmpdir/Tmp_EhCache\"/>\n   \n   &lt;defaultCache\n           eternal=\"false\"\n           maxElementsInMemory=\"10000\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           timeToIdleSeconds=\"1800\"\n           timeToLiveSeconds=\"259200\"\n           memoryStoreEvictionPolicy=\"LRU\"/>\n\n&lt;/ehcache>\n\n&lt;!--     \n       name:缓存名称。     \n       maxElementsInMemory：缓存最大个数。     \n       eternal:对象是否永久有效，一但设置了，timeout将不起作用。     \n       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。     \n       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。     \n       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。     \n       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。     \n       maxElementsOnDisk：硬盘最大缓存个数。     \n       diskPersistent：是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false。   \n       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     \n       clearOnFlush：内存数量最大时是否清除。     \n    --> \n\n3、测试\n5、使用缓存独立控制\n\n\n\n\n\n\n\n\n其实我们更加常见的是使用第三方的缓存进行存储，并且自由控制\n&lt;dependency>\n    &lt;groupId>net.sf.ehcache&lt;/groupId>\n    &lt;artifactId>ehcache&lt;/artifactId>\n    &lt;version>2.10.3&lt;/version>\n&lt;/dependency>  \n\n\n\n\n\n\n\n\n\n\n\n\n测试一下\nfinal CacheManager cacheManager = new CacheManager(this.getClass().getClassLoader().getResourceAsStream(\"ehcache.xml\"));\n\n// create the cache called \"hello-world\"\nString[] cacheNames = cacheManager.getCacheNames();\nfor (String cacheName : cacheNames) &#123;\n    System.out.println(cacheName);\n&#125;\nCache userDao = cacheManager.getCache(\"userDao\");\nElement element = new Element(\"testFindUserById_1\",new User(1,\"q\",\"d\"));\nuserDao.put(element);\n\nElement element1 = userDao.get(\"testFindUserById_1\");\nUser user = (User)element1.getObjectValue();\nSystem.out.println(user);\n\n\n\n\n\n\n\n\n\n\n\n\n创建工具类\n/**\n * @author zn\n * @date 2021/1/28\n */\npublic class CacheUtil &#123;\n\n    private static CacheManager cacheManager = new CacheManager(CacheUtil.class.getClassLoader().getResourceAsStream(\"ehcache.xml\"));\n\n    public static void put(String cacheName,String key,Object value)&#123;\n        Cache cache = cacheManager.getCache(cacheName);\n        Element element = new Element(key,value);\n        cache.put(element);\n    &#125;\n\n    public static Object get(String cacheName,String key)&#123;\n        Cache cache = cacheManager.getCache(cacheName);\n        return cache.get(key).getObjectValue();\n\n    &#125;\n\n    public static boolean  delete(String cacheName,String key)&#123;\n        Cache cache = cacheManager.getCache(cacheName);\n        return cache.remove(key);\n    &#125;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n测试\n@Test\npublic void selectDeptsTest()&#123;\n\n    Map&lt;String,Object> cache = new HashMap&lt;>(8);\n    // 执行方法\n    List&lt;Dept> depts = deptMapper.selectDepts();\n    CacheUtil.put(\"dept\",\"selectUserByIdTest\",depts);\n    System.out.println(depts);\n    session.commit();\n\n    session = sqlSessionFactory.openSession();\n    // 去缓存拿，如果有就拿出来\n    List&lt;Dept> newDepts = null;\n    Object object = CacheUtil.get(\"dept\", \"selectUserByIdTest\");\n    if(object == null)&#123;\n        // 去数据库查询\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        newDepts = mapper.selectDepts();\n    &#125; else &#123;\n        newDepts = (List&lt;Dept>) object;\n    &#125;\n\n    System.out.println(newDepts);\n&#125;\n\n\n\n\n\n十一、配置文件\n\n\n\n\n\n\n\n\nMyBatis的配置文件分为核心配置文件和mapper配置文件\n\nmybatis-config.xml 系统核心配置文件\n\n核心配置文件主要配置Mybatis一些基础组件和加载资源，核心配置文件中的元素常常能影响Mybatis的整个运行过程。\n\n能配置的内容如下，顺序不能乱：\n\n\n1.properties是一个配置属性的元素\n2.settings设置，mybatis最为复杂的配置也是最重要的，会改变mybatis运行时候的行为\n3.typeAliases别名（在TypeAliasRegistry中可以看到mybatis提供了许多的系统别名）\n4.typeHandlers 类型处理器（比如在预处理语句中设置一个参数或者从结果集中获取一个参数时候，都会用到类型处理器，在TypeHandlerRegistry中定义了很多的类型处理器）\n5.objectFactory 对象工厂（myabtis在构建一个结果返回的时候，会使用一个ObjectFactory去构建pojo)\n6.plugins 插件\n7.environments 环境变量\n  environment 环境变量\n   transactionManager 事务管理器\n   dataSource 数据源\n   databaseIdProvider 数据库厂商标识\n8.mappers 映射器\n\n\n\n\n\n\n\n\n\n\n\n\n找几个重要的讲解一下\n1、environments元素environments可以为mybatis配置多环境运行，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定），如果想切换环境修改default的值即可。\n\n\n\n\n\n\n\n\n\n最常见的就是，生产环境和开发环境，两个环境切换必将导致数据库的切换。\n&lt;environments default=\"development\">\n &lt;environment id=\"development\">\n   &lt;transactionManager type=\"JDBC\">\n     &lt;property name=\"...\" value=\"...\"/>\n   &lt;/transactionManager>\n   &lt;dataSource type=\"POOLED\">\n     &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n     &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n     &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n     &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n   &lt;/dataSource>\n &lt;/environment>\n    \n  &lt;environment id=\"product\">\n       &lt;transactionManager type=\"JDBC\">\n         &lt;property name=\"...\" value=\"...\"/>\n       &lt;/transactionManager>\n       &lt;dataSource type=\"POOLED\">\n         &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n         &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n         &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n         &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n       &lt;/dataSource>\n &lt;/environment>\n&lt;/environments>\n\n\n\n\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n\n数据源是必须配置的。\n\n有三种内建的数据源类型\ntype&#x3D;&quot;[UNPOOLED|POOLED|JNDI]&quot;）\n- unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。\n- pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。\n- jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。\n\n数据源也有很多第三方的实现，比如druid，hikari，dbcp，c3p0等等….\n\n这两种事务管理器类型都不需要设置任何属性。\n\n具体的一套环境，通过设置id进行区别，id保证唯一！\n\n子元素节点：transactionManager - [ 事务管理器 ]\n&lt;!-- 语法 --&gt;\n&lt;transactionManager type&#x3D;&quot;[ JDBC | MANAGED ]&quot;&#x2F;&gt;\n\n子元素节点：数据源（dataSource）\n\n\n2、mappers元素\n\n\n\n\n\n\n\n\nmappers的存在就是要对写好的mapper和xml进行统一管理\n要不然系统怎么知道我写了哪些mapper\n通常这么引入\n&lt;mappers>\n    &lt;!-- 使用相对于类路径的资源引用 -->\n    &lt;mapper resource=\"com/ydlclass/dao/userMapper.xml\"/>\n    &lt;!-- 面向注解时使用全类名 -->\n    &lt;mapper class=\"com.ydlclass.dao.AdminMapper\"/>\n&lt;/mappers>\n\n。。。还有其他的方式\n\nMapper文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n       PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.ydlclass.mapper.UserMapper\">\n   \n&lt;/mapper>\n\n\nnamespace中文意思：命名空间，作用如下：\nnamespace的命名必须跟某个接口同名，这才能找的到啊！\n\n3、Properties元素数据库连接信息我们最好放在一个单独的文件中。\n1、 在资源目录下新建一个db.properties\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8\nusername=root\npassword=root\n\n2、 将文件导入properties 配置文件\n&lt;configuration>\n   &lt;!--导入properties文件-->\n   &lt;properties resource=\"db.properties\"/>\n\n   &lt;environments default=\"development\">\n       &lt;environment id=\"development\">\n           &lt;transactionManager type=\"JDBC\"/>\n           &lt;dataSource type=\"POOLED\">\n               &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n               &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n               &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n               &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n           &lt;/dataSource>\n       &lt;/environment>\n   &lt;/environments>\n   &lt;mappers>\n       &lt;mapper resource=\"mapper/UserMapper.xml\"/>\n   &lt;/mappers>\n&lt;/configuration>\n\n\n\n4、其他配置浏览\n\n\n\n\n\n\n\n\nsettings能对我的一些核心功能进行配置，如懒加载、日志实现、缓存开启关闭等\n\n\n\n\n\n\n\n\n\n简单参数说明\n\n\n\n设置参数\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n该配置影响的所有映射器中配置的缓存的全局开关。\ntrue | false\ntrue\n\n\nlazyLoadingEnabled\n延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。\ntrue | false\nfalse\n\n\nuseColumnLabel\n使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。\ntrue | false\ntrue\n\n\nuseGeneratedKeys\n允许 JDBC 支持自动生成主键，需要驱动兼容。如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。\ntrue | false\nFalse\n\n\ndefaultStatementTimeout\n设置超时时间，它决定驱动等待数据库响应的秒数。\nAny positive integer\nNot Set (null)\n\n\nmapUnderscoreToCamelCase\n是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。\ntrue | false\nFalse\n\n\nlogPrefix\n指定 MyBatis 增加到日志名称的前缀。\nAny String\nNot set\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\nNot set\n\n\n\n\n\n\n\n\n\n\n\n完整的 settings 元素，有很多可以配置的选项，需要大家慢慢自己学习：\n&lt;settings>\n    &lt;!---->\n     &lt;setting name=\"cacheEnabled\" value=\"true\"/>\n    &lt;!---->\n     &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    &lt;!---->\n     &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n     &lt;setting name=\"useColumnLabel\" value=\"true\"/>\n     &lt;setting name=\"useGeneratedKeys\" value=\"false\"/>\n     &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\n     &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/>\n     &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\n     &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/>\n     &lt;setting name=\"defaultFetchSize\" value=\"100\"/>\n     &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/>\n     &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/>\n     &lt;setting name=\"localCacheScope\" value=\"SESSION\"/>\n     &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/>\n     &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/>\n&lt;/settings>\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mybatis","date":"2022-10-13T03:10:00.000Z","categories_index":"java,框架","tags_index":"java,框架","author_index":"Leixng"}]